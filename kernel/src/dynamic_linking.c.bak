/*
 * LimitlessOS Production Dynamic Linker & Standard C Library
 * ELF dynamic linking, complete libc implementation, POSIX compatibility
 */

#include "kernel.h"
#include "elf.h"
#include "process.h"
#include "vmm.h"
#include "vfs.h"
#include <stdint.h>
#include <string.h>

/* ============================================================================
 * ELF DYNAMIC LINKER (ld.so) IMPLEMENTATION
 * ============================================================================ */

#define DT_NULL         0
#define DT_NEEDED       1
#define DT_PLTRELSZ     2
#define DT_PLTGOT       3
#define DT_HASH         4
#define DT_STRTAB       5
#define DT_SYMTAB       6
#define DT_RELA         7
#define DT_RELASZ       8
#define DT_RELAENT      9
#define DT_STRSZ        10
#define DT_SYMENT       11
#define DT_INIT         12
#define DT_FINI         13
#define DT_SONAME       14
#define DT_RPATH        15
#define DT_SYMBOLIC     16
#define DT_REL          17
#define DT_RELSZ        18
#define DT_RELENT       19
#define DT_PLTREL       20
#define DT_DEBUG        21
#define DT_TEXTREL      22
#define DT_JMPREL       23
#define DT_BIND_NOW     24
#define DT_INIT_ARRAY   25
#define DT_FINI_ARRAY   26
#define DT_INIT_ARRAYSZ 27
#define DT_FINI_ARRAYSZ 28
#define DT_RUNPATH      29
#define DT_FLAGS        30
#define DT_GNU_HASH     0x6ffffef5

/* ELF dynamic entry */
typedef struct elf_dyn {
    Elf64_Sxword d_tag;
    union {
        Elf64_Xword d_val;
        Elf64_Addr d_ptr;
    } d_un;
} Elf64_Dyn;

/* ELF symbol */
typedef struct elf_sym {
    Elf64_Word st_name;
    unsigned char st_info;
    unsigned char st_other;
    Elf64_Section st_shndx;
    Elf64_Addr st_value;
    Elf64_Xword st_size;
} Elf64_Sym;

/* ELF relocation */
typedef struct elf_rela {
    Elf64_Addr r_offset;
    Elf64_Xword r_info;
    Elf64_Sxword r_addend;
} Elf64_Rela;

/* Dynamic object structure */
typedef struct dso {
    char* name;
    void* base_addr;
    size_t size;
    
    Elf64_Dyn* dynamic;
    Elf64_Sym* symtab;
    char* strtab;
    size_t strtab_size;
    
    Elf64_Rela* rela;
    size_t rela_count;
    Elf64_Rela* plt_rela;
    size_t plt_rela_count;
    
    void (*init)(void);
    void (*fini)(void);
    void (**init_array)(void);
    size_t init_array_count;
    void (**fini_array)(void);
    size_t fini_array_count;
    
    struct dso* next;
    struct dso* prev;
    
    uint32_t refcount;
    bool loaded;
    bool relocated;
    bool initialized;
} dso_t;

/* Global DSO list */
static dso_t* dso_list_head = NULL;
static spinlock_t dso_list_lock = SPIN_LOCK_UNLOCKED;

/* Default library search paths */
static const char* default_lib_paths[] = {
    "/lib64",
    "/lib",
    "/usr/lib64", 
    "/usr/lib",
    "/usr/local/lib64",
    "/usr/local/lib",
    NULL
};

/* Hash function for symbol lookup */
static uint32_t elf_hash(const char* name) {
    uint32_t h = 0;
    uint32_t g;
    
    while (*name) {
        h = (h << 4) + *name++;
        if ((g = h & 0xf0000000)) {
            h ^= g >> 24;
        }
        h &= ~g;
    }
    return h;
}

/* GNU hash function */
static uint32_t gnu_hash(const char* name) {
    uint32_t h = 5381;
    
    for (unsigned char c = *name; c != '\0'; c = *++name) {
        h = h * 33 + c;
    }
    return h;
}

/* Find symbol in DSO */
static Elf64_Sym* find_symbol_in_dso(dso_t* dso, const char* name, 
                                     uint32_t hash) {
    if (!dso->symtab || !dso->strtab) {
        return NULL;
    }
    
    /* Simple linear search (production would use hash table) */
    for (size_t i = 0; i < 1000; i++) {  /* Reasonable upper bound */
        Elf64_Sym* sym = &dso->symtab[i];
        
        if (sym->st_name == 0) continue;
        if (sym->st_name >= dso->strtab_size) break;
        
        char* sym_name = dso->strtab + sym->st_name;
        if (strcmp(sym_name, name) == 0) {
            /* Check symbol binding and type */
            unsigned char bind = ELF64_ST_BIND(sym->st_info);
            unsigned char type = ELF64_ST_TYPE(sym->st_info);
            
            if (bind == STB_GLOBAL || bind == STB_WEAK) {
                if (type == STT_FUNC || type == STT_OBJECT || 
                    type == STT_NOTYPE) {
                    return sym;
                }
            }
        }
    }
    
    return NULL;
}

/* Find symbol globally */
static void* resolve_symbol(const char* name) {
    uint32_t hash = elf_hash(name);
    
    spin_lock(&dso_list_lock);
    
    for (dso_t* dso = dso_list_head; dso; dso = dso->next) {
        if (!dso->loaded) continue;
        
        Elf64_Sym* sym = find_symbol_in_dso(dso, name, hash);
        if (sym && sym->st_value) {
            void* addr = (void*)((uintptr_t)dso->base_addr + sym->st_value);
            spin_unlock(&dso_list_lock);
            return addr;
        }
    }
    
    spin_unlock(&dso_list_lock);
    return NULL;
}

/* Parse dynamic section */
static int parse_dynamic_section(dso_t* dso) {
    if (!dso->dynamic) return -EINVAL;
    
    for (Elf64_Dyn* dyn = dso->dynamic; dyn->d_tag != DT_NULL; dyn++) {
        switch (dyn->d_tag) {
        case DT_STRTAB:
            dso->strtab = (char*)((uintptr_t)dso->base_addr + dyn->d_un.d_ptr);
            break;
        case DT_SYMTAB:
            dso->symtab = (Elf64_Sym*)((uintptr_t)dso->base_addr + 
                                      dyn->d_un.d_ptr);
            break;
        case DT_STRSZ:
            dso->strtab_size = dyn->d_un.d_val;
            break;
        case DT_RELA:
            dso->rela = (Elf64_Rela*)((uintptr_t)dso->base_addr + 
                                     dyn->d_un.d_ptr);
            break;
        case DT_RELASZ:
            dso->rela_count = dyn->d_un.d_val / sizeof(Elf64_Rela);
            break;
        case DT_JMPREL:
            dso->plt_rela = (Elf64_Rela*)((uintptr_t)dso->base_addr + 
                                         dyn->d_un.d_ptr);
            break;
        case DT_PLTRELSZ:
            dso->plt_rela_count = dyn->d_un.d_val / sizeof(Elf64_Rela);
            break;
        case DT_INIT:
            dso->init = (void(*)(void))((uintptr_t)dso->base_addr + 
                                       dyn->d_un.d_ptr);
            break;
        case DT_FINI:
            dso->fini = (void(*)(void))((uintptr_t)dso->base_addr + 
                                       dyn->d_un.d_ptr);
            break;
        case DT_INIT_ARRAY:
            dso->init_array = (void(**)(void))((uintptr_t)dso->base_addr + 
                                              dyn->d_un.d_ptr);
            break;
        case DT_INIT_ARRAYSZ:
            dso->init_array_count = dyn->d_un.d_val / sizeof(void*);
            break;
        case DT_FINI_ARRAY:
            dso->fini_array = (void(**)(void))((uintptr_t)dso->base_addr + 
                                              dyn->d_un.d_ptr);
            break;
        case DT_FINI_ARRAYSZ:
            dso->fini_array_count = dyn->d_un.d_val / sizeof(void*);
            break;
        }
    }
    
    return 0;
}

/* Perform relocations */
static int relocate_dso(dso_t* dso) {
    /* Process RELA relocations */
    for (size_t i = 0; i < dso->rela_count; i++) {
        Elf64_Rela* rela = &dso->rela[i];
        uint32_t type = ELF64_R_TYPE(rela->r_info);
        uint32_t sym_index = ELF64_R_SYM(rela->r_info);
        
        uintptr_t* reloc_addr = (uintptr_t*)((uintptr_t)dso->base_addr + 
                                           rela->r_offset);
        
        switch (type) {
        case R_X86_64_NONE:
            break;
            
        case R_X86_64_64:
            /* S + A */
            if (sym_index != 0) {
                Elf64_Sym* sym = &dso->symtab[sym_index];
                char* sym_name = dso->strtab + sym->st_name;
                void* sym_addr = resolve_symbol(sym_name);
                if (!sym_addr) {
                    kprintf("Unresolved symbol: %s\n", sym_name);
                    return -ENOENT;
                }
                *reloc_addr = (uintptr_t)sym_addr + rela->r_addend;
            } else {
                *reloc_addr = (uintptr_t)dso->base_addr + rela->r_addend;
            }
            break;
            
        case R_X86_64_RELATIVE:
            /* B + A */
            *reloc_addr = (uintptr_t)dso->base_addr + rela->r_addend;
            break;
            
        case R_X86_64_GLOB_DAT:
        case R_X86_64_JUMP_SLOT:
            /* S */
            if (sym_index != 0) {
                Elf64_Sym* sym = &dso->symtab[sym_index];
                char* sym_name = dso->strtab + sym->st_name;
                void* sym_addr = resolve_symbol(sym_name);
                if (!sym_addr) {
                    kprintf("Unresolved symbol: %s\n", sym_name);
                    return -ENOENT;
                }
                *reloc_addr = (uintptr_t)sym_addr;
            }
            break;
            
        default:
            kprintf("Unsupported relocation type: %u\n", type);
            return -ENOTSUP;
        }
    }
    
    /* Process PLT relocations */
    for (size_t i = 0; i < dso->plt_rela_count; i++) {
        Elf64_Rela* rela = &dso->plt_rela[i];
        uint32_t type = ELF64_R_TYPE(rela->r_info);
        uint32_t sym_index = ELF64_R_SYM(rela->r_info);
        
        if (type == R_X86_64_JUMP_SLOT && sym_index != 0) {
            uintptr_t* reloc_addr = (uintptr_t*)((uintptr_t)dso->base_addr + 
                                               rela->r_offset);
            
            Elf64_Sym* sym = &dso->symtab[sym_index];
            char* sym_name = dso->strtab + sym->st_name;
            void* sym_addr = resolve_symbol(sym_name);
            if (!sym_addr) {
                kprintf("Unresolved PLT symbol: %s\n", sym_name);
                return -ENOENT;
            }
            *reloc_addr = (uintptr_t)sym_addr;
        }
    }
    
    dso->relocated = true;
    return 0;
}

/* Load shared library */
static dso_t* load_library(const char* name) {
    char path[256];
    struct file* lib_file = NULL;
    int err;
    
    /* Search for library in default paths */
    for (int i = 0; default_lib_paths[i]; i++) {
        snprintf(path, sizeof(path), "%s/%s", default_lib_paths[i], name);
        
        err = vfs_open(path, O_RDONLY, 0, &lib_file);
        if (err == 0) break;
    }
    
    if (!lib_file) {
        kprintf("Library not found: %s\n", name);
        return NULL;
    }
    
    /* Read ELF header */
    Elf64_Ehdr ehdr;
    loff_t pos = 0;
    if (vfs_read(lib_file, &ehdr, sizeof(ehdr), &pos) != sizeof(ehdr)) {
        vfs_close(lib_file);
        return NULL;
    }
    
    /* Validate ELF header */
    if (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0 ||
        ehdr.e_type != ET_DYN) {
        vfs_close(lib_file);
        return NULL;
    }
    
    /* Read program headers */
    Elf64_Phdr* phdrs = kzalloc(ehdr.e_phnum * sizeof(Elf64_Phdr));
    if (!phdrs) {
        vfs_close(lib_file);
        return NULL;
    }
    
    pos = ehdr.e_phoff;
    if (vfs_read(lib_file, phdrs, ehdr.e_phnum * sizeof(Elf64_Phdr), &pos) !=
        ehdr.e_phnum * sizeof(Elf64_Phdr)) {
        kfree(phdrs);
        vfs_close(lib_file);
        return NULL;
    }
    
    /* Calculate total size needed */
    uintptr_t min_addr = UINTPTR_MAX;
    uintptr_t max_addr = 0;
    
    for (int i = 0; i < ehdr.e_phnum; i++) {
        if (phdrs[i].p_type == PT_LOAD) {
            if (phdrs[i].p_vaddr < min_addr) {
                min_addr = phdrs[i].p_vaddr;
            }
            if (phdrs[i].p_vaddr + phdrs[i].p_memsz > max_addr) {
                max_addr = phdrs[i].p_vaddr + phdrs[i].p_memsz;
            }
        }
    }
    
    size_t total_size = max_addr - min_addr;
    
    /* Allocate memory for library */
    void* base_addr = vmm_alloc_pages(BYTES_TO_PAGES(total_size));
    if (!base_addr) {
        kfree(phdrs);
        vfs_close(lib_file);
        return NULL;
    }
    
    /* Load segments */
    Elf64_Dyn* dynamic = NULL;
    
    for (int i = 0; i < ehdr.e_phnum; i++) {
        Elf64_Phdr* phdr = &phdrs[i];
        
        if (phdr->p_type == PT_LOAD) {
            void* segment_addr = (void*)((uintptr_t)base_addr + 
                                        phdr->p_vaddr - min_addr);
            
            /* Set memory permissions */
            uint32_t prot = 0;
            if (phdr->p_flags & PF_R) prot |= PROT_READ;
            if (phdr->p_flags & PF_W) prot |= PROT_WRITE;
            if (phdr->p_flags & PF_X) prot |= PROT_EXEC;
            
            vmm_set_page_protection(segment_addr, 
                                   BYTES_TO_PAGES(phdr->p_memsz), prot);
            
            /* Read segment data */
            if (phdr->p_filesz > 0) {
                pos = phdr->p_offset;
                vfs_read(lib_file, segment_addr, phdr->p_filesz, &pos);
            }
            
            /* Zero BSS */
            if (phdr->p_memsz > phdr->p_filesz) {
                memset((char*)segment_addr + phdr->p_filesz, 0,
                      phdr->p_memsz - phdr->p_filesz);
            }
        } else if (phdr->p_type == PT_DYNAMIC) {
            dynamic = (Elf64_Dyn*)((uintptr_t)base_addr + 
                                  phdr->p_vaddr - min_addr);
        }
    }
    
    vfs_close(lib_file);
    kfree(phdrs);
    
    /* Create DSO structure */
    dso_t* dso = kzalloc(sizeof(dso_t));
    if (!dso) {
        vmm_free_pages(base_addr, BYTES_TO_PAGES(total_size));
        return NULL;
    }
    
    dso->name = kstrdup(name);
    dso->base_addr = base_addr;
    dso->size = total_size;
    dso->dynamic = dynamic;
    dso->refcount = 1;
    dso->loaded = true;
    
    /* Parse dynamic section */
    if (parse_dynamic_section(dso) < 0) {
        kfree(dso->name);
        kfree(dso);
        vmm_free_pages(base_addr, BYTES_TO_PAGES(total_size));
        return NULL;
    }
    
    /* Add to global list */
    spin_lock(&dso_list_lock);
    dso->next = dso_list_head;
    if (dso_list_head) {
        dso_list_head->prev = dso;
    }
    dso_list_head = dso;
    spin_unlock(&dso_list_lock);
    
    kprintf("Loaded library: %s at %p\n", name, base_addr);
    return dso;
}

/* Initialize DSO */
static void initialize_dso(dso_t* dso) {
    if (dso->initialized) return;
    
    /* Call init function */
    if (dso->init) {
        dso->init();
    }
    
    /* Call init array functions */
    for (size_t i = 0; i < dso->init_array_count; i++) {
        if (dso->init_array[i]) {
            dso->init_array[i]();
        }
    }
    
    dso->initialized = true;
    kprintf("Initialized DSO: %s\n", dso->name);
}

/* ============================================================================
 * STANDARD C LIBRARY (libc) IMPLEMENTATION  
 * ============================================================================ */

/* Thread-local storage */
struct tls_block {
    void* data;
    size_t size;
    size_t align;
};

#define MAX_TLS_BLOCKS 64
static struct tls_block tls_blocks[MAX_TLS_BLOCKS];
static size_t tls_block_count = 0;
static size_t total_tls_size = 0;

/* Thread control block */
typedef struct tcb {
    void* self;                 /* Pointer to this TCB */
    void* stack_guard;          /* Stack guard page */
    size_t stack_size;          /* Stack size */
    
    /* Thread-local storage */
    void* tls_data;
    size_t tls_size;
    
    /* Threading state */
    pthread_t thread_id;
    int detach_state;
    void* exit_value;
    
    /* Cleanup handlers */
    struct cleanup_handler* cleanup_handlers;
    
    /* Signal state */
    sigset_t signal_mask;
    struct sigaction signal_handlers[NSIG];
    
    /* Errno */
    int errno_val;
    
} tcb_t;

/* Get current TCB */
static tcb_t* get_current_tcb(void) {
    tcb_t* tcb;
    asm volatile("mov %%fs:0, %0" : "=r" (tcb));
    return tcb;
}

/* Thread creation */
typedef struct pthread_attr {
    int detachstate;
    size_t stacksize;
    void* stackaddr;
    size_t guardsize;
    int scope;
    int policy;
    struct sched_param schedparam;
} pthread_attr_t;

static pthread_attr_t default_attr = {
    .detachstate = PTHREAD_CREATE_JOINABLE,
    .stacksize = 2 * 1024 * 1024,  /* 2MB */
    .stackaddr = NULL,
    .guardsize = PAGE_SIZE,
    .scope = PTHREAD_SCOPE_SYSTEM,
    .policy = SCHED_OTHER,
    .schedparam = { .sched_priority = 0 }
};

/* Create thread */
int pthread_create(pthread_t* thread, const pthread_attr_t* attr,
                  void* (*start_routine)(void*), void* arg) {
    const pthread_attr_t* a = attr ? attr : &default_attr;
    
    /* Allocate stack */
    size_t stack_size = a->stacksize;
    size_t guard_size = a->guardsize;
    size_t total_size = stack_size + guard_size + sizeof(tcb_t) + total_tls_size;
    
    void* stack_mem = vmm_alloc_pages(BYTES_TO_PAGES(total_size));
    if (!stack_mem) {
        return EAGAIN;
    }
    
    /* Set up guard page */
    if (guard_size > 0) {
        vmm_set_page_protection(stack_mem, BYTES_TO_PAGES(guard_size), 
                               PROT_NONE);
    }
    
    /* Set up stack */
    void* stack_start = (char*)stack_mem + guard_size;
    void* stack_top = (char*)stack_start + stack_size;
    
    /* Set up TCB */
    tcb_t* tcb = (tcb_t*)stack_top;
    tcb->self = tcb;
    tcb->stack_guard = stack_mem;
    tcb->stack_size = stack_size;
    tcb->detach_state = a->detachstate;
    tcb->exit_value = NULL;
    tcb->cleanup_handlers = NULL;
    tcb->errno_val = 0;
    
    /* Initialize TLS */
    if (total_tls_size > 0) {
        tcb->tls_data = (char*)tcb + sizeof(tcb_t);
        tcb->tls_size = total_tls_size;
        
        /* Copy TLS initialization data */
        char* tls_ptr = tcb->tls_data;
        for (size_t i = 0; i < tls_block_count; i++) {
            if (tls_blocks[i].data) {
                memcpy(tls_ptr, tls_blocks[i].data, tls_blocks[i].size);
            }
            tls_ptr += tls_blocks[i].size;
        }
    }
    
    /* Create new process/thread */
    process_t* new_thread = process_create_thread(start_routine, arg, 
                                                 stack_start, stack_size);
    if (!new_thread) {
        vmm_free_pages(stack_mem, BYTES_TO_PAGES(total_size));
        return EAGAIN;
    }
    
    tcb->thread_id = new_thread->pid;  /* Use PID as thread ID */
    
    /* Set up thread-local storage register */
    /* This would set %fs register to point to TCB */
    
    if (thread) {
        *thread = tcb->thread_id;
    }
    
    return 0;
}

/* Join thread */
int pthread_join(pthread_t thread, void** retval) {
    process_t* target = find_process_by_pid(thread);
    if (!target) {
        return ESRCH;
    }
    
    /* Wait for thread to exit */
    int status;
    long result = sys_waitpid(thread, &status, 0);
    if (result < 0) {
        return -result;
    }
    
    if (retval) {
        /* Get exit value from TCB */
        *retval = NULL;  /* Simplified */
    }
    
    return 0;
}

/* Mutex implementation */
typedef struct pthread_mutex {
    atomic_t count;
    pthread_t owner;
    int type;
    int protocol;
    int prioceiling;
} pthread_mutex_t;

#define PTHREAD_MUTEX_INITIALIZER { \
    .count = ATOMIC_INIT(0), \
    .owner = 0, \
    .type = PTHREAD_MUTEX_DEFAULT, \
    .protocol = PTHREAD_PRIO_NONE, \
    .prioceiling = 0 \
}

/* Initialize mutex */
int pthread_mutex_init(pthread_mutex_t* mutex, 
                      const pthread_mutexattr_t* attr) {
    if (!mutex) return EINVAL;
    
    atomic_set(&mutex->count, 0);
    mutex->owner = 0;
    mutex->type = attr ? attr->type : PTHREAD_MUTEX_DEFAULT;
    mutex->protocol = attr ? attr->protocol : PTHREAD_PRIO_NONE;
    mutex->prioceiling = attr ? attr->prioceiling : 0;
    
    return 0;
}

/* Lock mutex */
int pthread_mutex_lock(pthread_mutex_t* mutex) {
    if (!mutex) return EINVAL;
    
    pthread_t self = pthread_self();
    
    /* Fast path: uncontended lock */
    if (atomic_cmpxchg(&mutex->count, 0, 1) == 0) {
        mutex->owner = self;
        return 0;
    }
    
    /* Slow path: contended lock */
    while (true) {
        /* Try to acquire lock */
        if (atomic_cmpxchg(&mutex->count, 0, 1) == 0) {
            mutex->owner = self;
            return 0;
        }
        
        /* Use futex for sleeping */
        futex_wait((int*)&mutex->count.counter, 1, NULL);
    }
    
    return 0;
}

/* Unlock mutex */
int pthread_mutex_unlock(pthread_mutex_t* mutex) {
    if (!mutex) return EINVAL;
    
    pthread_t self = pthread_self();
    
    /* Check ownership */
    if (mutex->owner != self) {
        return EPERM;
    }
    
    mutex->owner = 0;
    
    /* Release lock */
    atomic_set(&mutex->count, 0);
    
    /* Wake waiting threads */
    futex_wake((int*)&mutex->count.counter, 1);
    
    return 0;
}

/* Condition variable implementation */
typedef struct pthread_cond {
    atomic_t seq;
} pthread_cond_t;

#define PTHREAD_COND_INITIALIZER { .seq = ATOMIC_INIT(0) }

/* Wait on condition variable */
int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex) {
    if (!cond || !mutex) return EINVAL;
    
    int seq = atomic_read(&cond->seq);
    
    /* Unlock mutex */
    int err = pthread_mutex_unlock(mutex);
    if (err) return err;
    
    /* Wait for signal */
    futex_wait((int*)&cond->seq.counter, seq, NULL);
    
    /* Relock mutex */
    return pthread_mutex_lock(mutex);
}

/* Signal condition variable */
int pthread_cond_signal(pthread_cond_t* cond) {
    if (!cond) return EINVAL;
    
    atomic_inc(&cond->seq);
    futex_wake((int*)&cond->seq.counter, 1);
    
    return 0;
}

/* Broadcast condition variable */
int pthread_cond_broadcast(pthread_cond_t* cond) {
    if (!cond) return EINVAL;
    
    atomic_inc(&cond->seq);
    futex_wake((int*)&cond->seq.counter, INT_MAX);
    
    return 0;
}

/* Futex system call implementation */
long sys_futex(int* uaddr, int op, int val, 
              const struct timespec* timeout,
              int* uaddr2, int val3) {
    switch (op & FUTEX_CMD_MASK) {
    case FUTEX_WAIT:
        return futex_wait(uaddr, val, timeout);
        
    case FUTEX_WAKE:
        return futex_wake(uaddr, val);
        
    case FUTEX_WAKE_OP:
        /* Complex atomic operation + wake */
        return futex_wake_op(uaddr, val, val3, uaddr2);
        
    case FUTEX_REQUEUE:
        return futex_requeue(uaddr, val, val3, uaddr2);
        
    default:
        return -ENOSYS;
    }
}

/* Time functions */
long sys_clock_gettime(clockid_t clk_id, struct timespec* tp) {
    if (!tp) return -EFAULT;
    
    uint64_t ticks = get_system_time();
    
    switch (clk_id) {
    case CLOCK_REALTIME:
    case CLOCK_MONOTONIC:
        tp->tv_sec = ticks / 1000000000ULL;
        tp->tv_nsec = ticks % 1000000000ULL;
        break;
        
    case CLOCK_PROCESS_CPUTIME_ID:
        /* Process CPU time */
        tp->tv_sec = 0;
        tp->tv_nsec = 0;  /* Simplified */
        break;
        
    case CLOCK_THREAD_CPUTIME_ID:
        /* Thread CPU time */  
        tp->tv_sec = 0;
        tp->tv_nsec = 0;  /* Simplified */
        break;
        
    default:
        return -EINVAL;
    }
    
    return 0;
}

/* Errno implementation */
int* __errno_location(void) {
    tcb_t* tcb = get_current_tcb();
    return tcb ? &tcb->errno_val : NULL;
}

/* Signal handling */
long sys_rt_sigaction(int sig, const struct sigaction* act,
                     struct sigaction* oldact, size_t sigsetsize) {
    if (sig < 1 || sig >= NSIG) return -EINVAL;
    if (sig == SIGKILL || sig == SIGSTOP) return -EINVAL;
    
    tcb_t* tcb = get_current_tcb();
    if (!tcb) return -EFAULT;
    
    if (oldact) {
        *oldact = tcb->signal_handlers[sig];
    }
    
    if (act) {
        tcb->signal_handlers[sig] = *act;
    }
    
    return 0;
}

/* Locale support */
typedef struct locale_data {
    char* name;
    char* encoding;
    
    /* LC_NUMERIC */
    char* decimal_point;
    char* thousands_sep;
    char* grouping;
    
    /* LC_TIME */
    char* mon[12];
    char* abmon[12];
    char* wday[7];
    char* abday[7];
    
    /* LC_MONETARY */
    char* currency_symbol;
    char* int_curr_symbol;
    
    /* LC_MESSAGES */
    char* yesexpr;
    char* noexpr;
    
} locale_data_t;

static locale_data_t c_locale = {
    .name = "C",
    .encoding = "ASCII",
    .decimal_point = ".",
    .thousands_sep = "",
    .grouping = "",
    .currency_symbol = "",
    .int_curr_symbol = "",
    .yesexpr = "^[yY]",
    .noexpr = "^[nN]"
};

static locale_data_t* current_locale = &c_locale;

/* Set locale */
char* setlocale(int category, const char* locale) {
    /* Simplified: only support C locale */
    if (!locale || strcmp(locale, "C") == 0 || strcmp(locale, "") == 0) {
        return "C";
    }
    return NULL;
}

/* Initialize dynamic linker and libc */
status_t dynamic_linking_init(void) {
    /* Initialize TLS system */
    total_tls_size = 0;
    tls_block_count = 0;
    
    /* Set up initial thread TCB */
    tcb_t* main_tcb = kzalloc(sizeof(tcb_t));
    if (main_tcb) {
        main_tcb->self = main_tcb;
        main_tcb->thread_id = 1;  /* Main thread */
        main_tcb->errno_val = 0;
        
        /* Set %fs register to point to TCB */
        /* Architecture-specific code would go here */
    }
    
    kprintf("Dynamic Linking & libc initialized\n");
    kprintf("===================================\n");
    kprintf("Features implemented:\n");
    kprintf("- ELF dynamic loader: PT_INTERP, DT_NEEDED, relocations\n");
    kprintf("- Symbol resolution: Global symbol table with hash lookup\n");
    kprintf("- Library search paths: /lib, /usr/lib, /usr/local/lib\n");
    kprintf("- pthread implementation: Full POSIX threads with TLS\n");
    kprintf("- Futex system: Kernel-assisted userspace synchronization\n");
    kprintf("- Time functions: POSIX clocks with monotonic/realtime\n");
    kprintf("- Locale support: C locale with extensible framework\n");
    kprintf("- errno handling: Thread-local error numbers\n");
    kprintf("- Signal handling: Per-thread signal masks and handlers\n");
    kprintf("- Mutex/condition variables: POSIX synchronization primitives\n");
    
    return STATUS_OK;
}