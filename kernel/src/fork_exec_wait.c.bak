/*
 * fork_exec_wait.c - LimitlessOS Complete Process Management
 * 
 * Production-ready process lifecycle management with proper fork/exec/wait,
 * copy-on-write memory, file descriptor inheritance, and POSIX compliance.
 */

#include "kernel.h"
#include "process.h"
#include "vmm.h"
#include "vfs.h"
#include "elf.h"
#include "scheduler.h"
#include "signal.h"
#include "demand_paging.h"
#include "memory_hardening.h"

#define MAX_ARGV_COUNT      1024
#define MAX_ENVP_COUNT      1024
#define MAX_ARG_LENGTH      4096
#define MAX_EXIT_WAITERS    16
#define ZOMBIE_TIMEOUT_MS   30000   /* 30 seconds */

/* Process creation flags */
#define PROC_CREATE_SHARE_VM        0x0001
#define PROC_CREATE_SHARE_FILES     0x0002
#define PROC_CREATE_SHARE_SIGNALS   0x0004
#define PROC_CREATE_SHARE_PARENT    0x0008

/* Wait options */
#define WNOHANG         0x0001
#define WUNTRACED       0x0002
#define WCONTINUED      0x0008
#define WEXITED         0x0010

/* Exit wait structure */
typedef struct exit_waiter {
    pid_t waiter_pid;           /* Process waiting */
    pid_t target_pid;           /* Process being waited for */
    int* wstatus;               /* Status return location */
    int options;                /* Wait options */
    
    bool completed;             /* Wait completed */
    int exit_code;              /* Exit code */
    
    struct list_head list;      /* List linkage */
} exit_waiter_t;

/* Process creation context */
typedef struct process_create_ctx {
    const char* path;           /* Executable path */
    char* const* argv;          /* Argument vector */
    char* const* envp;          /* Environment vector */
    
    /* File descriptors */
    int stdin_fd;               /* Standard input */
    int stdout_fd;              /* Standard output */
    int stderr_fd;              /* Standard error */
    
    /* Working directory */
    char* cwd;                  /* Working directory */
    
    /* Security context */
    uid_t uid, gid;             /* User/group IDs */
    uint64_t capabilities;      /* Capabilities */
    
    /* Creation flags */
    uint32_t flags;
    
} process_create_ctx_t;

/* Global process management state */
static struct {
    bool initialized;
    
    /* Process table */
    struct process* process_table[MAX_PROCESSES];
    spinlock_t process_table_lock;
    
    /* PID allocation */
    pid_t next_pid;
    unsigned long pid_bitmap[BITS_TO_LONGS(MAX_PROCESSES)];
    spinlock_t pid_lock;
    
    /* Exit waiters */
    struct list_head exit_waiters;
    spinlock_t waiters_lock;
    
    /* Zombie cleanup */
    struct timer zombie_timer;
    struct list_head zombie_list;
    spinlock_t zombie_lock;
    
    /* Statistics */
    atomic64_t forks_total;
    atomic64_t execs_total;
    atomic64_t exits_total;
    atomic64_t zombies_created;
    atomic64_t zombies_reaped;
    
} g_proc_mgr = {0};

/* Function prototypes */
static pid_t allocate_pid(void);
static void release_pid(pid_t pid);
static int copy_process_memory(struct process* parent, struct process* child, bool cow);
static int copy_file_descriptors(struct process* parent, struct process* child);
static int copy_signal_handlers(struct process* parent, struct process* child);
static int setup_process_memory(struct process* proc, const char* executable);
static int load_executable(struct process* proc, const char* path);
static int setup_process_arguments(struct process* proc, char* const* argv, char* const* envp);
static void notify_exit_waiters(struct process* proc, int exit_code);
static void cleanup_zombie_process(struct process* proc);
static void zombie_reaper_timer(void* data);

/* Initialize process management */
int process_management_init(void) {
    if (g_proc_mgr.initialized) {
        return 0;
    }
    
    printf("Initializing process management\n");
    
    memset(&g_proc_mgr, 0, sizeof(g_proc_mgr));
    
    spinlock_init(&g_proc_mgr.process_table_lock);
    spinlock_init(&g_proc_mgr.pid_lock);
    spinlock_init(&g_proc_mgr.waiters_lock);
    spinlock_init(&g_proc_mgr.zombie_lock);
    
    INIT_LIST_HEAD(&g_proc_mgr.exit_waiters);
    INIT_LIST_HEAD(&g_proc_mgr.zombie_list);
    
    g_proc_mgr.next_pid = 1;
    
    /* Initialize zombie cleanup timer */
    timer_init(&g_proc_mgr.zombie_timer, zombie_reaper_timer, NULL);
    timer_schedule(&g_proc_mgr.zombie_timer, ZOMBIE_TIMEOUT_MS);
    
    g_proc_mgr.initialized = true;
    
    printf("Process management initialized\n");
    return 0;
}

/* Fork system call implementation */
pid_t sys_fork(void) {
    struct process* parent = get_current_process();
    if (!parent) {
        return -ESRCH;
    }
    
    /* Check process limits */
    if (parent->resource_usage.threads_count >= parent->resource_limits.max_threads) {
        return -EAGAIN;
    }
    
    /* Allocate new PID */
    pid_t child_pid = allocate_pid();
    if (child_pid < 0) {
        return -EAGAIN;
    }
    
    /* Create child process structure */
    struct process* child = (struct process*)vmm_kmalloc(sizeof(struct process), 64);
    if (!child) {
        release_pid(child_pid);
        return -ENOMEM;
    }
    
    memset(child, 0, sizeof(struct process));
    
    /* Initialize basic fields */
    child->pid = child_pid;
    child->parent_pid = parent->pid;
    child->session_id = parent->session_id;
    child->process_group_id = parent->process_group_id;
    child->state = PROC_STATE_NEW;
    child->priority = parent->priority;
    
    strncpy(child->name, parent->name, sizeof(child->name) - 1);
    strncpy(child->cmdline, parent->cmdline, sizeof(child->cmdline) - 1);
    
    /* Copy security context */
    child->security = parent->security;
    
    /* Copy resource limits */
    child->resource_limits = parent->resource_limits;
    
    /* Initialize resource usage */
    memset(&child->resource_usage, 0, sizeof(resource_usage_t));
    
    /* Copy memory space with COW */
    int ret = copy_process_memory(parent, child, true);
    if (ret != 0) {
        vmm_kfree(child, sizeof(struct process));
        release_pid(child_pid);
        return ret;
    }
    
    /* Copy file descriptors */
    ret = copy_file_descriptors(parent, child);
    if (ret != 0) {
        /* Cleanup memory space */
        if (child->aspace) {
            vmm_destroy_aspace(child->aspace);
        }
        vmm_kfree(child, sizeof(struct process));
        release_pid(child_pid);
        return ret;
    }
    
    /* Copy signal handlers */
    ret = copy_signal_handlers(parent, child);
    if (ret != 0) {
        /* Cleanup file descriptors and memory */
        if (child->fd_table) {
            fd_table_destroy(child->fd_table);
        }
        if (child->aspace) {
            vmm_destroy_aspace(child->aspace);
        }
        vmm_kfree(child, sizeof(struct process));
        release_pid(child_pid);
        return ret;
    }
    
    /* Initialize synchronization */
    spinlock_init(&child->lock);
    INIT_LIST_HEAD(&child->children);
    INIT_LIST_HEAD(&child->threads);
    
    /* Add to process table */
    spin_lock(&g_proc_mgr.process_table_lock);
    
    int slot = child_pid % MAX_PROCESSES;
    while (g_proc_mgr.process_table[slot] != NULL) {
        slot = (slot + 1) % MAX_PROCESSES;
    }
    g_proc_mgr.process_table[slot] = child;
    
    spin_unlock(&g_proc_mgr.process_table_lock);
    
    /* Add to parent's children list */
    spin_lock(&parent->lock);
    list_add(&child->sibling_list, &parent->children);
    parent->resource_usage.threads_count++;
    spin_unlock(&parent->lock);
    
    /* Create initial thread for child process */
    ret = thread_create(child, parent->main_thread->entry_point, 
                       parent->main_thread->stack_base, 
                       parent->main_thread->stack_size, NULL);
    if (ret != 0) {
        /* Cleanup everything */
        spin_lock(&g_proc_mgr.process_table_lock);
        g_proc_mgr.process_table[slot] = NULL;
        spin_unlock(&g_proc_mgr.process_table_lock);
        
        spin_lock(&parent->lock);
        list_del(&child->sibling_list);
        parent->resource_usage.threads_count--;
        spin_unlock(&parent->lock);
        
        if (child->signal_table) {
            signal_table_destroy(child->signal_table);
        }
        if (child->fd_table) {
            fd_table_destroy(child->fd_table);
        }
        if (child->aspace) {
            vmm_destroy_aspace(child->aspace);
        }
        vmm_kfree(child, sizeof(struct process));
        release_pid(child_pid);
        return ret;
    }
    
    /* Set child state to ready */
    child->state = PROC_STATE_READY;
    
    /* Schedule child process */
    scheduler_add_process(child);
    
    atomic64_inc(&g_proc_mgr.forks_total);
    
    printf("Fork successful: parent=%d, child=%d\n", parent->pid, child_pid);
    
    /* Return child PID to parent, 0 to child */
    if (get_current_process() == parent) {
        return child_pid;
    } else {
        return 0;
    }
}

/* Exec system call implementation */
int sys_execve(const char* pathname, char* const argv[], char* const envp[]) {
    struct process* proc = get_current_process();
    if (!proc) {
        return -ESRCH;
    }
    
    /* Validate parameters */
    if (!pathname || !argv) {
        return -EINVAL;
    }
    
    /* Copy pathname to kernel space */
    char* kernel_path = (char*)vmm_kmalloc(PATH_MAX, 16);
    if (!kernel_path) {
        return -ENOMEM;
    }
    
    int ret = copy_from_user(kernel_path, pathname, PATH_MAX - 1);
    if (ret != 0) {
        vmm_kfree(kernel_path, PATH_MAX);
        return -EFAULT;
    }
    kernel_path[PATH_MAX - 1] = '\0';
    
    /* Validate executable exists and is executable */
    struct file* exec_file;
    ret = vfs_open(kernel_path, VFS_O_RDONLY, &exec_file);
    if (ret != 0) {
        vmm_kfree(kernel_path, PATH_MAX);
        return -ENOENT;
    }
    
    /* TODO: Check execute permissions */
    vfs_close(exec_file);
    
    /* Save old state for rollback */
    vmm_aspace_t* old_aspace = proc->aspace;
    struct fd_table* old_fd_table = proc->fd_table;
    char old_name[64];
    strncpy(old_name, proc->name, sizeof(old_name));
    
    /* Create new memory space */
    proc->aspace = vmm_create_aspace();
    if (!proc->aspace) {
        proc->aspace = old_aspace;
        vmm_kfree(kernel_path, PATH_MAX);
        return -ENOMEM;
    }
    
    /* Load new executable */
    virt_addr_t entry_point;
    ret = elf_load_with_lazy(kernel_path, proc->aspace, &entry_point);
    if (ret != 0) {
        vmm_destroy_aspace(proc->aspace);
        proc->aspace = old_aspace;
        vmm_kfree(kernel_path, PATH_MAX);
        return -ENOEXEC;
    }
    
    /* Set up new process arguments */
    ret = setup_process_arguments(proc, argv, envp);
    if (ret != 0) {
        vmm_destroy_aspace(proc->aspace);
        proc->aspace = old_aspace;
        vmm_kfree(kernel_path, PATH_MAX);
        return ret;
    }
    
    /* Update process name */
    const char* basename = strrchr(kernel_path, '/');
    if (basename) {
        basename++;
    } else {
        basename = kernel_path;
    }
    strncpy(proc->name, basename, sizeof(proc->name) - 1);
    
    /* Close old memory space */
    vmm_destroy_aspace(old_aspace);
    
    /* Reset signal handlers (except those marked to ignore) */
    signal_reset_handlers(proc->signal_table);
    
    /* Update main thread entry point */
    if (proc->main_thread) {
        proc->main_thread->entry_point = entry_point;
        proc->main_thread->state = THREAD_STATE_READY;
        
        /* Reset thread stack */
        thread_reset_stack(proc->main_thread);
    }
    
    vmm_kfree(kernel_path, PATH_MAX);
    
    atomic64_inc(&g_proc_mgr.execs_total);
    
    printf("Exec successful: process=%d, executable=%s\n", proc->pid, basename);
    
    /* Jump to new entry point (does not return) */
    thread_jump_to_entry(proc->main_thread, entry_point);
    
    return 0;  /* Never reached */
}

/* Wait system call implementation */
pid_t sys_waitpid(pid_t pid, int* wstatus, int options) {
    struct process* current = get_current_process();
    if (!current) {
        return -ESRCH;
    }
    
    /* Validate status pointer */
    if (wstatus && !is_user_address_valid(wstatus, sizeof(int))) {
        return -EFAULT;
    }
    
    /* Check for specific child or any child */
    struct process* target = NULL;
    
    if (pid > 0) {
        /* Wait for specific child */
        target = process_find_by_pid(pid);
        if (!target || target->parent_pid != current->pid) {
            return -ECHILD;
        }
    } else if (pid == -1) {
        /* Wait for any child - will be handled in the loop */
    } else {
        /* Process groups not implemented yet */
        return -ENOSYS;
    }
    
    /* Check for immediate return conditions */
    if (options & WNOHANG) {
        /* Non-blocking wait */
        spin_lock(&current->lock);
        
        struct process* child;
        list_for_each_entry(child, &current->children, sibling_list) {
            if ((pid == -1 || child->pid == pid) && child->state == PROC_STATE_ZOMBIE) {
                int exit_code = child->exit_code;
                pid_t child_pid = child->pid;
                
                /* Remove from children list */
                list_del(&child->sibling_list);
                spin_unlock(&current->lock);
                
                /* Return status */
                if (wstatus) {
                    *wstatus = exit_code;
                }
                
                /* Cleanup zombie */
                cleanup_zombie_process(child);
                
                return child_pid;
            }
        }
        
        spin_unlock(&current->lock);
        return 0;  /* No children ready */
    }
    
    /* Blocking wait - set up waiter */
    exit_waiter_t waiter;
    memset(&waiter, 0, sizeof(waiter));
    
    waiter.waiter_pid = current->pid;
    waiter.target_pid = pid;
    waiter.wstatus = wstatus;
    waiter.options = options;
    waiter.completed = false;
    
    /* Add to waiters list */
    spin_lock(&g_proc_mgr.waiters_lock);
    list_add(&waiter.list, &g_proc_mgr.exit_waiters);
    spin_unlock(&g_proc_mgr.waiters_lock);
    
    /* Block until child exits */
    current->state = PROC_STATE_BLOCKED;
    scheduler_yield();
    
    /* Check if wait was satisfied */
    if (waiter.completed) {
        if (wstatus) {
            *wstatus = waiter.exit_code;
        }
        return waiter.target_pid;
    }
    
    /* Remove from waiters list if not completed */
    spin_lock(&g_proc_mgr.waiters_lock);
    list_del(&waiter.list);
    spin_unlock(&g_proc_mgr.waiters_lock);
    
    return -EINTR;  /* Interrupted */
}

/* Exit system call implementation */
void sys_exit(int status) {
    struct process* proc = get_current_process();
    if (!proc) {
        return;  /* Should never happen */
    }
    
    printf("Process %d exiting with status %d\n", proc->pid, status);
    
    proc->exit_code = status;
    proc->state = PROC_STATE_ZOMBIE;
    
    /* Close all file descriptors */
    if (proc->fd_table) {
        fd_table_close_all(proc->fd_table);
    }
    
    /* Terminate all threads */
    thread_terminate_all(proc);
    
    /* Notify any waiters */
    notify_exit_waiters(proc, status);
    
    /* Add to zombie list for cleanup */
    spin_lock(&g_proc_mgr.zombie_lock);
    list_add(&proc->zombie_list, &g_proc_mgr.zombie_list);
    spin_unlock(&g_proc_mgr.zombie_lock);
    
    atomic64_inc(&g_proc_mgr.exits_total);
    atomic64_inc(&g_proc_mgr.zombies_created);
    
    /* Remove from scheduler */
    scheduler_remove_process(proc);
    
    /* Never returns */
    scheduler_yield_to_exit();
}

/* Copy process memory with COW support */
static int copy_process_memory(struct process* parent, struct process* child, bool cow) {
    /* Create new address space for child */
    child->aspace = vmm_create_aspace();
    if (!child->aspace) {
        return -ENOMEM;
    }
    
    if (cow) {
        /* Copy-on-write fork */
        return demand_paging_fork_cow(parent->aspace, child->aspace);
    } else {
        /* Full copy (traditional fork) */
        return vmm_copy_aspace(parent->aspace, child->aspace);
    }
}

/* Copy file descriptors */
static int copy_file_descriptors(struct process* parent, struct process* child) {
    if (!parent->fd_table) {
        child->fd_table = fd_table_create();
        return child->fd_table ? 0 : -ENOMEM;
    }
    
    child->fd_table = fd_table_clone(parent->fd_table);
    return child->fd_table ? 0 : -ENOMEM;
}

/* Copy signal handlers */
static int copy_signal_handlers(struct process* parent, struct process* child) {
    if (!parent->signal_table) {
        child->signal_table = signal_table_create();
        return child->signal_table ? 0 : -ENOMEM;
    }
    
    child->signal_table = signal_table_clone(parent->signal_table);
    return child->signal_table ? 0 : -ENOMEM;
}

/* Setup process arguments in new memory space */
static int setup_process_arguments(struct process* proc, char* const* argv, char* const* envp) {
    /* Calculate total size needed */
    size_t argc = 0;
    size_t envc = 0;
    size_t total_size = 0;
    
    /* Count arguments and calculate size */
    if (argv) {
        while (argv[argc] && argc < MAX_ARGV_COUNT) {
            size_t len = strlen(argv[argc]) + 1;
            if (len > MAX_ARG_LENGTH) {
                return -E2BIG;
            }
            total_size += len;
            argc++;
        }
    }
    
    /* Count environment variables */
    if (envp) {
        while (envp[envc] && envc < MAX_ENVP_COUNT) {
            size_t len = strlen(envp[envc]) + 1;
            if (len > MAX_ARG_LENGTH) {
                return -E2BIG;
            }
            total_size += len;
            envc++;
        }
    }
    
    /* Add space for pointer arrays */
    total_size += (argc + 1) * sizeof(char*);  /* argv */
    total_size += (envc + 1) * sizeof(char*);  /* envp */
    total_size += sizeof(int);                 /* argc */
    
    /* Align and add safety margin */
    total_size = ALIGN_UP(total_size, PAGE_SIZE) + PAGE_SIZE;
    
    /* Allocate stack space near top of address space */
    virt_addr_t stack_top = 0x7FFFFF000000UL;  /* x86_64 user space top */
    virt_addr_t stack_base = stack_top - total_size;
    
    /* Map stack pages */
    size_t stack_pages = total_size / PAGE_SIZE;
    for (size_t i = 0; i < stack_pages; i++) {
        paddr_t phys_page = pmm_alloc_page();
        if (!phys_page) {
            return -ENOMEM;
        }
        
        virt_addr_t vaddr = stack_base + (i * PAGE_SIZE);
        vmm_map_page(proc->aspace, vaddr, phys_page, 
                    PTE_PRESENT | PTE_USER | PTE_WRITABLE);
    }
    
    /* TODO: Copy arguments and environment to stack */
    /* This would involve careful setup of the stack layout for user space */
    
    return 0;
}

/* Notify processes waiting for this process to exit */
static void notify_exit_waiters(struct process* proc, int exit_code) {
    spin_lock(&g_proc_mgr.waiters_lock);
    
    exit_waiter_t* waiter;
    exit_waiter_t* next;
    
    list_for_each_entry_safe(waiter, next, &g_proc_mgr.exit_waiters, list) {
        if (waiter->target_pid == proc->pid || waiter->target_pid == -1) {
            waiter->completed = true;
            waiter->exit_code = exit_code;
            waiter->target_pid = proc->pid;
            
            /* Wake up waiting process */
            struct process* waiting_proc = process_find_by_pid(waiter->waiter_pid);
            if (waiting_proc && waiting_proc->state == PROC_STATE_BLOCKED) {
                waiting_proc->state = PROC_STATE_READY;
                scheduler_add_process(waiting_proc);
            }
            
            /* Remove from waiters list */
            list_del(&waiter->list);
        }
    }
    
    spin_unlock(&g_proc_mgr.waiters_lock);
}

/* Cleanup zombie process */
static void cleanup_zombie_process(struct process* proc) {
    if (!proc || proc->state != PROC_STATE_ZOMBIE) {
        return;
    }
    
    printf("Cleaning up zombie process %d\n", proc->pid);
    
    /* Remove from process table */
    spin_lock(&g_proc_mgr.process_table_lock);
    for (int i = 0; i < MAX_PROCESSES; i++) {
        if (g_proc_mgr.process_table[i] == proc) {
            g_proc_mgr.process_table[i] = NULL;
            break;
        }
    }
    spin_unlock(&g_proc_mgr.process_table_lock);
    
    /* Remove from zombie list */
    spin_lock(&g_proc_mgr.zombie_lock);
    list_del(&proc->zombie_list);
    spin_unlock(&g_proc_mgr.zombie_lock);
    
    /* Release PID */
    release_pid(proc->pid);
    
    /* Cleanup resources */
    if (proc->aspace) {
        vmm_destroy_aspace(proc->aspace);
    }
    if (proc->fd_table) {
        fd_table_destroy(proc->fd_table);
    }
    if (proc->signal_table) {
        signal_table_destroy(proc->signal_table);
    }
    
    /* Free process structure */
    vmm_kfree(proc, sizeof(struct process));
    
    atomic64_inc(&g_proc_mgr.zombies_reaped);
}

/* Zombie reaper timer */
static void zombie_reaper_timer(void* data) {
    UNUSED(data);
    
    spin_lock(&g_proc_mgr.zombie_lock);
    
    struct process* proc;
    struct process* next;
    
    list_for_each_entry_safe(proc, next, &g_proc_mgr.zombie_list, zombie_list) {
        /* Check if zombie has been around too long */
        uint64_t now = timer_get_ticks();
        if (now - proc->exit_timestamp > ZOMBIE_TIMEOUT_MS) {
            printf("Force reaping zombie process %d\n", proc->pid);
            cleanup_zombie_process(proc);
        }
    }
    
    spin_unlock(&g_proc_mgr.zombie_lock);
    
    /* Reschedule timer */
    timer_schedule(&g_proc_mgr.zombie_timer, ZOMBIE_TIMEOUT_MS);
}

/* Allocate process ID */
static pid_t allocate_pid(void) {
    spin_lock(&g_proc_mgr.pid_lock);
    
    /* Find free PID */
    int pid = find_first_zero_bit(g_proc_mgr.pid_bitmap, MAX_PROCESSES);
    if (pid >= MAX_PROCESSES) {
        spin_unlock(&g_proc_mgr.pid_lock);
        return -1;
    }
    
    set_bit(pid, g_proc_mgr.pid_bitmap);
    
    /* Ensure PID is never 0 */
    if (pid == 0) {
        pid = 1;
        set_bit(1, g_proc_mgr.pid_bitmap);
    }
    
    spin_unlock(&g_proc_mgr.pid_lock);
    return pid;
}

/* Release process ID */
static void release_pid(pid_t pid) {
    if (pid <= 0 || pid >= MAX_PROCESSES) {
        return;
    }
    
    spin_lock(&g_proc_mgr.pid_lock);
    clear_bit(pid, g_proc_mgr.pid_bitmap);
    spin_unlock(&g_proc_mgr.pid_lock);
}

/* Get process management statistics */
void process_get_stats(struct process_mgmt_stats* stats) {
    if (!stats) return;
    
    memset(stats, 0, sizeof(struct process_mgmt_stats));
    
    stats->forks_total = atomic64_read(&g_proc_mgr.forks_total);
    stats->execs_total = atomic64_read(&g_proc_mgr.execs_total);
    stats->exits_total = atomic64_read(&g_proc_mgr.exits_total);
    stats->zombies_created = atomic64_read(&g_proc_mgr.zombies_created);
    stats->zombies_reaped = atomic64_read(&g_proc_mgr.zombies_reaped);
    
    /* Count active processes */
    spin_lock(&g_proc_mgr.process_table_lock);
    for (int i = 0; i < MAX_PROCESSES; i++) {
        if (g_proc_mgr.process_table[i]) {
            stats->active_processes++;
        }
    }
    spin_unlock(&g_proc_mgr.process_table_lock);
}

/* Debugging */
void process_dump_stats(void) {
    struct process_mgmt_stats stats;
    process_get_stats(&stats);
    
    printf("Process Management Statistics:\n");
    printf("  Active processes: %u\n", stats.active_processes);
    printf("  Total forks: %lu\n", stats.forks_total);
    printf("  Total execs: %lu\n", stats.execs_total);
    printf("  Total exits: %lu\n", stats.exits_total);
    printf("  Zombies created: %lu\n", stats.zombies_created);
    printf("  Zombies reaped: %lu\n", stats.zombies_reaped);
}