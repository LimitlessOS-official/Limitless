/*
 * LimitlessOS SMP Testing Suite
 * Focused testing for the advanced SMP kernel module
 */

#include "kernel.h"
#include "enterprise.h"
#include "testing.h"

/* Global testing state */
static struct testing_framework test_framework;

/* Initialize the testing framework */
void testing_framework_init(void) {
    test_framework.test_count = 0;
    test_framework.passed_count = 0;
    test_framework.failed_count = 0;
    test_framework.total_duration_us = 0;
    test_framework.verbose = true;
    console_printf("=== Enterprise SMP Testing Suite Initialized ===\n");
}

/* Record a test result */
void record_test_result(const char* name, bool passed, uint64_t duration, const char* error_msg) {
    if (test_framework.test_count >= MAX_TESTS) {
        console_printf("WARNING: Maximum test count exceeded!\n");
        return;
    }
    
    struct test_result* result = &test_framework.results[test_framework.test_count++];
    strncpy(result->name, name, MAX_TEST_NAME - 1);
    result->name[MAX_TEST_NAME - 1] = '\0';
    result->passed = passed;
    result->duration_us = duration;
    strncpy(result->error_msg, error_msg, MAX_ERROR_MSG - 1);
    result->error_msg[MAX_ERROR_MSG - 1] = '\0';
    
    test_framework.total_duration_us += duration;
    if (passed) {
        test_framework.passed_count++;
    } else {
        test_framework.failed_count++;
    }
}

/* Test SMP initialization */
void test_smp_init(void) {
    TEST_START("SMP Initialization");
    
    // Test basic SMP structures are accessible
    TEST_ASSERT(1, "SMP system structure available");
    
    // Test CPU count detection
    uint32_t cpu_count = hal_cpu_count();
    TEST_ASSERT(cpu_count > 0, "CPU count detection");
    TEST_ASSERT(cpu_count <= MAX_SMP_CPUS, "CPU count within limits");
    
    console_printf("    Detected %u CPUs\n", cpu_count);
    
    TEST_END("SMP Initialization");
}

/* Test SMP topology detection */
void test_smp_topology(void) {
    TEST_START("SMP Topology Detection");
    
    // Test that at least one CPU is online
    uint32_t cpu_count = hal_cpu_count();
    TEST_ASSERT(cpu_count > 0, "At least one CPU online");
    
    // Test topology detection doesn't crash
    TEST_ASSERT(1, "Topology detection completed");
    
    console_printf("    System topology: %u CPUs\n", cpu_count);
    
    TEST_END("SMP Topology Detection");
}

/* Test basic CPU operations */
void test_cpu_operations(void) {
    TEST_START("CPU Operations");
    
    // Test getting current CPU ID
    uint32_t current_cpu = hal_cpu_id();
    TEST_ASSERT(current_cpu < MAX_SMP_CPUS, "Current CPU ID valid");
    
    console_printf("    Current CPU: %u\n", current_cpu);
    
    TEST_END("CPU Operations");
}

/* Test IPI functionality (basic) */
void test_ipi_basic(void) {
    TEST_START("Basic IPI Functionality");
    
    // Test IPI constants are defined
    TEST_ASSERT(IPI_RESCHEDULE == 0, "IPI constants defined");
    TEST_ASSERT(IPI_MAX_TYPES > IPI_RESCHEDULE, "IPI types enumerated");
    
    console_printf("    IPI system: %d types defined\n", IPI_MAX_TYPES);
    
    TEST_END("Basic IPI Functionality");
}

/* Test load balancing structures */
void test_load_balancing(void) {
    TEST_START("Load Balancing Structures");
    
    // Test that load balancing constants are defined
    TEST_ASSERT(LOAD_BALANCE_INTERVAL_MS > 0, "Load balance interval defined");
    
    console_printf("    Load balance interval: %d ms\n", LOAD_BALANCE_INTERVAL_MS);
    
    TEST_END("Load Balancing Structures");
}

/* Run all SMP tests */
void run_smp_tests(void) {
    console_printf("\n=== Running SMP Enterprise Tests ===\n");
    
    test_smp_init();
    test_smp_topology();
    test_cpu_operations();
    test_ipi_basic();
    test_load_balancing();
    
    console_printf("\n=== SMP Tests Complete ===\n");
}

/* Print test summary */
void print_test_summary(void) {
    console_printf("\n" CONSOLE_CYAN "=== TEST SUMMARY ===" CONSOLE_RESET "\n");
    console_printf("Total Tests: %u\n", test_framework.test_count);
    console_printf(CONSOLE_GREEN "Passed: %u" CONSOLE_RESET "\n", test_framework.passed_count);
    console_printf(CONSOLE_RED "Failed: %u" CONSOLE_RESET "\n", test_framework.failed_count);
    console_printf("Total Duration: %llu us\n", test_framework.total_duration_us);
    
    if (test_framework.failed_count > 0) {
        console_printf(CONSOLE_RED "\nFAILED TESTS:\n" CONSOLE_RESET);
        for (uint32_t i = 0; i < test_framework.test_count; i++) {
            if (!test_framework.results[i].passed) {
                console_printf("  %s: %s\n", test_framework.results[i].name, 
                             test_framework.results[i].error_msg);
            }
        }
    }
    
    double success_rate = (test_framework.test_count > 0) ? 
                         ((double)test_framework.passed_count / test_framework.test_count) * 100.0 : 0.0;
    console_printf("Success Rate: %.1f%%\n", success_rate);
}

/* Get failed test count */
uint32_t get_failed_test_count(void) {
    return test_framework.failed_count;
}

/* Set verbose testing */
void set_verbose_testing(bool verbose) {
    test_framework.verbose = verbose;
}

/* Main testing entry point */
int main(void) {
    testing_framework_init();
    run_smp_tests();
    print_test_summary();
    return (get_failed_test_count() == 0) ? 0 : 1;
}