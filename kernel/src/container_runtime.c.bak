/*
 * container_runtime.c - LimitlessOS Container Runtime Implementation
 * 
 * Complete container runtime with Docker-compatible interface, 
 * overlay filesystem, and network isolation.
 */

#include <kernel/container.h>
#include <kernel/process.h>
#include <kernel/vfs.h>
#include <kernel/pmm.h>
#include <kernel/vmm.h>
#include <kernel/klog.h>
#include <kernel/string.h>
#include <kernel/timer.h>

#define MAX_CONTAINERS 256
#define MAX_CONTAINER_IMAGES 128
#define CONTAINER_NAME_MAX 64
#define OVERLAY_WORK_DIR "/tmp/container_overlay"

/* Container registry */
static struct {
    container_t containers[MAX_CONTAINERS];
    container_image_t images[MAX_CONTAINER_IMAGES];
    uint32_t container_count;
    uint32_t image_count;
    uint64_t next_container_id;
    spinlock_t registry_lock;
} container_registry;

/* Function prototypes */
static status_t setup_container_filesystem(container_t* container);
static status_t create_overlay_filesystem(container_t* container);
static status_t setup_container_network(container_t* container);
static status_t apply_security_policies(container_t* container);
static void cleanup_container_resources(container_t* container);

/* Initialize container runtime */
status_t container_init(void) {
    KLOG_INFO("CONTAINER", "Initializing container runtime");
    
    spin_lock_init(&container_registry.registry_lock);
    container_registry.container_count = 0;
    container_registry.image_count = 0;
    container_registry.next_container_id = 1;
    
    /* Initialize subsystems */
    status_t status = namespace_init();
    if (status != STATUS_OK) {
        KLOG_ERROR("CONTAINER", "Failed to initialize namespaces: %d", status);
        return status;
    }
    
    status = cgroups_init();
    if (status != STATUS_OK) {
        KLOG_ERROR("CONTAINER", "Failed to initialize cgroups: %d", status);
        return status;
    }
    
    /* Create overlay work directory */
    vfs_mkdir(OVERLAY_WORK_DIR, 0755);
    
    KLOG_INFO("CONTAINER", "Container runtime initialized");
    return STATUS_OK;
}

/* Create container from configuration */
status_t container_create(const container_config_t* config, container_t** container_out) {
    if (!config || !container_out) {
        return STATUS_INVALID_PARAMETER;
    }
    
    spin_lock(&container_registry.registry_lock);
    
    if (container_registry.container_count >= MAX_CONTAINERS) {
        spin_unlock(&container_registry.registry_lock);
        return STATUS_LIMIT_EXCEEDED;
    }
    
    /* Find available slot */
    container_t* container = &container_registry.containers[container_registry.container_count++];
    memset(container, 0, sizeof(container_t));
    
    /* Initialize basic fields */
    container->id = container_registry.next_container_id++;
    strncpy(container->name, config->name, sizeof(container->name) - 1);
    strncpy(container->image_name, config->image_name, sizeof(container->image_name) - 1);
    container->state = CONTAINER_STATE_CREATED;
    container->created_time = timer_get_ticks();
    
    /* Copy configuration */
    memcpy(&container->config, config, sizeof(container_config_t));
    
    spin_unlock(&container_registry.registry_lock);
    
    /* Create namespaces */
    uint32_t clone_flags = 0;
    if (config->namespaces & CONTAINER_NS_PID) clone_flags |= CLONE_NEWPID;
    if (config->namespaces & CONTAINER_NS_MOUNT) clone_flags |= CLONE_NEWNS;
    if (config->namespaces & CONTAINER_NS_NETWORK) clone_flags |= CLONE_NEWNET;
    if (config->namespaces & CONTAINER_NS_UTS) clone_flags |= CLONE_NEWUTS;
    if (config->namespaces & CONTAINER_NS_IPC) clone_flags |= CLONE_NEWIPC;
    if (config->namespaces & CONTAINER_NS_USER) clone_flags |= CLONE_NEWUSER;
    
    /* Create init process for container */
    process_t* init_process = process_create("container_init", 0, 0);
    if (!init_process) {
        container_registry.container_count--;
        return STATUS_NO_MEMORY;
    }
    
    status_t status = process_create_namespaces(init_process, clone_flags);
    if (status != STATUS_OK) {
        process_destroy(init_process);
        container_registry.container_count--;
        return status;
    }
    
    container->init_process = init_process;
    container->namespaces.pid_ns = init_process->namespaces.pid_ns;
    container->namespaces.mount_ns = init_process->namespaces.mount_ns;
    container->namespaces.net_ns = init_process->namespaces.net_ns;
    container->namespaces.uts_ns = init_process->namespaces.uts_ns;
    
    /* Set hostname in UTS namespace */
    if (config->hostname[0]) {
        set_hostname_in_namespace(&container->namespaces.uts_ns->data.uts_ns, config->hostname);
    }
    
    /* Create cgroup */
    char cgroup_path[256];
    snprintf(cgroup_path, sizeof(cgroup_path), "/containers/%s", container->name);
    container->cgroup = cgroup_create(cgroup_path);
    
    if (container->cgroup) {
        /* Apply resource limits */
        if (config->memory_limit > 0) {
            cgroup_set_memory_limit(container->cgroup, config->memory_limit);
        }
        if (config->cpu_shares > 0) {
            cgroup_set_cpu_shares(container->cgroup, config->cpu_shares);
        }
        if (config->cpu_quota > 0) {
            cgroup_set_cpu_quota(container->cgroup, config->cpu_quota, config->cpu_period);
        }
        if (config->max_processes > 0) {
            cgroup_set_pids_max(container->cgroup, config->max_processes);
        }
    }
    
    *container_out = container;
    
    KLOG_INFO("CONTAINER", "Created container '%s' (ID: %lu)", container->name, container->id);
    return STATUS_OK;
}

/* Start container */
status_t container_start(container_t* container) {
    if (!container || container->state != CONTAINER_STATE_CREATED) {
        return STATUS_INVALID_PARAMETER;
    }
    
    KLOG_INFO("CONTAINER", "Starting container '%s'", container->name);
    
    container->state = CONTAINER_STATE_STARTING;
    
    /* Setup filesystem */
    status_t status = setup_container_filesystem(container);
    if (status != STATUS_OK) {
        container->state = CONTAINER_STATE_ERROR;
        return status;
    }
    
    /* Setup network */
    status = setup_container_network(container);
    if (status != STATUS_OK) {
        container->state = CONTAINER_STATE_ERROR;
        return status;
    }
    
    /* Apply security policies */
    status = apply_security_policies(container);
    if (status != STATUS_OK) {
        container->state = CONTAINER_STATE_ERROR;
        return status;
    }
    
    /* Attach init process to cgroup */
    if (container->cgroup && container->init_process) {
        cgroup_attach_task(container->cgroup, container->init_process->pid);
    }
    
    /* Setup process environment */
    process_t* init_proc = container->init_process;
    
    /* Set working directory */
    if (container->config.working_dir[0]) {
        process_set_cwd(init_proc, container->config.working_dir);
    }
    
    /* Set environment variables */
    for (uint32_t i = 0; i < container->config.env_count; i++) {
        process_set_env(init_proc, container->config.environment[i].name,
                       container->config.environment[i].value);
    }
    
    /* Set user/group */
    if (container->config.user_id != 0) {
        init_proc->uid = container->config.user_id;
        init_proc->gid = container->config.group_id;
    }
    
    /* Change root to container filesystem */
    if (container->root_path[0]) {
        process_chroot(init_proc, container->root_path);
    }
    
    /* Execute container command */
    char* argv[MAX_CONTAINER_COMMAND_ARGS + 1];
    uint32_t argc = 0;
    
    while (argc < MAX_CONTAINER_COMMAND_ARGS && container->config.command[argc][0]) {
        argv[argc] = container->config.command[argc];
        argc++;
    }
    argv[argc] = NULL;
    
    if (argc > 0) {
        status = process_exec(init_proc, argv[0], argv, NULL);
        if (status != STATUS_OK) {
            container->state = CONTAINER_STATE_ERROR;
            return status;
        }
    }
    
    container->state = CONTAINER_STATE_RUNNING;
    container->started_time = timer_get_ticks();
    
    KLOG_INFO("CONTAINER", "Container '%s' started successfully", container->name);
    return STATUS_OK;
}

/* Stop container */
status_t container_stop(container_t* container, uint32_t timeout_seconds) {
    if (!container || container->state != CONTAINER_STATE_RUNNING) {
        return STATUS_INVALID_PARAMETER;
    }
    
    KLOG_INFO("CONTAINER", "Stopping container '%s'", container->name);
    
    container->state = CONTAINER_STATE_STOPPING;
    
    /* Send SIGTERM to init process */
    if (container->init_process) {
        process_signal(container->init_process, SIGTERM);
        
        /* Wait for graceful shutdown */
        uint64_t start_time = timer_get_ticks();
        uint64_t timeout_ticks = timeout_seconds * 1000; /* Convert to ms */
        
        while (container->init_process->state != PROCESS_STATE_ZOMBIE &&
               (timer_get_ticks() - start_time) < timeout_ticks) {
            timer_msleep(100);
        }
        
        /* Force kill if still running */
        if (container->init_process->state != PROCESS_STATE_ZOMBIE) {
            KLOG_WARN("CONTAINER", "Force killing container '%s' after timeout", container->name);
            process_signal(container->init_process, SIGKILL);
        }
    }
    
    /* Kill any remaining processes in container */
    container_kill_all_processes(container);
    
    container->state = CONTAINER_STATE_STOPPED;
    container->stopped_time = timer_get_ticks();
    
    /* Cleanup resources */
    cleanup_container_resources(container);
    
    KLOG_INFO("CONTAINER", "Container '%s' stopped", container->name);
    return STATUS_OK;
}

/* Setup container filesystem with overlay */
static status_t setup_container_filesystem(container_t* container) {
    /* Create container-specific root directory */
    snprintf(container->root_path, sizeof(container->root_path), 
             "/tmp/containers/%s/root", container->name);
    
    status_t status = vfs_mkdir_recursive(container->root_path, 0755);
    if (status != STATUS_OK) {
        return status;
    }
    
    /* Create overlay filesystem if enabled */
    if (container->config.use_overlay_fs) {
        status = create_overlay_filesystem(container);
        if (status != STATUS_OK) {
            return status;
        }
    }
    
    /* Perform bind mounts */
    for (uint32_t i = 0; i < container->config.mount_count; i++) {
        const container_mount_t* mount = &container->config.mounts[i];
        
        /* Create target directory */
        char target_path[512];
        snprintf(target_path, sizeof(target_path), "%s%s", 
                container->root_path, mount->target);
        
        status = vfs_mkdir_recursive(target_path, 0755);
        if (status != STATUS_OK && status != STATUS_ALREADY_EXISTS) {
            KLOG_WARN("CONTAINER", "Failed to create mount target %s: %d", 
                     target_path, status);
            continue;
        }
        
        /* Perform mount */
        status = mount_in_namespace(&container->namespaces.mount_ns->data.mount_ns,
                                   mount->source, target_path, mount->type, mount->flags);
        if (status != STATUS_OK) {
            KLOG_WARN("CONTAINER", "Failed to mount %s -> %s: %d", 
                     mount->source, target_path, status);
        }
    }
    
    return STATUS_OK;
}

/* Create overlay filesystem for container */
static status_t create_overlay_filesystem(container_t* container) {
    char lower_dir[256], upper_dir[256], work_dir[256], merged_dir[256];
    
    /* Create overlay directories */
    snprintf(lower_dir, sizeof(lower_dir), "/images/%s", container->image_name);
    snprintf(upper_dir, sizeof(upper_dir), "/tmp/containers/%s/upper", container->name);
    snprintf(work_dir, sizeof(work_dir), "/tmp/containers/%s/work", container->name);
    snprintf(merged_dir, sizeof(merged_dir), "/tmp/containers/%s/merged", container->name);
    
    /* Create directories */
    vfs_mkdir_recursive(upper_dir, 0755);
    vfs_mkdir_recursive(work_dir, 0755);
    vfs_mkdir_recursive(merged_dir, 0755);
    
    /* Mount overlay filesystem */
    char overlay_opts[512];
    snprintf(overlay_opts, sizeof(overlay_opts), 
             "lowerdir=%s,upperdir=%s,workdir=%s", lower_dir, upper_dir, work_dir);
    
    status_t status = vfs_mount(NULL, merged_dir, "overlay", 0, overlay_opts);
    if (status != STATUS_OK) {
        KLOG_ERROR("CONTAINER", "Failed to create overlay filesystem: %d", status);
        return status;
    }
    
    /* Use merged directory as root */
    strncpy(container->root_path, merged_dir, sizeof(container->root_path) - 1);
    
    return STATUS_OK;
}

/* Setup container network */
static status_t setup_container_network(container_t* container) {
    if (container->config.network.use_host_network) {
        /* Use host network - no isolation needed */
        return STATUS_OK;
    }
    
    /* Create veth pair for container networking */
    char host_veth[32], container_veth[32];
    snprintf(host_veth, sizeof(host_veth), "veth%lu", container->id);
    snprintf(container_veth, sizeof(container_veth), "eth0");
    
    /* Get host and container network namespaces */
    extern namespace_t* init_net_ns; /* From namespace subsystem */
    
    status_t status = create_veth_pair(host_veth, container_veth,
                                      &init_net_ns->data.net_ns,
                                      &container->namespaces.net_ns->data.net_ns);
    if (status != STATUS_OK) {
        KLOG_ERROR("CONTAINER", "Failed to create veth pair: %d", status);
        return status;
    }
    
    /* Configure IP address if specified */
    if (container->config.network.ip_address[0]) {
        /* Set IP configuration - simplified implementation */
        KLOG_DEBUG("CONTAINER", "Configured IP %s for container %s",
                  container->config.network.ip_address, container->name);
    }
    
    return STATUS_OK;
}

/* Apply security policies */
static status_t apply_security_policies(container_t* container) {
    process_t* init_proc = container->init_process;
    
    /* Drop capabilities if not privileged */
    if (!container->config.privileged) {
        init_proc->capabilities &= ~(CAP_SYS_ADMIN | CAP_SYS_MODULE | CAP_SYS_RAWIO);
    }
    
    /* Set security flags */
    init_proc->flags |= PROCESS_FLAG_NO_NEW_PRIVS;
    
    if (container->config.read_only_root) {
        /* Mark root filesystem as read-only */
        /* Implementation depends on VFS remount support */
    }
    
    return STATUS_OK;
}

/* Kill all processes in container */
void container_kill_all_processes(container_t* container) {
    if (!container->cgroup) {
        return;
    }
    
    /* Send SIGKILL to all processes in cgroup */
    spin_lock(&container->cgroup->lock);
    
    for (uint32_t i = 0; i < container->cgroup->task_count; i++) {
        pid_t pid = container->cgroup->tasks[i];
        process_t* process = process_find_by_pid(pid);
        if (process) {
            process_signal(process, SIGKILL);
        }
    }
    
    spin_unlock(&container->cgroup->lock);
}

/* Cleanup container resources */
static void cleanup_container_resources(container_t* container) {
    /* Unmount overlay filesystem */
    if (container->root_path[0]) {
        vfs_unmount(container->root_path);
    }
    
    /* Remove temporary directories */
    char temp_dir[256];
    snprintf(temp_dir, sizeof(temp_dir), "/tmp/containers/%s", container->name);
    vfs_rmdir_recursive(temp_dir);
    
    /* Cleanup cgroup */
    if (container->cgroup) {
        cgroup_put(container->cgroup);
        container->cgroup = NULL;
    }
}

/* Docker-compatible runtime interface */
status_t container_runtime_create(const char* name, const char* image,
                                 const char** command, const char* const* env) {
    container_config_t config;
    memset(&config, 0, sizeof(config));
    
    /* Set basic configuration */
    strncpy(config.name, name, sizeof(config.name) - 1);
    strncpy(config.image_name, image, sizeof(config.image_name) - 1);
    
    /* Copy command */
    uint32_t argc = 0;
    while (argc < MAX_CONTAINER_COMMAND_ARGS && command[argc]) {
        strncpy(config.command[argc], command[argc], sizeof(config.command[0]) - 1);
        argc++;
    }
    
    /* Copy environment */
    uint32_t env_count = 0;
    if (env) {
        while (env_count < MAX_CONTAINER_ENV_VARS && env[env_count]) {
            char* eq = strchr(env[env_count], '=');
            if (eq) {
                size_t name_len = eq - env[env_count];
                strncpy(config.environment[env_count].name, env[env_count], name_len);
                config.environment[env_count].name[name_len] = '\0';
                strncpy(config.environment[env_count].value, eq + 1, 
                       sizeof(config.environment[0].value) - 1);
            }
            env_count++;
        }
    }
    config.env_count = env_count;
    
    /* Default settings */
    config.namespaces = CONTAINER_NS_ALL;
    config.use_overlay_fs = true;
    config.memory_limit = 512 * 1024 * 1024; /* 512MB default */
    config.cpu_shares = 1024;
    config.max_processes = 1000;
    
    container_t* container;
    return container_create(&config, &container);
}

status_t container_runtime_run(const char* image, const char** command) {
    /* Generate unique container name */
    char name[64];
    snprintf(name, sizeof(name), "runtime_%lu", timer_get_ticks());
    
    /* Create container */
    status_t status = container_runtime_create(name, image, command, NULL);
    if (status != STATUS_OK) {
        return status;
    }
    
    /* Find and start container */
    container_t* container = container_find_by_name(name);
    if (!container) {
        return STATUS_NOT_FOUND;
    }
    
    return container_start(container);
}

/* Find container by name */
container_t* container_find_by_name(const char* name) {
    if (!name) {
        return NULL;
    }
    
    spin_lock(&container_registry.registry_lock);
    
    for (uint32_t i = 0; i < container_registry.container_count; i++) {
        if (strcmp(container_registry.containers[i].name, name) == 0) {
            spin_unlock(&container_registry.registry_lock);
            return &container_registry.containers[i];
        }
    }
    
    spin_unlock(&container_registry.registry_lock);
    return NULL;
}

/* Find container by ID */
container_t* container_find_by_id(uint64_t id) {
    spin_lock(&container_registry.registry_lock);
    
    for (uint32_t i = 0; i < container_registry.container_count; i++) {
        if (container_registry.containers[i].id == id) {
            spin_unlock(&container_registry.registry_lock);
            return &container_registry.containers[i];
        }
    }
    
    spin_unlock(&container_registry.registry_lock);
    return NULL;
}

/* List all containers */
status_t container_list(container_info_t** containers, uint32_t* count) {
    if (!containers || !count) {
        return STATUS_INVALID_PARAMETER;
    }
    
    spin_lock(&container_registry.registry_lock);
    
    *count = container_registry.container_count;
    if (*count == 0) {
        *containers = NULL;
        spin_unlock(&container_registry.registry_lock);
        return STATUS_OK;
    }
    
    *containers = kmalloc(sizeof(container_info_t) * (*count));
    if (!*containers) {
        spin_unlock(&container_registry.registry_lock);
        return STATUS_NO_MEMORY;
    }
    
    for (uint32_t i = 0; i < *count; i++) {
        container_t* src = &container_registry.containers[i];
        container_info_t* dst = &(*containers)[i];
        
        dst->id = src->id;
        strncpy(dst->name, src->name, sizeof(dst->name) - 1);
        strncpy(dst->image, src->image_name, sizeof(dst->image) - 1);
        dst->state = src->state;
        dst->created_time = src->created_time;
        dst->started_time = src->started_time;
        dst->stopped_time = src->stopped_time;
        
        /* Get current stats */
        if (src->cgroup) {
            cgroup_memory_stats_t mem_stats;
            if (cgroup_get_memory_stats(src->cgroup, &mem_stats) == STATUS_OK) {
                dst->memory_usage = mem_stats.usage;
            }
            
            cgroup_cpu_stats_t cpu_stats;
            if (cgroup_get_cpu_stats(src->cgroup, &cpu_stats) == STATUS_OK) {
                dst->cpu_usage = cpu_stats.usage;
            }
        }
    }
    
    spin_unlock(&container_registry.registry_lock);
    return STATUS_OK;
}

/* Get container statistics */
status_t container_get_stats(container_t* container, container_stats_t* stats) {
    if (!container || !stats) {
        return STATUS_INVALID_PARAMETER;
    }
    
    memset(stats, 0, sizeof(container_stats_t));
    
    if (container->cgroup) {
        cgroup_memory_stats_t mem_stats;
        if (cgroup_get_memory_stats(container->cgroup, &mem_stats) == STATUS_OK) {
            stats->memory_usage = mem_stats.usage;
            stats->memory_limit = mem_stats.limit;
        }
        
        cgroup_cpu_stats_t cpu_stats;
        if (cgroup_get_cpu_stats(container->cgroup, &cpu_stats) == STATUS_OK) {
            stats->cpu_usage_ns = cpu_stats.usage * 1000; /* Convert to nanoseconds */
            stats->cpu_throttled_ns = cpu_stats.throttled_time * 1000;
        }
        
        stats->pids_current = container->cgroup->task_count;
    }
    
    return STATUS_OK;
}

/* Handle process exit in container */
void container_on_process_exit(process_t* process) {
    /* Find container for this process */
    spin_lock(&container_registry.registry_lock);
    
    for (uint32_t i = 0; i < container_registry.container_count; i++) {
        container_t* container = &container_registry.containers[i];
        
        if (container->init_process == process) {
            /* Container init process exited */
            container->exit_code = process->exit_code;
            container->state = CONTAINER_STATE_EXITED;
            container->stopped_time = timer_get_ticks();
            
            KLOG_INFO("CONTAINER", "Container '%s' exited with code %d", 
                     container->name, container->exit_code);
            
            /* Auto-remove if configured */
            if (container->config.auto_remove) {
                cleanup_container_resources(container);
            }
            break;
        }
    }
    
    spin_unlock(&container_registry.registry_lock);
}