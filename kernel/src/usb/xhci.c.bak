/**
 * XHCI (USB 3.0) Host Controller Driver for LimitlessOS
 * Supports USB 3.0, 2.0, and 1.1 devices
 */

#include "usb.h"
#include "kernel.h"
#include "pci.h"
#include "vmm.h"
#include "string.h"
#include "log.h"
#include "timer.h"

/* XHCI register offsets */
#define XHCI_CAP_CAPLENGTH   0x00
#define XHCI_CAP_HCIVERSION  0x02
#define XHCI_CAP_HCSPARAMS1  0x04
#define XHCI_CAP_HCSPARAMS2  0x08
#define XHCI_CAP_HCSPARAMS3  0x0C
#define XHCI_CAP_HCCPARAMS1  0x10
#define XHCI_CAP_DBOFF       0x14
#define XHCI_CAP_RTSOFF      0x18

/* Operational registers (offset by CAPLENGTH) */
#define XHCI_OP_USBCMD       0x00
#define XHCI_OP_USBSTS       0x04
#define XHCI_OP_PAGESIZE     0x08
#define XHCI_OP_DNCTRL       0x14
#define XHCI_OP_CRCR         0x18
#define XHCI_OP_DCBAAP       0x30
#define XHCI_OP_CONFIG       0x38

/* Port register sets (offset from operational base) */
#define XHCI_PORT_PORTSC     0x00
#define XHCI_PORT_PORTPMSC   0x04
#define XHCI_PORT_PORTLI     0x08
#define XHCI_PORT_PORTHLPMC  0x0C

#define MAX_XHCI_CONTROLLERS 8
#define MAX_XHCI_PORTS      16
#define XHCI_RING_SIZE      256

/* Command and transfer ring structures */
typedef struct {
    uint64_t parameter;
    uint32_t status;
    uint32_t control;
} __attribute__((packed)) xhci_trb_t;

/* Event ring segment table entry */
typedef struct {
    uint64_t ring_segment_base_address;
    uint16_t ring_segment_size;
    uint16_t reserved1;
    uint32_t reserved2;
} __attribute__((packed)) xhci_erst_entry_t;

/* Device context */
typedef struct {
    uint32_t slot_context[8];
    uint32_t endpoint_contexts[31][8];  /* 31 endpoints max */
} __attribute__((packed)) xhci_device_context_t;

/* XHCI controller state */
typedef struct {
    bool in_use;
    pci_device_t pci_dev;
    void* cap_regs;         /* Capability registers */
    void* op_regs;          /* Operational registers */
    void* runtime_regs;     /* Runtime registers */
    void* doorbell_array;   /* Doorbell array */
    
    /* Controller capabilities */
    uint16_t hci_version;
    uint32_t max_slots;
    uint32_t max_ports;
    uint32_t max_intrs;
    
    /* Command and event rings */
    xhci_trb_t* command_ring;
    xhci_trb_t* event_ring;
    xhci_erst_entry_t* event_ring_segment_table;
    
    /* Device context base address array */
    uint64_t* dcbaa;
    
    /* Ring management */
    uint32_t command_ring_enqueue;
    uint32_t command_ring_dequeue;
    uint32_t event_ring_dequeue;
    bool command_ring_cycle;
    bool event_ring_cycle;
    
    /* Port status */
    uint32_t port_count;
    bool port_connected[MAX_XHCI_PORTS];
    uint32_t port_speed[MAX_XHCI_PORTS];
} xhci_controller_t;

static xhci_controller_t g_xhci_controllers[MAX_XHCI_CONTROLLERS];
static uint32_t g_xhci_controller_count = 0;

/* Register access helpers */
static inline uint32_t xhci_read32(void* base, uint32_t offset) {
    return *(volatile uint32_t*)((uint8_t*)base + offset);
}

static inline void xhci_write32(void* base, uint32_t offset, uint32_t value) {
    *(volatile uint32_t*)((uint8_t*)base + offset) = value;
}

static inline uint64_t xhci_read64(void* base, uint32_t offset) {
    return *(volatile uint64_t*)((uint8_t*)base + offset);
}

static inline void xhci_write64(void* base, uint32_t offset, uint64_t value) {
    *(volatile uint64_t*)((uint8_t*)base + offset) = value;
}

/* Reset XHCI controller */
static status_t xhci_reset_controller(xhci_controller_t* ctrl) {
    if (!ctrl) return STATUS_ERROR;
    
    /* Stop the controller */
    uint32_t usbcmd = xhci_read32(ctrl->op_regs, XHCI_OP_USBCMD);
    usbcmd &= ~0x01;  /* Clear Run/Stop bit */
    xhci_write32(ctrl->op_regs, XHCI_OP_USBCMD, usbcmd);
    
    /* Wait for halt */
    uint64_t timeout = timer_get_ticks() + timer_get_freq_hz();
    while (timer_get_ticks() < timeout) {
        uint32_t usbsts = xhci_read32(ctrl->op_regs, XHCI_OP_USBSTS);
        if (usbsts & 0x01) {  /* HCHalted bit */
            break;
        }
    }
    
    /* Reset the controller */
    usbcmd = xhci_read32(ctrl->op_regs, XHCI_OP_USBCMD);
    usbcmd |= 0x02;  /* Host Controller Reset */
    xhci_write32(ctrl->op_regs, XHCI_OP_USBCMD, usbcmd);
    
    /* Wait for reset completion */
    timeout = timer_get_ticks() + timer_get_freq_hz();
    while (timer_get_ticks() < timeout) {
        usbcmd = xhci_read32(ctrl->op_regs, XHCI_OP_USBCMD);
        if ((usbcmd & 0x02) == 0) {  /* Reset bit cleared */
            break;
        }
    }
    
    if (usbcmd & 0x02) {
        KLOG_ERROR(\"xhci\", \"Controller reset timeout\");
        return STATUS_ERROR;
    }
    
    return STATUS_OK;
}

/* Initialize command and event rings */
static status_t xhci_init_rings(xhci_controller_t* ctrl) {
    if (!ctrl) return STATUS_ERROR;
    
    /* Allocate command ring */
    ctrl->command_ring = (xhci_trb_t*)vmm_kmalloc(XHCI_RING_SIZE * sizeof(xhci_trb_t), PAGE_SIZE);
    if (!ctrl->command_ring) return STATUS_NOMEM;
    k_memset(ctrl->command_ring, 0, XHCI_RING_SIZE * sizeof(xhci_trb_t));
    
    /* Allocate event ring */
    ctrl->event_ring = (xhci_trb_t*)vmm_kmalloc(XHCI_RING_SIZE * sizeof(xhci_trb_t), PAGE_SIZE);
    if (!ctrl->event_ring) {
        vmm_kfree(ctrl->command_ring, XHCI_RING_SIZE * sizeof(xhci_trb_t));
        return STATUS_NOMEM;
    }
    k_memset(ctrl->event_ring, 0, XHCI_RING_SIZE * sizeof(xhci_trb_t));
    
    /* Allocate event ring segment table */
    ctrl->event_ring_segment_table = (xhci_erst_entry_t*)vmm_kmalloc(sizeof(xhci_erst_entry_t), PAGE_SIZE);
    if (!ctrl->event_ring_segment_table) {
        vmm_kfree(ctrl->command_ring, XHCI_RING_SIZE * sizeof(xhci_trb_t));
        vmm_kfree(ctrl->event_ring, XHCI_RING_SIZE * sizeof(xhci_trb_t));
        return STATUS_NOMEM;
    }
    
    /* Initialize event ring segment table */
    ctrl->event_ring_segment_table->ring_segment_base_address = (uint64_t)(uintptr_t)ctrl->event_ring;
    ctrl->event_ring_segment_table->ring_segment_size = XHCI_RING_SIZE;
    ctrl->event_ring_segment_table->reserved1 = 0;
    ctrl->event_ring_segment_table->reserved2 = 0;
    
    /* Initialize ring pointers */
    ctrl->command_ring_enqueue = 0;
    ctrl->command_ring_dequeue = 0;
    ctrl->event_ring_dequeue = 0;
    ctrl->command_ring_cycle = true;
    ctrl->event_ring_cycle = true;
    
    /* Set command ring control register */\n    uint64_t crcr = (uint64_t)(uintptr_t)ctrl->command_ring;\n    crcr |= 0x01;  /* Ring Cycle State */\n    xhci_write64(ctrl->op_regs, XHCI_OP_CRCR, crcr);\n    \n    return STATUS_OK;\n}\n\n/* Initialize device context base address array */\nstatic status_t xhci_init_dcbaa(xhci_controller_t* ctrl) {\n    if (!ctrl) return STATUS_ERROR;\n    \n    /* Allocate DCBAA (Device Context Base Address Array) */\n    size_t dcbaa_size = (ctrl->max_slots + 1) * sizeof(uint64_t);\n    ctrl->dcbaa = (uint64_t*)vmm_kmalloc(dcbaa_size, PAGE_SIZE);\n    if (!ctrl->dcbaa) return STATUS_NOMEM;\n    \n    k_memset(ctrl->dcbaa, 0, dcbaa_size);\n    \n    /* Set DCBAAP register */\n    xhci_write64(ctrl->op_regs, XHCI_OP_DCBAAP, (uint64_t)(uintptr_t)ctrl->dcbaa);\n    \n    return STATUS_OK;\n}\n\n/* Scan ports for connected devices */\nstatic void xhci_scan_ports(xhci_controller_t* ctrl) {\n    if (!ctrl) return;\n    \n    for (uint32_t i = 0; i < ctrl->port_count && i < MAX_XHCI_PORTS; i++) {\n        uint32_t port_offset = 0x400 + (i * 0x10);  /* Port register set */\n        uint32_t portsc = xhci_read32(ctrl->op_regs, port_offset + XHCI_PORT_PORTSC);\n        \n        bool connected = (portsc & 0x01) != 0;  /* Current Connect Status */\n        uint32_t speed = (portsc >> 10) & 0x0F; /* Port Speed */\n        \n        if (connected != ctrl->port_connected[i]) {\n            ctrl->port_connected[i] = connected;\n            ctrl->port_speed[i] = speed;\n            \n            if (connected) {\n                const char* speed_str = \"Unknown\";\n                switch (speed) {\n                    case 1: speed_str = \"Full Speed (12 Mbps)\"; break;\n                    case 2: speed_str = \"Low Speed (1.5 Mbps)\"; break;\n                    case 3: speed_str = \"High Speed (480 Mbps)\"; break;\n                    case 4: speed_str = \"Super Speed (5 Gbps)\"; break;\n                }\n                \n                KLOG_INFO(\"xhci\", \"Device connected to port %u: %s\", i + 1, speed_str);\n                \n                /* Enumerate device */
                xhci_enumerate_device(i, i);\n            } else {\n                KLOG_INFO(\"xhci\", \"Device disconnected from port %u\", i + 1);\n            }\n        }\n    }\n}\n\n/* Initialize XHCI controller */\nstatic status_t xhci_init_controller(xhci_controller_t* ctrl) {\n    if (!ctrl) return STATUS_ERROR;\n    \n    /* Read capability registers */\n    uint8_t cap_length = *(uint8_t*)ctrl->cap_regs;\n    ctrl->hci_version = xhci_read32(ctrl->cap_regs, XHCI_CAP_HCIVERSION) & 0xFFFF;\n    \n    uint32_t hcsparams1 = xhci_read32(ctrl->cap_regs, XHCI_CAP_HCSPARAMS1);\n    ctrl->max_slots = hcsparams1 & 0xFF;\n    ctrl->max_intrs = (hcsparams1 >> 8) & 0x7FF;\n    ctrl->max_ports = (hcsparams1 >> 24) & 0xFF;\n    \n    uint32_t dboff = xhci_read32(ctrl->cap_regs, XHCI_CAP_DBOFF);\n    uint32_t rtsoff = xhci_read32(ctrl->cap_regs, XHCI_CAP_RTSOFF);\n    \n    /* Calculate register base addresses */\n    ctrl->op_regs = (uint8_t*)ctrl->cap_regs + cap_length;\n    ctrl->runtime_regs = (uint8_t*)ctrl->cap_regs + (rtsoff & ~0x1F);\n    ctrl->doorbell_array = (uint8_t*)ctrl->cap_regs + (dboff & ~0x03);\n    \n    KLOG_INFO(\"xhci\", \"Version %u.%u, %u slots, %u ports, %u interrupts\",\n              ctrl->hci_version >> 8, ctrl->hci_version & 0xFF,\n              ctrl->max_slots, ctrl->max_ports, ctrl->max_intrs);\n    \n    /* Reset controller */\n    status_t result = xhci_reset_controller(ctrl);\n    if (result != STATUS_OK) return result;\n    \n    /* Initialize rings */\n    result = xhci_init_rings(ctrl);\n    if (result != STATUS_OK) return result;\n    \n    /* Initialize DCBAA */\n    result = xhci_init_dcbaa(ctrl);\n    if (result != STATUS_OK) return result;\n    \n    /* Configure controller */\n    uint32_t config = ctrl->max_slots;  /* Enable all device slots */\n    xhci_write32(ctrl->op_regs, XHCI_OP_CONFIG, config);\n    \n    /* Start the controller */\n    uint32_t usbcmd = xhci_read32(ctrl->op_regs, XHCI_OP_USBCMD);\n    usbcmd |= 0x01;  /* Run/Stop bit */\n    usbcmd |= 0x04;  /* Interrupter Enable */\n    xhci_write32(ctrl->op_regs, XHCI_OP_USBCMD, usbcmd);\n    \n    /* Wait for controller to start */\n    uint64_t timeout = timer_get_ticks() + timer_get_freq_hz();\n    while (timer_get_ticks() < timeout) {\n        uint32_t usbsts = xhci_read32(ctrl->op_regs, XHCI_OP_USBSTS);\n        if ((usbsts & 0x01) == 0) {  /* HCHalted bit clear */\n            break;\n        }\n    }\n    \n    uint32_t usbsts = xhci_read32(ctrl->op_regs, XHCI_OP_USBSTS);\n    if (usbsts & 0x01) {\n        KLOG_ERROR(\"xhci\", \"Controller failed to start\");\n        return STATUS_ERROR;\n    }\n    \n    ctrl->port_count = ctrl->max_ports;\n    \n    /* Scan for connected devices */\n    xhci_scan_ports(ctrl);\n    \n    KLOG_INFO(\"xhci\", \"Controller initialized successfully\");\n    return STATUS_OK;\n}\n\n/* PCI enumeration callback */\nstatic void xhci_on_pci(const pci_device_t* dev, void* user) {\n    (void)user;\n    \n    /* Check for XHCI controller (class 0x0C, subclass 0x03, prog-if 0x30) */\n    if (dev->class_code == 0x0C && dev->subclass == 0x03 && dev->prog_if == 0x30) {\n        if (g_xhci_controller_count >= MAX_XHCI_CONTROLLERS) {\n            KLOG_WARN(\"xhci\", \"Too many XHCI controllers, skipping %02x:%02x.%x\",\n                      dev->bus, dev->slot, dev->func);\n            return;\n        }\n        \n        KLOG_INFO(\"xhci\", \"Found XHCI controller: %02x:%02x.%x vid=%04x did=%04x\",\n                  dev->bus, dev->slot, dev->func, dev->vendor_id, dev->device_id);\n        \n        xhci_controller_t* ctrl = &g_xhci_controllers[g_xhci_controller_count];\n        ctrl->pci_dev = *dev;\n        \n        /* Map BAR0 (XHCI registers) */\n        if (dev->bar[0] == 0) {\n            KLOG_ERROR(\"xhci\", \"BAR0 not configured\");\n            return;\n        }\n        \n        uint64_t bar0_addr = dev->bar[0] & ~0x0F;  /* Clear flags */\n        \n        /* TODO: Proper MMIO mapping */\n        ctrl->cap_regs = (void*)bar0_addr;\n        \n        /* Initialize controller */\n        status_t result = xhci_init_controller(ctrl);\n        if (result == STATUS_OK) {\n            ctrl->in_use = true;\n            g_xhci_controller_count++;\n            KLOG_INFO(\"xhci\", \"Successfully initialized XHCI controller %u\", g_xhci_controller_count - 1);\n        } else {\n            KLOG_ERROR(\"xhci\", \"Failed to initialize XHCI controller\");\n        }\n    }\n}\n\n/* Probe for XHCI controllers */\nvoid xhci_probe(void) {\n    KLOG_INFO(\"xhci\", \"Scanning for XHCI (USB 3.0) controllers...\");\n    g_xhci_controller_count = 0;\n    k_memset(g_xhci_controllers, 0, sizeof(g_xhci_controllers));\n    \n    pci_enumerate(xhci_on_pci, NULL);\n    \n    KLOG_INFO(\"xhci\", \"Found %u XHCI controller(s)\", g_xhci_controller_count);\n}\n\n/* USB device enumeration */\nstatus_t xhci_enumerate_device(uint32_t controller_id, uint32_t port_id) {\n    if (controller_id >= g_xhci_controller_count) {\n        return STATUS_ERROR;\n    }\n    \n    xhci_controller_t* ctrl = &g_xhci_controllers[controller_id];\n    if (!ctrl->in_use || port_id >= ctrl->port_count) {\n        return STATUS_ERROR;\n    }\n    \n    /* TODO: Implement device enumeration process */\n    /* This would involve:\n     * 1. Enable slot command\n     * 2. Set address command  \n     * 3. Get device descriptor\n     * 4. Set configuration\n     * 5. Initialize endpoints\n     */\n    \n    KLOG_INFO(\"xhci\", \"Enumerating device on controller %u port %u\", controller_id, port_id);\n    return STATUS_OK;\n}\n\n/* Process XHCI events */\nvoid xhci_process_events(void) {\n    for (uint32_t i = 0; i < g_xhci_controller_count; i++) {\n        xhci_controller_t* ctrl = &g_xhci_controllers[i];\n        if (!ctrl->in_use) continue;\n        \n        /* Scan ports for changes */\n        xhci_scan_ports(ctrl);\n        \n        /* TODO: Process event ring for command completions and transfer events */\n    }\n}"