#include "enterprise_metrics.h"
#include "log.h"
#include "kernel.h"
#include "timer.h"
#include "vfs.h"

/* Global metrics state */
static metric_category_t g_metric_categories[METRICS_MAX_CATEGORIES];
static uint32_t g_category_count = 0;
static system_metrics_t g_system_metrics;
static metrics_config_t g_metrics_config;
static performance_alert_t g_performance_alerts[64];
static uint32_t g_alert_count = 0;
static spinlock_t g_metrics_lock;
static bool g_real_time_collection = false;
static void (*g_update_callback)(const char*, const char*, const metric_value_t*) = NULL;

/* Statistics */
static uint64_t g_total_updates = 0;
static uint64_t g_update_errors = 0;
static uint64_t g_memory_used = 0;

/* Helper functions */
static metric_category_t* find_category(const char* name) {
    for (uint32_t i = 0; i < g_category_count; i++) {
        if (k_strcmp(g_metric_categories[i].name, name) == 0) {
            return &g_metric_categories[i];
        }
    }
    return NULL;
}

static metric_entry_t* find_metric(metric_category_t* category, const char* name) {
    if (!category) return NULL;
    
    for (uint32_t i = 0; i < category->entry_count; i++) {
        if (k_strcmp(category->entries[i].name, name) == 0) {
            return &category->entries[i];
        }
    }
    return NULL;
}

static void notify_update_callback(const char* category, const char* name, const metric_value_t* value) {
    if (g_update_callback) {
        g_update_callback(category, name, value);
    }
}

status_t enterprise_metrics_init(void) {
    spinlock_init(&g_metrics_lock);
    k_memset(g_metric_categories, 0, sizeof(g_metric_categories));
    k_memset(&g_system_metrics, 0, sizeof(g_system_metrics));
    k_memset(g_performance_alerts, 0, sizeof(g_performance_alerts));
    
    g_category_count = 0;
    g_alert_count = 0;
    g_real_time_collection = false;
    g_update_callback = NULL;
    g_total_updates = 0;
    g_update_errors = 0;
    g_memory_used = 0;
    
    /* Initialize default configuration */
    g_metrics_config.enabled = true;
    g_metrics_config.collect_performance_metrics = true;
    g_metrics_config.collect_security_metrics = true;
    g_metrics_config.collect_enterprise_metrics = true;
    g_metrics_config.collect_error_metrics = true;
    g_metrics_config.collection_interval_ms = 1000;
    g_metrics_config.retention_days = 30;
    g_metrics_config.max_entries_per_category = METRICS_MAX_ENTRIES_PER_CATEGORY;
    g_metrics_config.export_to_file = false;
    g_metrics_config.compress_exports = true;
    k_strlcpy(g_metrics_config.export_path, "/var/log/metrics.json", 
              sizeof(g_metrics_config.export_path));
    
    /* Create default categories */
    metrics_create_category(METRICS_CATEGORY_SYSTEM, "System performance metrics");
    metrics_create_category(METRICS_CATEGORY_MEMORY, "Memory usage metrics");
    metrics_create_category(METRICS_CATEGORY_CPU, "CPU utilization metrics");
    metrics_create_category(METRICS_CATEGORY_IO, "I/O performance metrics");
    metrics_create_category(METRICS_CATEGORY_NETWORK, "Network statistics");
    metrics_create_category(METRICS_CATEGORY_SECURITY, "Security event metrics");
    metrics_create_category(METRICS_CATEGORY_ENTERPRISE, "Enterprise feature metrics");
    metrics_create_category(METRICS_CATEGORY_ERRORS, "System error metrics");
    
    /* Create common metrics */
    metrics_create_gauge(METRICS_CATEGORY_SYSTEM, METRIC_CPU_UTILIZATION, "CPU utilization percentage");
    metrics_create_gauge(METRICS_CATEGORY_MEMORY, METRIC_MEMORY_USAGE, "Memory usage in bytes");
    metrics_create_counter(METRICS_CATEGORY_IO, "disk_reads_total", "Total disk read operations");
    metrics_create_counter(METRICS_CATEGORY_IO, "disk_writes_total", "Total disk write operations");
    metrics_create_counter(METRICS_CATEGORY_NETWORK, "packets_sent_total", "Total packets sent");
    metrics_create_counter(METRICS_CATEGORY_NETWORK, "packets_received_total", "Total packets received");
    metrics_create_counter(METRICS_CATEGORY_SECURITY, "auth_attempts_total", "Authentication attempts");
    metrics_create_counter(METRICS_CATEGORY_SECURITY, "auth_failures_total", "Authentication failures");
    metrics_create_counter(METRICS_CATEGORY_ENTERPRISE, "backups_total", "Total backup operations");
    metrics_create_counter(METRICS_CATEGORY_ENTERPRISE, "audit_events_total", "Total audit events");
    metrics_create_counter(METRICS_CATEGORY_ERRORS, "kernel_errors_total", "Total kernel errors");
    
    log_info("[METRICS] Enterprise metrics subsystem initialized");
    return STATUS_OK;
}

status_t enterprise_metrics_shutdown(void) {
    /* Stop real-time collection */
    g_real_time_collection = false;
    g_update_callback = NULL;
    
    /* Export final metrics if configured */
    if (g_metrics_config.export_to_file) {
        metrics_export_to_file(g_metrics_config.export_path, METRICS_FORMAT_JSON);
    }
    
    log_info("[METRICS] Enterprise metrics subsystem shutdown");
    return STATUS_OK;
}

status_t metrics_create_category(const char* name, const char* description) {
    if (!name || g_category_count >= METRICS_MAX_CATEGORIES) {
        return STATUS_INVALID;
    }
    
    spin_lock(&g_metrics_lock);
    
    /* Check if category already exists */
    if (find_category(name)) {
        spin_unlock(&g_metrics_lock);
        return STATUS_EXISTS;
    }
    
    metric_category_t* category = &g_metric_categories[g_category_count];
    k_strlcpy(category->name, name, sizeof(category->name));
    if (description) {
        k_strlcpy(category->description, description, sizeof(category->description));
    }
    category->entry_count = 0;
    category->enabled = true;
    spinlock_init(&category->lock);
    
    g_category_count++;
    g_memory_used += sizeof(metric_category_t);
    
    spin_unlock(&g_metrics_lock);
    return STATUS_OK;
}

status_t metrics_create_counter(const char* category_name, const char* name, const char* description) {
    if (!category_name || !name) return STATUS_INVALID;
    
    spin_lock(&g_metrics_lock);
    
    metric_category_t* category = find_category(category_name);
    if (!category) {
        spin_unlock(&g_metrics_lock);
        return STATUS_NOTFOUND;
    }
    
    if (category->entry_count >= METRICS_MAX_ENTRIES_PER_CATEGORY) {
        spin_unlock(&g_metrics_lock);
        return STATUS_NO_SPACE;
    }
    
    /* Check if metric already exists */
    if (find_metric(category, name)) {
        spin_unlock(&g_metrics_lock);
        return STATUS_EXISTS;
    }
    
    spin_lock(&category->lock);
    
    metric_entry_t* metric = &category->entries[category->entry_count];
    k_strlcpy(metric->name, name, sizeof(metric->name));
    if (description) {
        k_strlcpy(metric->description, description, sizeof(metric->description));
    }
    metric->type = METRIC_TYPE_COUNTER;
    metric->aggregation = METRIC_AGG_SUM;
    metric->created_time = timer_get_ticks();
    metric->last_updated = 0;
    metric->update_count = 0;
    metric->value.counter_value = 0;
    metric->enabled = true;
    spinlock_init(&metric->lock);
    
    category->entry_count++;
    g_memory_used += sizeof(metric_entry_t);
    
    spin_unlock(&category->lock);
    spin_unlock(&g_metrics_lock);
    
    return STATUS_OK;
}

status_t metrics_create_gauge(const char* category_name, const char* name, const char* description) {
    if (!category_name || !name) return STATUS_INVALID;
    
    spin_lock(&g_metrics_lock);
    
    metric_category_t* category = find_category(category_name);
    if (!category) {
        spin_unlock(&g_metrics_lock);
        return STATUS_NOTFOUND;
    }
    
    if (category->entry_count >= METRICS_MAX_ENTRIES_PER_CATEGORY) {
        spin_unlock(&g_metrics_lock);
        return STATUS_NO_SPACE;
    }
    
    if (find_metric(category, name)) {
        spin_unlock(&g_metrics_lock);
        return STATUS_EXISTS;
    }
    
    spin_lock(&category->lock);
    
    metric_entry_t* metric = &category->entries[category->entry_count];
    k_strlcpy(metric->name, name, sizeof(metric->name));
    if (description) {
        k_strlcpy(metric->description, description, sizeof(metric->description));
    }
    metric->type = METRIC_TYPE_GAUGE;
    metric->aggregation = METRIC_AGG_AVERAGE;
    metric->created_time = timer_get_ticks();
    metric->last_updated = 0;
    metric->update_count = 0;
    metric->value.gauge_value = 0;
    metric->enabled = true;
    spinlock_init(&metric->lock);
    
    category->entry_count++;
    g_memory_used += sizeof(metric_entry_t);
    
    spin_unlock(&category->lock);
    spin_unlock(&g_metrics_lock);
    
    return STATUS_OK;
}

status_t metrics_increment_counter(const char* category_name, const char* name, uint64_t value) {
    if (!category_name || !name) return STATUS_INVALID;
    
    spin_lock(&g_metrics_lock);
    
    metric_category_t* category = find_category(category_name);
    if (!category || !category->enabled) {
        spin_unlock(&g_metrics_lock);
        g_update_errors++;
        return STATUS_NOTFOUND;
    }
    
    metric_entry_t* metric = find_metric(category, name);
    if (!metric || !metric->enabled || metric->type != METRIC_TYPE_COUNTER) {
        spin_unlock(&g_metrics_lock);
        g_update_errors++;
        return STATUS_INVALID;
    }
    
    spin_lock(&metric->lock);
    metric->value.counter_value += value;
    metric->last_updated = timer_get_ticks();
    metric->update_count++;
    g_total_updates++;
    
    /* Notify callback */
    notify_update_callback(category_name, name, &metric->value);
    
    spin_unlock(&metric->lock);
    spin_unlock(&g_metrics_lock);
    
    return STATUS_OK;
}

status_t metrics_set_gauge(const char* category_name, const char* name, int64_t value) {
    if (!category_name || !name) return STATUS_INVALID;
    
    spin_lock(&g_metrics_lock);
    
    metric_category_t* category = find_category(category_name);
    if (!category || !category->enabled) {
        spin_unlock(&g_metrics_lock);
        g_update_errors++;
        return STATUS_NOTFOUND;
    }
    
    metric_entry_t* metric = find_metric(category, name);
    if (!metric || !metric->enabled || metric->type != METRIC_TYPE_GAUGE) {
        spin_unlock(&g_metrics_lock);
        g_update_errors++;
        return STATUS_INVALID;
    }
    
    spin_lock(&metric->lock);
    metric->value.gauge_value = value;
    metric->last_updated = timer_get_ticks();
    metric->update_count++;
    g_total_updates++;
    
    /* Notify callback */
    notify_update_callback(category_name, name, &metric->value);
    
    spin_unlock(&metric->lock);
    spin_unlock(&g_metrics_lock);
    
    return STATUS_OK;
}

status_t metrics_set_gauge_float(const char* category_name, const char* name, double value) {
    if (!category_name || !name) return STATUS_INVALID;
    
    spin_lock(&g_metrics_lock);
    
    metric_category_t* category = find_category(category_name);
    if (!category || !category->enabled) {
        spin_unlock(&g_metrics_lock);
        g_update_errors++;
        return STATUS_NOTFOUND;
    }
    
    metric_entry_t* metric = find_metric(category, name);
    if (!metric || !metric->enabled || metric->type != METRIC_TYPE_GAUGE) {
        spin_unlock(&g_metrics_lock);
        g_update_errors++;
        return STATUS_INVALID;
    }
    
    spin_lock(&metric->lock);
    metric->value.float_value = value;
    metric->last_updated = timer_get_ticks();
    metric->update_count++;
    g_total_updates++;
    
    /* Notify callback */
    notify_update_callback(category_name, name, &metric->value);
    
    spin_unlock(&metric->lock);
    spin_unlock(&g_metrics_lock);
    
    return STATUS_OK;
}

status_t metrics_update_system_metrics(void) {
    if (!g_metrics_config.enabled || !g_metrics_config.collect_performance_metrics) {
        return STATUS_OK;
    }
    
    uint64_t current_time = timer_get_ticks();
    
    /* Update system counters atomically */
    g_system_metrics.last_update_time = current_time;
    
    /* Update built-in metrics */
    metrics_set_gauge(METRICS_CATEGORY_MEMORY, METRIC_MEMORY_USAGE, 
                     (int64_t)g_system_metrics.memory_current_usage);
    
    /* Update I/O metrics */
    metrics_increment_counter(METRICS_CATEGORY_IO, "disk_reads_total", 1);
    metrics_increment_counter(METRICS_CATEGORY_IO, "disk_writes_total", 1);
    
    /* Update network metrics */
    metrics_increment_counter(METRICS_CATEGORY_NETWORK, "packets_sent_total", 
                             g_system_metrics.network_packets_sent);
    metrics_increment_counter(METRICS_CATEGORY_NETWORK, "packets_received_total",
                             g_system_metrics.network_packets_received);
    
    /* Update security metrics */
    metrics_increment_counter(METRICS_CATEGORY_SECURITY, "auth_attempts_total",
                             g_system_metrics.authentication_attempts);
    metrics_increment_counter(METRICS_CATEGORY_SECURITY, "auth_failures_total",
                             g_system_metrics.authentication_failures);
    
    /* Update enterprise metrics */
    metrics_increment_counter(METRICS_CATEGORY_ENTERPRISE, "backups_total",
                             g_system_metrics.backup_operations);
    metrics_increment_counter(METRICS_CATEGORY_ENTERPRISE, "audit_events_total",
                             g_system_metrics.audit_events);
    
    /* Update error metrics */
    metrics_increment_counter(METRICS_CATEGORY_ERRORS, "kernel_errors_total",
                             g_system_metrics.kernel_errors);
    
    return STATUS_OK;
}

status_t metrics_get_system_metrics(system_metrics_t* out_metrics) {
    if (!out_metrics) return STATUS_INVALID;
    
    *out_metrics = g_system_metrics;
    return STATUS_OK;
}

status_t metrics_export_to_file(const char* file_path, metrics_export_format_t format) {
    if (!file_path) return STATUS_INVALID;
    
    int fd = vfs_open(file_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        return STATUS_ERROR;
    }
    
    /* Export in JSON format */
    if (format == METRICS_FORMAT_JSON) {
        vfs_write(fd, "{\n", 2);
        vfs_write(fd, "  \"timestamp\": ", 14);
        
        char timestamp_str[32];
        k_snprintf(timestamp_str, sizeof(timestamp_str), "%llu,\n", timer_get_ticks());
        vfs_write(fd, timestamp_str, k_strlen(timestamp_str));
        
        vfs_write(fd, "  \"categories\": [\n", 18);
        
        spin_lock(&g_metrics_lock);
        for (uint32_t i = 0; i < g_category_count; i++) {
            metric_category_t* category = &g_metric_categories[i];
            if (!category->enabled) continue;
            
            char category_json[1024];
            k_snprintf(category_json, sizeof(category_json),
                      "    {\n"
                      "      \"name\": \"%s\",\n"
                      "      \"description\": \"%s\",\n"
                      "      \"metrics\": [\n",
                      category->name, category->description);
            vfs_write(fd, category_json, k_strlen(category_json));
            
            spin_lock(&category->lock);
            for (uint32_t j = 0; j < category->entry_count; j++) {
                metric_entry_t* metric = &category->entries[j];
                if (!metric->enabled) continue;
                
                char metric_json[512];
                if (metric->type == METRIC_TYPE_COUNTER) {
                    k_snprintf(metric_json, sizeof(metric_json),
                              "        {\n"
                              "          \"name\": \"%s\",\n"
                              "          \"type\": \"counter\",\n"
                              "          \"value\": %llu,\n"
                              "          \"last_updated\": %llu\n"
                              "        }%s\n",
                              metric->name, metric->value.counter_value,
                              metric->last_updated, 
                              (j < category->entry_count - 1) ? "," : "");
                } else if (metric->type == METRIC_TYPE_GAUGE) {
                    k_snprintf(metric_json, sizeof(metric_json),
                              "        {\n"
                              "          \"name\": \"%s\",\n"
                              "          \"type\": \"gauge\",\n"
                              "          \"value\": %lld,\n"
                              "          \"last_updated\": %llu\n"
                              "        }%s\n",
                              metric->name, metric->value.gauge_value,
                              metric->last_updated,
                              (j < category->entry_count - 1) ? "," : "");
                }
                vfs_write(fd, metric_json, k_strlen(metric_json));
            }
            spin_unlock(&category->lock);
            
            vfs_write(fd, "      ]\n", 8);
            vfs_write(fd, (i < g_category_count - 1) ? "    },\n" : "    }\n", 
                     (i < g_category_count - 1) ? 7 : 6);
        }
        spin_unlock(&g_metrics_lock);
        
        vfs_write(fd, "  ]\n", 4);
        vfs_write(fd, "}\n", 2);
    }
    
    vfs_close(fd);
    return STATUS_OK;
}

status_t metrics_get_metric_value(const char* category_name, const char* name, metric_value_t* out_value) {
    if (!category_name || !name || !out_value) return STATUS_INVALID;
    
    spin_lock(&g_metrics_lock);
    
    metric_category_t* category = find_category(category_name);
    if (!category) {
        spin_unlock(&g_metrics_lock);
        return STATUS_NOTFOUND;
    }
    
    metric_entry_t* metric = find_metric(category, name);
    if (!metric) {
        spin_unlock(&g_metrics_lock);
        return STATUS_NOTFOUND;
    }
    
    spin_lock(&metric->lock);
    *out_value = metric->value;
    spin_unlock(&metric->lock);
    
    spin_unlock(&g_metrics_lock);
    return STATUS_OK;
}

status_t metrics_get_collection_stats(uint64_t* out_updates, uint64_t* out_errors, uint64_t* out_memory_used) {
    if (out_updates) *out_updates = g_total_updates;
    if (out_errors) *out_errors = g_update_errors;
    if (out_memory_used) *out_memory_used = g_memory_used;
    return STATUS_OK;
}

/* Convenience functions for common system metrics */
void metrics_record_context_switch(void) {
    atomic_add(&g_system_metrics.context_switches, 1);
    metrics_increment_counter(METRICS_CATEGORY_SYSTEM, "context_switches_total", 1);
}

void metrics_record_interrupt(void) {
    atomic_add(&g_system_metrics.interrupts, 1);
    metrics_increment_counter(METRICS_CATEGORY_SYSTEM, "interrupts_total", 1);
}

void metrics_record_page_fault(void) {
    atomic_add(&g_system_metrics.page_faults, 1);
    metrics_increment_counter(METRICS_CATEGORY_MEMORY, "page_faults_total", 1);
}

void metrics_record_syscall(void) {
    atomic_add(&g_system_metrics.system_calls, 1);
    metrics_increment_counter(METRICS_CATEGORY_SYSTEM, "syscalls_total", 1);
}

void metrics_record_authentication_attempt(bool success) {
    atomic_add(&g_system_metrics.authentication_attempts, 1);
    if (!success) {
        atomic_add(&g_system_metrics.authentication_failures, 1);
    }
}

void metrics_record_backup_operation(bool success) {
    atomic_add(&g_system_metrics.backup_operations, 1);
    if (!success) {
        atomic_add(&g_system_metrics.backup_failures, 1);
    }
}

void metrics_record_audit_event(void) {
    atomic_add(&g_system_metrics.audit_events, 1);
}

void metrics_record_security_violation(void) {
    atomic_add(&g_system_metrics.security_violations, 1);
}