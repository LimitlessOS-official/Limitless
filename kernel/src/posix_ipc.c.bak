/*
 * posix_ipc.c - LimitlessOS POSIX IPC Implementation
 * 
 * Complete POSIX IPC including pipes, FIFOs, shared memory,
 * message queues, and semaphores with production features.
 */

#include "kernel.h"
#include "process.h"
#include "vfs.h"
#include "vmm.h"
#include "fd.h"

#define PIPE_BUFFER_SIZE    65536   /* 64KB pipe buffer */
#define MAX_PIPES           4096
#define MAX_SHARED_MEMORY   1024
#define MAX_MESSAGE_QUEUES  256
#define MAX_SEMAPHORES      1024

/* Pipe flags */
#define PIPE_READ_END       0
#define PIPE_WRITE_END      1

/* Shared memory flags */
#define IPC_CREAT           0001000
#define IPC_EXCL            0002000
#define IPC_NOWAIT          0004000
#define IPC_RMID            0

/* Message queue limits */
#define MQ_MAXMSG           1024
#define MQ_MSGSIZE          8192

/* Pipe structure */
typedef struct pipe {
    uint32_t id;                /* Pipe ID */
    
    /* Buffer management */
    uint8_t* buffer;            /* Circular buffer */
    size_t size;                /* Buffer size */
    size_t read_pos;            /* Read position */
    size_t write_pos;           /* Write position */
    size_t data_count;          /* Bytes in buffer */
    
    /* Reference counting */
    atomic_t readers;           /* Number of read file descriptors */
    atomic_t writers;           /* Number of write file descriptors */
    
    /* Synchronization */
    struct wait_queue* read_waiters;    /* Processes waiting to read */
    struct wait_queue* write_waiters;   /* Processes waiting to write */
    spinlock_t lock;
    
    /* Statistics */
    uint64_t bytes_read;
    uint64_t bytes_written;
    uint64_t read_operations;
    uint64_t write_operations;
    
    bool is_named;              /* Named pipe (FIFO) */
    char name[256];             /* FIFO name */
    
    struct list_head list;      /* Global pipe list */
    
} pipe_t;

/* Shared memory segment */
typedef struct shm_segment {
    int shmid;                  /* Shared memory ID */
    key_t key;                  /* IPC key */
    
    size_t size;                /* Segment size */
    paddr_t phys_base;          /* Physical base address */
    
    /* Permissions */
    uid_t owner_uid;
    gid_t owner_gid;
    uint16_t perms;             /* Permission bits */
    
    /* Attachment info */
    uint32_t attach_count;      /* Number of attachments */
    pid_t creator_pid;          /* Creator process */
    pid_t last_attach_pid;      /* Last attach process */
    pid_t last_detach_pid;      /* Last detach process */
    
    /* Timestamps */
    uint64_t create_time;
    uint64_t attach_time;
    uint64_t detach_time;
    
    /* Attachment list */
    struct list_head attachments;
    
    spinlock_t lock;
    struct list_head list;
    
} shm_segment_t;

/* Shared memory attachment */
typedef struct shm_attachment {
    pid_t pid;                  /* Process ID */
    virt_addr_t vaddr;          /* Virtual address */
    int flags;                  /* Attachment flags */
    
    struct list_head list;
    
} shm_attachment_t;

/* Message queue */
typedef struct message_queue {
    int mqd;                    /* Message queue descriptor */
    key_t key;                  /* IPC key */
    
    /* Queue properties */
    uint32_t max_msgs;          /* Maximum messages */
    uint32_t msg_size;          /* Maximum message size */
    uint32_t current_msgs;      /* Current message count */
    
    /* Message buffer */
    uint8_t* buffer;            /* Message buffer */
    size_t buffer_size;         /* Buffer size */
    
    /* Message queue */
    struct list_head messages;
    
    /* Waiting processes */
    struct wait_queue* send_waiters;
    struct wait_queue* recv_waiters;
    
    /* Permissions */
    uid_t owner_uid;
    gid_t owner_gid;
    uint16_t perms;
    
    /* Statistics */
    uint64_t messages_sent;
    uint64_t messages_received;
    
    spinlock_t lock;
    struct list_head list;
    
} message_queue_t;

/* Message structure */
typedef struct message {
    uint32_t type;              /* Message type */
    uint32_t size;              /* Message size */
    uint8_t data[];             /* Message data */
    
    struct list_head list;
    
} message_t;

/* Semaphore set */
typedef struct semaphore_set {
    int semid;                  /* Semaphore set ID */
    key_t key;                  /* IPC key */
    
    uint32_t nsems;             /* Number of semaphores */
    int16_t* values;            /* Semaphore values */
    
    /* Waiting processes */
    struct wait_queue** waiters; /* Per-semaphore waiters */
    
    /* Permissions */
    uid_t owner_uid;
    gid_t owner_gid;
    uint16_t perms;
    
    /* Operations */
    uint64_t operations;
    
    spinlock_t lock;
    struct list_head list;
    
} semaphore_set_t;

/* Global IPC state */
static struct {
    bool initialized;
    
    /* Pipes */
    struct list_head pipes;
    spinlock_t pipe_lock;
    uint32_t next_pipe_id;
    
    /* Shared memory */
    struct list_head shm_segments;
    spinlock_t shm_lock;
    int next_shmid;
    
    /* Message queues */
    struct list_head message_queues;
    spinlock_t mq_lock;
    int next_mqd;
    
    /* Semaphores */
    struct list_head semaphore_sets;
    spinlock_t sem_lock;
    int next_semid;
    
    /* Statistics */
    atomic64_t pipes_created;
    atomic64_t pipes_destroyed;
    atomic64_t shm_segments_created;
    atomic64_t shm_attachments;
    atomic64_t messages_sent;
    atomic64_t messages_received;
    atomic64_t sem_operations;
    
} g_ipc_mgr = {0};

/* Function prototypes */
static pipe_t* pipe_create(size_t buffer_size);
static void pipe_destroy(pipe_t* pipe);
static ssize_t pipe_read(struct file* file, void* buf, size_t count);
static ssize_t pipe_write(struct file* file, const void* buf, size_t count);
static int pipe_close(struct file* file);

static shm_segment_t* shm_create_segment(key_t key, size_t size, int flags);
static shm_segment_t* shm_find_segment(int shmid);
static int shm_attach_segment(shm_segment_t* seg, virt_addr_t* addr, int flags);
static int shm_detach_segment(shm_segment_t* seg, virt_addr_t addr);

/* File operations for pipes */
static struct file_operations pipe_fops = {
    .read = pipe_read,
    .write = pipe_write,
    .close = pipe_close,
};

/* Initialize POSIX IPC */
int posix_ipc_init(void) {
    if (g_ipc_mgr.initialized) {
        return 0;
    }
    
    printf("Initializing POSIX IPC\n");
    
    memset(&g_ipc_mgr, 0, sizeof(g_ipc_mgr));
    
    /* Initialize lists and locks */
    INIT_LIST_HEAD(&g_ipc_mgr.pipes);
    INIT_LIST_HEAD(&g_ipc_mgr.shm_segments);
    INIT_LIST_HEAD(&g_ipc_mgr.message_queues);
    INIT_LIST_HEAD(&g_ipc_mgr.semaphore_sets);
    
    spinlock_init(&g_ipc_mgr.pipe_lock);
    spinlock_init(&g_ipc_mgr.shm_lock);
    spinlock_init(&g_ipc_mgr.mq_lock);
    spinlock_init(&g_ipc_mgr.sem_lock);
    
    g_ipc_mgr.next_pipe_id = 1;
    g_ipc_mgr.next_shmid = 1;
    g_ipc_mgr.next_mqd = 1;
    g_ipc_mgr.next_semid = 1;
    
    g_ipc_mgr.initialized = true;
    
    printf("POSIX IPC initialized\n");
    return 0;
}

/* Create pipe system call */
int sys_pipe(int pipefd[2]) {
    struct process* proc = get_current_process();
    if (!proc) {
        return -ESRCH;
    }
    
    /* Validate user pointer */
    if (!is_user_address_valid(pipefd, sizeof(int) * 2)) {
        return -EFAULT;
    }
    
    /* Create pipe */
    pipe_t* pipe = pipe_create(PIPE_BUFFER_SIZE);
    if (!pipe) {
        return -ENOMEM;
    }
    
    /* Create file descriptors */
    struct file* read_file = (struct file*)vmm_kmalloc(sizeof(struct file), 32);
    struct file* write_file = (struct file*)vmm_kmalloc(sizeof(struct file), 32);
    
    if (!read_file || !write_file) {
        if (read_file) vmm_kfree(read_file, sizeof(struct file));
        if (write_file) vmm_kfree(write_file, sizeof(struct file));
        pipe_destroy(pipe);
        return -ENOMEM;
    }
    
    memset(read_file, 0, sizeof(struct file));
    memset(write_file, 0, sizeof(struct file));
    
    /* Set up read end */
    read_file->private_data = pipe;
    read_file->f_op = &pipe_fops;
    read_file->f_flags = O_RDONLY;
    atomic_inc(&pipe->readers);
    
    /* Set up write end */
    write_file->private_data = pipe;
    write_file->f_op = &pipe_fops;
    write_file->f_flags = O_WRONLY;
    atomic_inc(&pipe->writers);
    
    /* Allocate file descriptors */
    int read_fd = fd_allocate(proc->fd_table, read_file);
    int write_fd = fd_allocate(proc->fd_table, write_file);
    
    if (read_fd < 0 || write_fd < 0) {
        if (read_fd >= 0) fd_close(proc->fd_table, read_fd);
        if (write_fd >= 0) fd_close(proc->fd_table, write_fd);
        
        vmm_kfree(read_file, sizeof(struct file));
        vmm_kfree(write_file, sizeof(struct file));
        pipe_destroy(pipe);
        return -EMFILE;
    }
    
    pipefd[0] = read_fd;
    pipefd[1] = write_fd;
    
    atomic64_inc(&g_ipc_mgr.pipes_created);
    
    printf("Pipe created: read_fd=%d, write_fd=%d\n", read_fd, write_fd);
    
    return 0;
}

/* Create FIFO (named pipe) */
int sys_mkfifo(const char* pathname, mode_t mode) {
    /* Validate pathname */
    if (!pathname || !is_user_address_valid(pathname, 1)) {
        return -EFAULT;
    }
    
    /* Copy pathname to kernel */
    char* kernel_path = (char*)vmm_kmalloc(PATH_MAX, 16);
    if (!kernel_path) {
        return -ENOMEM;
    }
    
    int ret = copy_from_user(kernel_path, pathname, PATH_MAX - 1);
    if (ret != 0) {
        vmm_kfree(kernel_path, PATH_MAX);
        return -EFAULT;
    }
    kernel_path[PATH_MAX - 1] = '\0';
    
    /* Create pipe */
    pipe_t* pipe = pipe_create(PIPE_BUFFER_SIZE);
    if (!pipe) {
        vmm_kfree(kernel_path, PATH_MAX);
        return -ENOMEM;
    }
    
    pipe->is_named = true;
    strncpy(pipe->name, kernel_path, sizeof(pipe->name) - 1);
    
    /* Create VFS node for FIFO */
    ret = vfs_create_fifo(kernel_path, mode, pipe);
    if (ret != 0) {
        pipe_destroy(pipe);
        vmm_kfree(kernel_path, PATH_MAX);
        return ret;
    }
    
    vmm_kfree(kernel_path, PATH_MAX);
    
    printf("FIFO created: %s\n", pipe->name);
    
    return 0;
}

/* Shared memory get */
int sys_shmget(key_t key, size_t size, int shmflg) {
    /* Find existing segment by key */
    shm_segment_t* seg = NULL;
    
    spin_lock(&g_ipc_mgr.shm_lock);
    
    shm_segment_t* s;
    list_for_each_entry(s, &g_ipc_mgr.shm_segments, list) {
        if (s->key == key) {
            seg = s;
            break;
        }
    }
    
    /* Create new segment if requested */
    if (!seg && (shmflg & IPC_CREAT)) {
        seg = shm_create_segment(key, size, shmflg);
        if (seg) {
            list_add(&seg->list, &g_ipc_mgr.shm_segments);
            atomic64_inc(&g_ipc_mgr.shm_segments_created);
        }
    }
    
    spin_unlock(&g_ipc_mgr.shm_lock);
    
    if (!seg) {
        return -ENOENT;
    }
    
    /* Check for exclusive creation */
    if ((shmflg & IPC_EXCL) && seg->key == key) {
        return -EEXIST;
    }
    
    return seg->shmid;
}

/* Shared memory attach */
void* sys_shmat(int shmid, const void* shmaddr, int shmflg) {
    shm_segment_t* seg = shm_find_segment(shmid);
    if (!seg) {
        return (void*)-EINVAL;
    }
    
    /* Determine attach address */
    virt_addr_t addr;
    if (shmaddr) {
        addr = (virt_addr_t)shmaddr;
        /* TODO: Validate address alignment and availability */
    } else {
        /* Find suitable virtual address */
        addr = 0x60000000;  /* Default shared memory region */
    }
    
    int ret = shm_attach_segment(seg, &addr, shmflg);
    if (ret != 0) {
        return (void*)(long)ret;
    }
    
    atomic64_inc(&g_ipc_mgr.shm_attachments);
    
    return (void*)addr;
}

/* Shared memory detach */
int sys_shmdt(const void* shmaddr) {
    virt_addr_t addr = (virt_addr_t)shmaddr;
    
    /* Find segment by address */
    spin_lock(&g_ipc_mgr.shm_lock);
    
    shm_segment_t* seg = NULL;
    shm_segment_t* s;
    
    list_for_each_entry(s, &g_ipc_mgr.shm_segments, list) {
        shm_attachment_t* att;
        list_for_each_entry(att, &s->attachments, list) {
            if (att->vaddr == addr) {
                seg = s;
                break;
            }
        }
        if (seg) break;
    }
    
    spin_unlock(&g_ipc_mgr.shm_lock);
    
    if (!seg) {
        return -EINVAL;
    }
    
    return shm_detach_segment(seg, addr);
}

/* Create pipe object */
static pipe_t* pipe_create(size_t buffer_size) {
    pipe_t* pipe = (pipe_t*)vmm_kmalloc(sizeof(pipe_t), 64);
    if (!pipe) {
        return NULL;
    }
    
    memset(pipe, 0, sizeof(pipe_t));
    
    /* Allocate buffer */
    pipe->buffer = (uint8_t*)vmm_kmalloc(buffer_size, PAGE_SIZE);
    if (!pipe->buffer) {
        vmm_kfree(pipe, sizeof(pipe_t));
        return NULL;
    }
    
    /* Initialize pipe */
    spin_lock(&g_ipc_mgr.pipe_lock);
    pipe->id = g_ipc_mgr.next_pipe_id++;
    spin_unlock(&g_ipc_mgr.pipe_lock);
    
    pipe->size = buffer_size;
    pipe->read_pos = 0;
    pipe->write_pos = 0;
    pipe->data_count = 0;
    
    atomic_set(&pipe->readers, 0);
    atomic_set(&pipe->writers, 0);
    
    pipe->read_waiters = wait_queue_create();
    pipe->write_waiters = wait_queue_create();
    spinlock_init(&pipe->lock);
    
    /* Add to global list */
    spin_lock(&g_ipc_mgr.pipe_lock);
    list_add(&pipe->list, &g_ipc_mgr.pipes);
    spin_unlock(&g_ipc_mgr.pipe_lock);
    
    return pipe;
}

/* Destroy pipe */
static void pipe_destroy(pipe_t* pipe) {
    if (!pipe) {
        return;
    }
    
    /* Remove from global list */
    spin_lock(&g_ipc_mgr.pipe_lock);
    list_del(&pipe->list);
    spin_unlock(&g_ipc_mgr.pipe_lock);
    
    /* Wake all waiters */
    if (pipe->read_waiters) {
        wait_queue_wake_all(pipe->read_waiters);
        wait_queue_destroy(pipe->read_waiters);
    }
    
    if (pipe->write_waiters) {
        wait_queue_wake_all(pipe->write_waiters);
        wait_queue_destroy(pipe->write_waiters);
    }
    
    /* Free buffer */
    if (pipe->buffer) {
        vmm_kfree(pipe->buffer, pipe->size);
    }
    
    vmm_kfree(pipe, sizeof(pipe_t));
    
    atomic64_inc(&g_ipc_mgr.pipes_destroyed);
}

/* Pipe read operation */
static ssize_t pipe_read(struct file* file, void* buf, size_t count) {
    pipe_t* pipe = (pipe_t*)file->private_data;
    if (!pipe) {
        return -EINVAL;
    }
    
    spin_lock(&pipe->lock);
    
    /* Check if any writers exist */
    if (atomic_read(&pipe->writers) == 0 && pipe->data_count == 0) {
        spin_unlock(&pipe->lock);
        return 0;  /* EOF */
    }
    
    /* Wait for data if pipe is empty */
    while (pipe->data_count == 0 && atomic_read(&pipe->writers) > 0) {
        spin_unlock(&pipe->lock);
        
        int ret = wait_queue_sleep(pipe->read_waiters);
        if (ret != 0) {
            return -EINTR;
        }
        
        spin_lock(&pipe->lock);
    }
    
    /* Read data from pipe */
    size_t bytes_to_read = min(count, pipe->data_count);
    size_t bytes_read = 0;
    
    while (bytes_read < bytes_to_read) {
        size_t chunk_size = min(bytes_to_read - bytes_read, 
                               pipe->size - pipe->read_pos);
        
        memcpy((char*)buf + bytes_read, 
               pipe->buffer + pipe->read_pos, chunk_size);
        
        pipe->read_pos = (pipe->read_pos + chunk_size) % pipe->size;
        bytes_read += chunk_size;
    }
    
    pipe->data_count -= bytes_read;
    pipe->bytes_read += bytes_read;
    pipe->read_operations++;
    
    /* Wake waiting writers */
    if (pipe->data_count < pipe->size) {
        wait_queue_wake_one(pipe->write_waiters);
    }
    
    spin_unlock(&pipe->lock);
    
    return bytes_read;
}

/* Pipe write operation */
static ssize_t pipe_write(struct file* file, const void* buf, size_t count) {
    pipe_t* pipe = (pipe_t*)file->private_data;
    if (!pipe) {
        return -EINVAL;
    }
    
    spin_lock(&pipe->lock);
    
    /* Check if any readers exist */
    if (atomic_read(&pipe->readers) == 0) {
        spin_unlock(&pipe->lock);
        /* Send SIGPIPE to current process */
        signal_send_to_current(SIGPIPE);
        return -EPIPE;
    }
    
    size_t bytes_written = 0;
    
    while (bytes_written < count) {
        /* Wait for space in pipe */
        while (pipe->data_count >= pipe->size) {
            spin_unlock(&pipe->lock);
            
            int ret = wait_queue_sleep(pipe->write_waiters);
            if (ret != 0) {
                return bytes_written > 0 ? bytes_written : -EINTR;
            }
            
            spin_lock(&pipe->lock);
            
            /* Check if readers still exist */
            if (atomic_read(&pipe->readers) == 0) {
                spin_unlock(&pipe->lock);
                signal_send_to_current(SIGPIPE);
                return bytes_written > 0 ? bytes_written : -EPIPE;
            }
        }
        
        /* Write data to pipe */
        size_t space_available = pipe->size - pipe->data_count;
        size_t bytes_to_write = min(count - bytes_written, space_available);
        size_t chunk_size = min(bytes_to_write, pipe->size - pipe->write_pos);
        
        memcpy(pipe->buffer + pipe->write_pos, 
               (const char*)buf + bytes_written, chunk_size);
        
        pipe->write_pos = (pipe->write_pos + chunk_size) % pipe->size;
        pipe->data_count += chunk_size;
        bytes_written += chunk_size;
        
        /* Handle wrap-around */
        if (chunk_size < bytes_to_write) {
            size_t remaining = bytes_to_write - chunk_size;
            memcpy(pipe->buffer, (const char*)buf + bytes_written, remaining);
            pipe->write_pos = remaining;
            pipe->data_count += remaining;
            bytes_written += remaining;
        }
    }
    
    pipe->bytes_written += bytes_written;
    pipe->write_operations++;
    
    /* Wake waiting readers */
    if (pipe->data_count > 0) {
        wait_queue_wake_one(pipe->read_waiters);
    }
    
    spin_unlock(&pipe->lock);
    
    return bytes_written;
}

/* Pipe close operation */
static int pipe_close(struct file* file) {
    pipe_t* pipe = (pipe_t*)file->private_data;
    if (!pipe) {
        return -EINVAL;
    }
    
    /* Decrement appropriate reference count */
    if (file->f_flags & O_RDONLY) {
        atomic_dec(&pipe->readers);
        /* Wake writers if no more readers */
        if (atomic_read(&pipe->readers) == 0) {
            wait_queue_wake_all(pipe->write_waiters);
        }
    } else if (file->f_flags & O_WRONLY) {
        atomic_dec(&pipe->writers);
        /* Wake readers if no more writers */
        if (atomic_read(&pipe->writers) == 0) {
            wait_queue_wake_all(pipe->read_waiters);
        }
    }
    
    /* Destroy pipe if no more references */
    if (atomic_read(&pipe->readers) == 0 && atomic_read(&pipe->writers) == 0) {
        pipe_destroy(pipe);
    }
    
    return 0;
}

/* Create shared memory segment */
static shm_segment_t* shm_create_segment(key_t key, size_t size, int flags) {
    /* Align size to page boundary */
    size = ALIGN_UP(size, PAGE_SIZE);
    
    shm_segment_t* seg = (shm_segment_t*)vmm_kmalloc(sizeof(shm_segment_t), 64);
    if (!seg) {
        return NULL;
    }
    
    memset(seg, 0, sizeof(shm_segment_t));
    
    /* Allocate physical pages */
    size_t pages = size / PAGE_SIZE;
    paddr_t phys_base = pmm_alloc_pages(pages);
    if (!phys_base) {
        vmm_kfree(seg, sizeof(shm_segment_t));
        return NULL;
    }
    
    /* Initialize segment */
    seg->shmid = g_ipc_mgr.next_shmid++;
    seg->key = key;
    seg->size = size;
    seg->phys_base = phys_base;
    
    /* Set permissions */
    struct process* proc = get_current_process();
    if (proc) {
        seg->owner_uid = proc->security.uid;
        seg->owner_gid = proc->security.gid;
        seg->creator_pid = proc->pid;
    }
    seg->perms = flags & 0777;
    
    seg->create_time = timer_get_ticks();
    
    INIT_LIST_HEAD(&seg->attachments);
    spinlock_init(&seg->lock);
    
    return seg;
}

/* Find shared memory segment */
static shm_segment_t* shm_find_segment(int shmid) {
    spin_lock(&g_ipc_mgr.shm_lock);
    
    shm_segment_t* seg;
    list_for_each_entry(seg, &g_ipc_mgr.shm_segments, list) {
        if (seg->shmid == shmid) {
            spin_unlock(&g_ipc_mgr.shm_lock);
            return seg;
        }
    }
    
    spin_unlock(&g_ipc_mgr.shm_lock);
    return NULL;
}

/* Attach shared memory segment */
static int shm_attach_segment(shm_segment_t* seg, virt_addr_t* addr, int flags) {
    struct process* proc = get_current_process();
    if (!proc) {
        return -ESRCH;
    }
    
    /* Create attachment record */
    shm_attachment_t* att = (shm_attachment_t*)vmm_kmalloc(sizeof(shm_attachment_t), 32);
    if (!att) {
        return -ENOMEM;
    }
    
    att->pid = proc->pid;
    att->vaddr = *addr;
    att->flags = flags;
    
    /* Map pages into process address space */
    size_t pages = seg->size / PAGE_SIZE;
    
    for (size_t i = 0; i < pages; i++) {
        paddr_t phys_page = seg->phys_base + (i * PAGE_SIZE);
        virt_addr_t virt_page = *addr + (i * PAGE_SIZE);
        
        uint32_t map_flags = PTE_PRESENT | PTE_USER;
        if (!(flags & SHM_RDONLY)) {
            map_flags |= PTE_WRITABLE;
        }
        
        vmm_map_page(proc->aspace, virt_page, phys_page, map_flags);
    }
    
    /* Add to segment's attachment list */
    spin_lock(&seg->lock);
    list_add(&att->list, &seg->attachments);
    seg->attach_count++;
    seg->last_attach_pid = proc->pid;
    seg->attach_time = timer_get_ticks();
    spin_unlock(&seg->lock);
    
    return 0;
}

/* Detach shared memory segment */
static int shm_detach_segment(shm_segment_t* seg, virt_addr_t addr) {
    struct process* proc = get_current_process();
    if (!proc) {
        return -ESRCH;
    }
    
    spin_lock(&seg->lock);
    
    /* Find attachment */
    shm_attachment_t* att = NULL;
    shm_attachment_t* a;
    
    list_for_each_entry(a, &seg->attachments, list) {
        if (a->pid == proc->pid && a->vaddr == addr) {
            att = a;
            break;
        }
    }
    
    if (!att) {
        spin_unlock(&seg->lock);
        return -EINVAL;
    }
    
    /* Remove from list */
    list_del(&att->list);
    seg->attach_count--;
    seg->last_detach_pid = proc->pid;
    seg->detach_time = timer_get_ticks();
    
    spin_unlock(&seg->lock);
    
    /* Unmap pages from process address space */
    size_t pages = seg->size / PAGE_SIZE;
    for (size_t i = 0; i < pages; i++) {
        vmm_unmap_page(proc->aspace, addr + (i * PAGE_SIZE));
    }
    
    vmm_kfree(att, sizeof(shm_attachment_t));
    
    return 0;
}

/* Get IPC statistics */
void posix_ipc_get_stats(struct posix_ipc_stats* stats) {
    if (!stats) return;
    
    memset(stats, 0, sizeof(struct posix_ipc_stats));
    
    stats->pipes_created = atomic64_read(&g_ipc_mgr.pipes_created);
    stats->pipes_destroyed = atomic64_read(&g_ipc_mgr.pipes_destroyed);
    stats->shm_segments_created = atomic64_read(&g_ipc_mgr.shm_segments_created);
    stats->shm_attachments = atomic64_read(&g_ipc_mgr.shm_attachments);
    stats->messages_sent = atomic64_read(&g_ipc_mgr.messages_sent);
    stats->messages_received = atomic64_read(&g_ipc_mgr.messages_received);
    stats->sem_operations = atomic64_read(&g_ipc_mgr.sem_operations);
}

/* Debug information */
void posix_ipc_dump_stats(void) {
    struct posix_ipc_stats stats;
    posix_ipc_get_stats(&stats);
    
    printf("POSIX IPC Statistics:\n");
    printf("  Pipes created: %lu\n", stats.pipes_created);
    printf("  Pipes destroyed: %lu\n", stats.pipes_destroyed);
    printf("  Shared memory segments: %lu\n", stats.shm_segments_created);
    printf("  Shared memory attachments: %lu\n", stats.shm_attachments);
    printf("  Messages sent: %lu\n", stats.messages_sent);
    printf("  Messages received: %lu\n", stats.messages_received);
    printf("  Semaphore operations: %lu\n", stats.sem_operations);
}