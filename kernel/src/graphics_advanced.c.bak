/*
 * LimitlessOS Advanced Graphics Subsystem
 * Complete graphics stack with OpenGL/Vulkan, 2D/3D acceleration, window management,
 * compositing, font rendering, image processing, and display management
 */

#include "kernel.h"
#include "hal.h"

/* Logging macros */
#define KLOG_INFO(subsys, fmt, ...) kprintf("[INFO:%s] " fmt "\n", subsys, ##__VA_ARGS__)
#define KLOG_DEBUG(subsys, fmt, ...) kprintf("[DEBUG:%s] " fmt "\n", subsys, ##__VA_ARGS__)
#define KLOG_WARN(subsys, fmt, ...) kprintf("[WARN:%s] " fmt "\n", subsys, ##__VA_ARGS__)
#define KLOG_ERROR(subsys, fmt, ...) kprintf("[ERROR:%s] " fmt "\n", subsys, ##__VA_ARGS__)

/* Memory functions */
#define memcpy k_memcpy
#define memset k_memset
#define memcmp k_memcmp

/* Graphics API Types */
#define GFX_API_OPENGL          0x01
#define GFX_API_VULKAN          0x02
#define GFX_API_DIRECTX         0x03
#define GFX_API_METAL           0x04
#define GFX_API_SOFTWARE        0x05

/* Display Interface Types */
#define DISPLAY_INTERFACE_VGA   0x01
#define DISPLAY_INTERFACE_DVI   0x02
#define DISPLAY_INTERFACE_HDMI  0x03
#define DISPLAY_INTERFACE_DP    0x04    /* DisplayPort */
#define DISPLAY_INTERFACE_eDP   0x05    /* Embedded DisplayPort */
#define DISPLAY_INTERFACE_USB_C 0x06
#define DISPLAY_INTERFACE_WIRELESS 0x07

/* GPU Vendor IDs */
#define GPU_VENDOR_NVIDIA       0x10DE
#define GPU_VENDOR_AMD          0x1002
#define GPU_VENDOR_INTEL        0x8086
#define GPU_VENDOR_QUALCOMM     0x17CB
#define GPU_VENDOR_ARM          0x13B5

/* Pixel Formats */
#define PIXEL_FORMAT_RGB565     0x01
#define PIXEL_FORMAT_RGB888     0x02
#define PIXEL_FORMAT_RGBA8888   0x03
#define PIXEL_FORMAT_ARGB8888   0x04
#define PIXEL_FORMAT_BGR565     0x05
#define PIXEL_FORMAT_BGR888     0x06
#define PIXEL_FORMAT_BGRA8888   0x07
#define PIXEL_FORMAT_YUV420     0x08
#define PIXEL_FORMAT_YUV422     0x09
#define PIXEL_FORMAT_YUV444     0x0A

/* Window Types */
#define WINDOW_TYPE_NORMAL      0x01
#define WINDOW_TYPE_DIALOG      0x02
#define WINDOW_TYPE_POPUP       0x03
#define WINDOW_TYPE_TOOLTIP     0x04
#define WINDOW_TYPE_MENU        0x05
#define WINDOW_TYPE_DESKTOP     0x06
#define WINDOW_TYPE_SPLASH      0x07

/* Rendering Modes */
#define RENDER_MODE_IMMEDIATE   0x01
#define RENDER_MODE_RETAINED    0x02
#define RENDER_MODE_DEFERRED    0x03
#define RENDER_MODE_TILED       0x04

/* Maximum limits */
#define MAX_DISPLAYS            8
#define MAX_GPU_ADAPTERS        4
#define MAX_WINDOWS             1024
#define MAX_TEXTURES            8192
#define MAX_SHADERS             512
#define MAX_VERTEX_BUFFERS      2048
#define MAX_RENDER_TARGETS      16
#define MAX_FONTS               64

/* Color structure */
typedef struct color {
    uint8_t r, g, b, a;            /* RGBA components */
} color_t;

/* Point and rectangle structures */
typedef struct point2d {
    int32_t x, y;
} point2d_t;

typedef struct point3d {
    float x, y, z;
} point3d_t;

typedef struct rect {
    int32_t x, y, width, height;
} rect_t;

typedef struct rect3d {
    float x, y, z, width, height, depth;
} rect3d_t;

/* Matrix structures */
typedef struct matrix3x3 {
    float m[3][3];
} matrix3x3_t;

typedef struct matrix4x4 {
    float m[4][4];
} matrix4x4_t;

/* Display mode */
typedef struct display_mode {
    uint32_t width;                 /* Horizontal resolution */
    uint32_t height;                /* Vertical resolution */
    uint32_t refresh_rate;          /* Refresh rate in Hz */
    uint8_t bit_depth;              /* Color depth */
    uint8_t pixel_format;           /* Pixel format */
    bool interlaced;                /* Interlaced mode */
} display_mode_t;

/* GPU Memory Buffer */
typedef struct gpu_buffer {
    uint32_t id;                    /* Buffer ID */
    uint8_t type;                   /* Buffer type (vertex, index, uniform) */
    uint32_t size;                  /* Buffer size in bytes */
    void* data;                     /* CPU-side data pointer */
    uint64_t gpu_address;           /* GPU memory address */
    uint32_t usage;                 /* Usage flags (static, dynamic, streaming) */
    bool mapped;                    /* Currently mapped to CPU */
    
    /* Statistics */
    uint64_t allocation_time;       /* Allocation timestamp */
    uint64_t last_access;           /* Last access timestamp */
    uint32_t map_count;             /* Number of times mapped */
    
    struct gpu_buffer* next;        /* Next buffer in list */
} gpu_buffer_t;

/* Texture */
typedef struct texture {
    uint32_t id;                    /* Texture ID */
    uint32_t width;                 /* Texture width */
    uint32_t height;                /* Texture height */
    uint32_t depth;                 /* Texture depth (for 3D textures) */
    uint8_t format;                 /* Pixel format */
    uint8_t type;                   /* Texture type (2D, 3D, cubemap) */
    uint32_t mip_levels;            /* Number of mipmap levels */
    
    /* Texture data */
    void* data;                     /* Texture data */
    uint32_t data_size;             /* Data size in bytes */
    uint64_t gpu_address;           /* GPU memory address */
    
    /* Sampling parameters */
    uint8_t min_filter;             /* Minification filter */
    uint8_t mag_filter;             /* Magnification filter */
    uint8_t wrap_s;                 /* S-coordinate wrapping */
    uint8_t wrap_t;                 /* T-coordinate wrapping */
    uint8_t wrap_r;                 /* R-coordinate wrapping */
    
    /* Statistics */
    uint64_t creation_time;         /* Creation timestamp */
    uint64_t last_bind;             /* Last bind timestamp */
    uint32_t bind_count;            /* Number of times bound */
    
    struct texture* next;           /* Next texture in list */
} texture_t;

/* Shader */
typedef struct shader {
    uint32_t id;                    /* Shader ID */
    uint8_t type;                   /* Shader type (vertex, fragment, compute) */
    char* source_code;              /* Shader source code */
    uint32_t source_size;           /* Source code size */
    void* compiled_code;            /* Compiled bytecode */
    uint32_t compiled_size;         /* Compiled code size */
    
    /* Uniform locations */
    struct {
        char name[64];              /* Uniform name */
        uint32_t location;          /* Uniform location */
        uint8_t type;               /* Uniform type */
    } uniforms[32];
    uint32_t uniform_count;         /* Number of uniforms */
    
    /* Compilation status */
    bool compiled;                  /* Successfully compiled */
    char error_log[512];            /* Compilation error log */
    
    /* Statistics */
    uint64_t compilation_time;      /* Compilation timestamp */
    uint64_t last_use;              /* Last use timestamp */
    uint32_t use_count;             /* Number of times used */
    
    struct shader* next;            /* Next shader in list */
} shader_t;

/* Render target */
typedef struct render_target {
    uint32_t id;                    /* Render target ID */
    uint32_t width;                 /* Target width */
    uint32_t height;                /* Target height */
    uint8_t format;                 /* Color format */
    bool has_depth;                 /* Has depth buffer */
    bool has_stencil;               /* Has stencil buffer */
    
    /* Associated textures */
    texture_t* color_texture;       /* Color texture */
    texture_t* depth_texture;       /* Depth texture */
    texture_t* stencil_texture;     /* Stencil texture */
    
    /* Framebuffer object */
    uint32_t framebuffer_id;        /* GPU framebuffer ID */
    
    struct render_target* next;     /* Next render target */
} render_target_t;

/* Font */
typedef struct font {
    uint32_t id;                    /* Font ID */
    char name[64];                  /* Font name */
    char filename[256];             /* Font file path */
    uint32_t size;                  /* Font size in points */
    
    /* Font metrics */
    uint32_t line_height;           /* Line height */
    uint32_t ascent;                /* Ascent */
    uint32_t descent;               /* Descent */
    
    /* Glyph atlas */
    texture_t* atlas_texture;       /* Glyph atlas texture */
    struct {
        uint32_t codepoint;         /* Unicode codepoint */
        rect_t texture_rect;        /* Rectangle in atlas */
        int32_t bearing_x;          /* Horizontal bearing */
        int32_t bearing_y;          /* Vertical bearing */
        uint32_t advance;           /* Advance width */
    } glyphs[256];                  /* Cached glyphs */
    uint32_t glyph_count;           /* Number of cached glyphs */
    
    /* Font data */
    void* font_data;                /* Font file data */
    uint32_t font_size;             /* Font file size */
    
    struct font* next;              /* Next font in list */
} font_t;

/* Window */
typedef struct window {
    uint32_t id;                    /* Window ID */
    uint8_t type;                   /* Window type */
    char title[128];                /* Window title */
    
    /* Position and size */
    rect_t bounds;                  /* Window bounds */
    rect_t client_area;             /* Client area (excluding decorations) */
    
    /* Window state */
    bool visible;                   /* Window is visible */
    bool focused;                   /* Window has focus */
    bool minimized;                 /* Window is minimized */
    bool maximized;                 /* Window is maximized */
    bool resizable;                 /* Window can be resized */
    bool movable;                   /* Window can be moved */
    
    /* Parent/child relationships */
    struct window* parent;          /* Parent window */
    struct window* children;        /* Child windows */
    struct window* next_sibling;    /* Next sibling window */
    
    /* Rendering */
    render_target_t* render_target; /* Window render target */
    bool needs_redraw;              /* Window needs redrawing */
    rect_t dirty_rect;              /* Dirty rectangle */
    
    /* Window callbacks */
    void (*on_paint)(struct window* win);
    void (*on_resize)(struct window* win, uint32_t width, uint32_t height);
    void (*on_close)(struct window* win);
    void (*on_focus)(struct window* win, bool focused);
    
    /* Window properties */
    color_t background_color;       /* Background color */
    uint8_t opacity;                /* Window opacity (0-255) */
    bool composited;                /* Window is composited */
    
    /* Statistics */
    uint64_t creation_time;         /* Creation timestamp */
    uint64_t last_paint;            /* Last paint timestamp */
    uint32_t paint_count;           /* Number of paint operations */
    
    struct window* next;            /* Next window in list */
} window_t;

/* Display Output */
typedef struct display_output {
    uint32_t id;                    /* Display ID */
    uint8_t interface_type;         /* Interface type (HDMI, DP, etc) */
    char name[64];                  /* Display name */
    char manufacturer[64];          /* Manufacturer */
    char model[64];                 /* Model name */
    
    /* Current mode */
    display_mode_t current_mode;    /* Current display mode */
    display_mode_t* supported_modes; /* Supported display modes */
    uint32_t mode_count;            /* Number of supported modes */
    
    /* Physical properties */
    uint32_t width_mm;              /* Physical width in millimeters */
    uint32_t height_mm;             /* Physical height in millimeters */
    float dpi_x;                    /* Horizontal DPI */
    float dpi_y;                    /* Vertical DPI */
    
    /* Display capabilities */
    bool supports_hdcp;             /* HDCP support */
    bool supports_hdr;              /* HDR support */
    bool supports_vrr;              /* Variable refresh rate */
    uint8_t color_depth;            /* Maximum color depth */
    
    /* Connection status */
    bool connected;                 /* Display is connected */
    bool enabled;                   /* Display is enabled */
    bool primary;                   /* Primary display */
    
    /* Framebuffer */
    void* framebuffer;              /* Framebuffer memory */
    uint64_t framebuffer_size;      /* Framebuffer size */
    uint64_t framebuffer_physical;  /* Physical framebuffer address */
    
    /* Display statistics */
    uint64_t frame_count;           /* Total frames displayed */
    uint32_t current_fps;           /* Current FPS */
    uint64_t last_vsync;            /* Last VSync timestamp */
    
    struct display_output* next;    /* Next display in list */
} display_output_t;

/* GPU Adapter */
typedef struct gpu_adapter {
    uint32_t id;                    /* Adapter ID */
    uint16_t vendor_id;             /* PCI vendor ID */
    uint16_t device_id;             /* PCI device ID */
    char name[128];                 /* GPU name */
    char driver_version[64];        /* Driver version */
    
    /* GPU capabilities */
    uint64_t vram_size;             /* Video RAM size */
    uint64_t vram_used;             /* Used video RAM */
    uint32_t max_texture_size;      /* Maximum texture size */
    uint32_t max_render_targets;    /* Maximum render targets */
    uint32_t max_vertex_attributes; /* Maximum vertex attributes */
    uint32_t max_shader_uniforms;   /* Maximum shader uniforms */
    
    /* Supported features */
    bool supports_opengl;           /* OpenGL support */
    bool supports_vulkan;           /* Vulkan support */
    bool supports_directx;          /* DirectX support */
    bool supports_compute;          /* Compute shader support */
    bool supports_tessellation;     /* Tessellation support */
    bool supports_geometry_shader;  /* Geometry shader support */
    
    /* OpenGL/Vulkan versions */
    uint32_t opengl_version_major;  /* OpenGL major version */
    uint32_t opengl_version_minor;  /* OpenGL minor version */
    uint32_t vulkan_version;        /* Vulkan API version */
    
    /* Connected displays */
    display_output_t* displays;     /* Connected displays */
    uint32_t display_count;         /* Number of displays */
    
    /* Memory management */
    gpu_buffer_t* buffers;          /* GPU buffers */
    texture_t* textures;            /* GPU textures */
    shader_t* shaders;              /* GPU shaders */
    render_target_t* render_targets; /* Render targets */
    
    /* Performance counters */
    uint64_t triangles_rendered;    /* Total triangles rendered */
    uint64_t draw_calls;            /* Total draw calls */
    uint64_t state_changes;         /* GPU state changes */
    uint32_t gpu_utilization;       /* GPU utilization percentage */
    uint32_t memory_bandwidth;      /* Memory bandwidth utilization */
    
    /* GPU operations */
    status_t (*create_buffer)(struct gpu_adapter* gpu, gpu_buffer_t* buffer);
    status_t (*create_texture)(struct gpu_adapter* gpu, texture_t* texture);
    status_t (*compile_shader)(struct gpu_adapter* gpu, shader_t* shader);
    status_t (*draw_primitives)(struct gpu_adapter* gpu, uint32_t primitive_type, 
                               uint32_t vertex_count);
    
    struct gpu_adapter* next;       /* Next adapter in list */
} gpu_adapter_t;

/* Compositor */
typedef struct compositor {
    uint32_t id;                    /* Compositor ID */
    char name[64];                  /* Compositor name */
    
    /* Composition target */
    render_target_t* composition_target; /* Main composition target */
    uint32_t width;                 /* Composition width */
    uint32_t height;                /* Composition height */
    
    /* Window management */
    window_t* windows;              /* All windows */
    window_t* focused_window;       /* Currently focused window */
    window_t* desktop_window;       /* Desktop background window */
    uint32_t window_count;          /* Number of windows */
    
    /* Compositing mode */
    uint8_t compositing_mode;       /* Compositing mode */
    bool vsync_enabled;             /* VSync enabled */
    bool triple_buffering;          /* Triple buffering enabled */
    
    /* Effects */
    bool blur_enabled;              /* Blur effects enabled */
    bool transparency_enabled;      /* Transparency effects enabled */
    bool animation_enabled;         /* Animation effects enabled */
    float blur_radius;              /* Blur radius */
    
    /* Performance */
    uint64_t frames_composed;       /* Total frames composed */
    uint32_t current_fps;           /* Current composition FPS */
    uint32_t target_fps;            /* Target FPS */
    uint64_t last_frame_time;       /* Last frame timestamp */
    
    /* Compositor operations */
    status_t (*compose_frame)(struct compositor* comp);
    status_t (*add_window)(struct compositor* comp, window_t* window);
    status_t (*remove_window)(struct compositor* comp, window_t* window);
    
} compositor_t;

/* Global graphics subsystem state */
static struct {
    /* GPU adapters */
    gpu_adapter_t* adapters;        /* GPU adapters */
    gpu_adapter_t* primary_adapter; /* Primary GPU adapter */
    uint32_t adapter_count;         /* Number of adapters */
    
    /* Displays */
    display_output_t* displays;     /* All displays */
    display_output_t* primary_display; /* Primary display */
    uint32_t display_count;         /* Number of displays */
    
    /* Compositor */
    compositor_t* compositor;       /* Desktop compositor */
    
    /* Windows */
    window_t* windows;              /* All windows */
    uint32_t window_count;          /* Number of windows */
    uint32_t next_window_id;        /* Next window ID */
    
    /* Resources */
    gpu_buffer_t* buffers;          /* All GPU buffers */
    texture_t* textures;            /* All textures */
    shader_t* shaders;              /* All shaders */
    font_t* fonts;                  /* All fonts */
    
    /* Resource counters */
    uint32_t buffer_count;          /* Number of buffers */
    uint32_t texture_count;         /* Number of textures */
    uint32_t shader_count;          /* Number of shaders */
    uint32_t font_count;            /* Number of fonts */
    
    /* Memory usage */
    uint64_t total_vram_allocated;  /* Total VRAM allocated */
    uint64_t total_system_memory;   /* Total system memory used */
    
    /* Performance statistics */
    uint64_t total_triangles;       /* Total triangles rendered */
    uint64_t total_draw_calls;      /* Total draw calls */
    uint32_t current_fps;           /* Current system FPS */
    uint32_t peak_fps;              /* Peak FPS achieved */
    
    /* Configuration */
    uint8_t default_api;            /* Default graphics API */
    bool hardware_acceleration;     /* Hardware acceleration enabled */
    bool multisampling_enabled;     /* Multisampling enabled */
    uint8_t msaa_samples;           /* MSAA sample count */
    bool anisotropic_filtering;     /* Anisotropic filtering enabled */
    
    /* Synchronization */
    volatile uint32_t global_lock;  /* Global graphics lock */
    
} graphics_subsystem;

/* GPU vendor names */
static const char* gpu_vendor_names[] = {
    [GPU_VENDOR_NVIDIA & 0xFF] = "NVIDIA",
    [GPU_VENDOR_AMD & 0xFF] = "AMD", 
    [GPU_VENDOR_INTEL & 0xFF] = "Intel",
    [GPU_VENDOR_QUALCOMM & 0xFF] = "Qualcomm",
    [GPU_VENDOR_ARM & 0xFF] = "ARM"
};

static const char* api_names[] = {
    [GFX_API_OPENGL] = "OpenGL",
    [GFX_API_VULKAN] = "Vulkan",
    [GFX_API_DIRECTX] = "DirectX",
    [GFX_API_METAL] = "Metal",
    [GFX_API_SOFTWARE] = "Software"
};

static const char* pixel_format_names[] = {
    [PIXEL_FORMAT_RGB565] = "RGB565",
    [PIXEL_FORMAT_RGB888] = "RGB888",
    [PIXEL_FORMAT_RGBA8888] = "RGBA8888",
    [PIXEL_FORMAT_ARGB8888] = "ARGB8888",
    [PIXEL_FORMAT_BGR565] = "BGR565",
    [PIXEL_FORMAT_BGR888] = "BGR888", 
    [PIXEL_FORMAT_BGRA8888] = "BGRA8888",
    [PIXEL_FORMAT_YUV420] = "YUV420",
    [PIXEL_FORMAT_YUV422] = "YUV422",
    [PIXEL_FORMAT_YUV444] = "YUV444"
};

/* GPU Operations */

/* Create GPU buffer */
static status_t gpu_create_buffer(gpu_adapter_t* gpu, gpu_buffer_t* buffer) {
    if (!gpu || !buffer) {
        return STATUS_INVALID;
    }
    
    /* Allocate GPU memory (simulated) */
    buffer->gpu_address = 0x80000000ULL + (buffer->id * 0x1000);
    buffer->allocation_time = hal_timer_get_timestamp_ns();
    
    KLOG_DEBUG("GFX", "Created GPU buffer %u (%u bytes) at 0x%llX",
               buffer->id, buffer->size, buffer->gpu_address);
    
    return STATUS_OK;
}

/* Create texture */
static status_t gpu_create_texture(gpu_adapter_t* gpu, texture_t* texture) {
    if (!gpu || !texture) {
        return STATUS_INVALID;
    }
    
    /* Calculate texture size */
    uint32_t bytes_per_pixel = 4; /* Assume RGBA8888 */
    texture->data_size = texture->width * texture->height * bytes_per_pixel;
    
    /* Allocate GPU memory (simulated) */
    texture->gpu_address = 0x90000000ULL + (texture->id * 0x10000);
    texture->creation_time = hal_timer_get_timestamp_ns();
    
    KLOG_DEBUG("GFX", "Created texture %u (%ux%u, %s) at 0x%llX",
               texture->id, texture->width, texture->height,
               pixel_format_names[texture->format < 10 ? texture->format : 0],
               texture->gpu_address);
    
    return STATUS_OK;
}

/* Compile shader */
static status_t gpu_compile_shader(gpu_adapter_t* gpu, shader_t* shader) {
    if (!gpu || !shader || !shader->source_code) {
        return STATUS_INVALID;
    }
    
    KLOG_DEBUG("GFX", "Compiling shader %u (type: %u, %u bytes)",
               shader->id, shader->type, shader->source_size);
    
    /* Simulate shader compilation */
    shader->compiled_size = shader->source_size / 2; /* Compressed bytecode */
    shader->compiled_code = kalloc(shader->compiled_size);
    
    if (!shader->compiled_code) {
        strncpy(shader->error_log, "Out of memory", sizeof(shader->error_log) - 1);
        return STATUS_NOMEM;
    }
    
    /* Simulate successful compilation */
    memset(shader->compiled_code, 0xAA, shader->compiled_size);
    shader->compiled = true;
    shader->compilation_time = hal_timer_get_timestamp_ns();
    
    /* Add some simulated uniforms */
    shader->uniform_count = 3;
    strncpy(shader->uniforms[0].name, "u_mvp_matrix", 64);
    shader->uniforms[0].location = 0;
    shader->uniforms[0].type = 1; /* Matrix4 */
    
    strncpy(shader->uniforms[1].name, "u_texture", 64);
    shader->uniforms[1].location = 1;
    shader->uniforms[1].type = 2; /* Sampler2D */
    
    strncpy(shader->uniforms[2].name, "u_color", 64);
    shader->uniforms[2].location = 2;
    shader->uniforms[2].type = 3; /* Vec4 */
    
    KLOG_INFO("GFX", "Shader %u compiled successfully (%u uniforms)",
              shader->id, shader->uniform_count);
    
    return STATUS_OK;
}

/* Draw primitives */
static status_t gpu_draw_primitives(gpu_adapter_t* gpu, uint32_t primitive_type, uint32_t vertex_count) {
    if (!gpu || vertex_count == 0) {
        return STATUS_INVALID;
    }
    
    /* Update statistics */
    gpu->draw_calls++;
    if (primitive_type == 0) { /* Triangles */
        gpu->triangles_rendered += vertex_count / 3;
    }
    
    graphics_subsystem.total_draw_calls++;
    graphics_subsystem.total_triangles += vertex_count / 3;
    
    return STATUS_OK;
}

/* Window Management */

/* Create window */
static window_t* gfx_create_window(uint8_t type, const char* title, rect_t bounds) {
    window_t* window = (window_t*)kalloc(sizeof(window_t));
    if (!window) {
        return NULL;
    }
    
    memset(window, 0, sizeof(*window));
    window->id = graphics_subsystem.next_window_id++;
    window->type = type;
    strncpy(window->title, title, sizeof(window->title) - 1);
    window->bounds = bounds;
    window->client_area = bounds;
    
    /* Adjust client area for window decorations */
    if (type == WINDOW_TYPE_NORMAL) {
        window->client_area.y += 30; /* Title bar height */
        window->client_area.height -= 30;
    }
    
    /* Set default properties */
    window->visible = true;
    window->resizable = (type == WINDOW_TYPE_NORMAL);
    window->movable = (type != WINDOW_TYPE_DESKTOP);
    window->background_color = (color_t){240, 240, 240, 255}; /* Light gray */
    window->opacity = 255; /* Fully opaque */
    
    /* Create render target for window */
    window->render_target = (render_target_t*)kalloc(sizeof(render_target_t));
    if (window->render_target) {
        window->render_target->id = window->id;
        window->render_target->width = bounds.width;
        window->render_target->height = bounds.height;
        window->render_target->format = PIXEL_FORMAT_RGBA8888;
        window->render_target->has_depth = false;
        window->render_target->has_stencil = false;
    }
    
    window->creation_time = hal_timer_get_timestamp_ns();
    window->needs_redraw = true;
    
    return window;
}

/* Font Management */

/* Load font */
static font_t* gfx_load_font(const char* name, const char* filename, uint32_t size) {
    font_t* font = (font_t*)kalloc(sizeof(font_t));
    if (!font) {
        return NULL;
    }
    
    memset(font, 0, sizeof(*font));
    font->id = graphics_subsystem.font_count + 1;
    strncpy(font->name, name, sizeof(font->name) - 1);
    strncpy(font->filename, filename, sizeof(font->filename) - 1);
    font->size = size;
    
    /* Set font metrics based on size */
    font->line_height = size + size / 4; /* 125% of size */
    font->ascent = (size * 3) / 4;       /* 75% of size */
    font->descent = size / 4;             /* 25% of size */
    
    /* Create glyph atlas texture */
    font->atlas_texture = (texture_t*)kalloc(sizeof(texture_t));
    if (font->atlas_texture) {
        font->atlas_texture->id = font->id + 10000; /* Offset to avoid conflicts */
        font->atlas_texture->width = 512;  /* 512x512 atlas */
        font->atlas_texture->height = 512;
        font->atlas_texture->format = PIXEL_FORMAT_RGBA8888;
        font->atlas_texture->type = 0; /* 2D texture */
        font->atlas_texture->mip_levels = 1;
        
        /* Create texture on GPU */
        if (graphics_subsystem.primary_adapter &&
            graphics_subsystem.primary_adapter->create_texture) {
            graphics_subsystem.primary_adapter->create_texture(
                graphics_subsystem.primary_adapter, font->atlas_texture);
        }
    }
    
    /* Pre-cache common ASCII characters */
    font->glyph_count = 95; /* ASCII 32-126 */
    for (int i = 0; i < font->glyph_count; i++) {
        font->glyphs[i].codepoint = 32 + i; /* ASCII range */
        font->glyphs[i].texture_rect = (rect_t){
            (i % 16) * 32, (i / 16) * 32, 32, 32 /* 32x32 glyphs in 16x6 grid */
        };
        font->glyphs[i].bearing_x = 2;
        font->glyphs[i].bearing_y = font->ascent;
        font->glyphs[i].advance = size / 2; /* Monospace-ish */
    }
    
    KLOG_INFO("GFX", "Loaded font '%s' size %u (%u glyphs cached)",
              name, size, font->glyph_count);
    
    return font;
}

/* Display Management */

/* Create display output */
static display_output_t* gfx_create_display(uint8_t interface_type, const char* name) {
    display_output_t* display = (display_output_t*)kalloc(sizeof(display_output_t));
    if (!display) {
        return NULL;
    }
    
    memset(display, 0, sizeof(*display));
    display->id = graphics_subsystem.display_count + 1;
    display->interface_type = interface_type;
    strncpy(display->name, name, sizeof(display->name) - 1);
    
    /* Set display properties based on interface type */
    switch (interface_type) {
        case DISPLAY_INTERFACE_HDMI:
            strncpy(display->manufacturer, "LimitlessOS", sizeof(display->manufacturer) - 1);
            strncpy(display->model, "Virtual HDMI Display", sizeof(display->model) - 1);
            display->current_mode = (display_mode_t){
                .width = 1920,
                .height = 1080,
                .refresh_rate = 60,
                .bit_depth = 24,
                .pixel_format = PIXEL_FORMAT_RGB888,
                .interlaced = false
            };
            display->supports_hdcp = true;
            display->supports_hdr = true;
            break;
            
        case DISPLAY_INTERFACE_DP:
            strncpy(display->manufacturer, "LimitlessOS", sizeof(display->manufacturer) - 1);
            strncpy(display->model, "Virtual DisplayPort Monitor", sizeof(display->model) - 1);
            display->current_mode = (display_mode_t){
                .width = 2560,
                .height = 1440,
                .refresh_rate = 144,
                .bit_depth = 24,
                .pixel_format = PIXEL_FORMAT_RGB888,
                .interlaced = false
            };
            display->supports_hdcp = true;
            display->supports_hdr = true;
            display->supports_vrr = true;
            break;
            
        default:
            display->current_mode = (display_mode_t){
                .width = 1024,
                .height = 768,
                .refresh_rate = 60,
                .bit_depth = 24,
                .pixel_format = PIXEL_FORMAT_RGB888,
                .interlaced = false
            };
            break;
    }
    
    /* Calculate physical dimensions (simulate 24" monitor) */
    float diagonal_inches = 24.0f;
    float aspect_ratio = (float)display->current_mode.width / display->current_mode.height;
    display->width_mm = (uint32_t)(diagonal_inches * 25.4f * aspect_ratio / sqrt(aspect_ratio * aspect_ratio + 1));
    display->height_mm = (uint32_t)(diagonal_inches * 25.4f / sqrt(aspect_ratio * aspect_ratio + 1));
    
    /* Calculate DPI */
    display->dpi_x = (float)display->current_mode.width / (display->width_mm / 25.4f);
    display->dpi_y = (float)display->current_mode.height / (display->height_mm / 25.4f);
    
    /* Allocate framebuffer */
    uint32_t bytes_per_pixel = 4; /* RGBA8888 */
    display->framebuffer_size = display->current_mode.width * 
                               display->current_mode.height * bytes_per_pixel;
    display->framebuffer = kalloc((size_t)display->framebuffer_size);
    display->framebuffer_physical = (uint64_t)display->framebuffer; /* Simulated */
    
    display->connected = true;
    display->enabled = true;
    
    return display;
}

/* Compositor Operations */

/* Compose frame */
static status_t compositor_compose_frame(compositor_t* comp) {
    if (!comp) {
        return STATUS_INVALID;
    }
    
    uint64_t frame_start = hal_timer_get_timestamp_ns();
    
    /* Clear composition target */
    /* In real implementation, would clear the render target */
    
    /* Render windows in back-to-front order */
    window_t* window = comp->windows;
    while (window) {
        if (window->visible && window->needs_redraw) {
            /* Render window content */
            if (window->on_paint) {
                window->on_paint(window);
            }
            window->needs_redraw = false;
            window->last_paint = frame_start;
            window->paint_count++;
        }
        window = window->next;
    }
    
    /* Apply composition effects */
    if (comp->blur_enabled) {
        /* Apply blur effect */
    }
    
    if (comp->transparency_enabled) {
        /* Composite with alpha blending */
    }
    
    /* Present to display */
    comp->frames_composed++;
    comp->last_frame_time = frame_start;
    
    /* Calculate FPS */
    static uint64_t last_fps_update = 0;
    static uint32_t frame_counter = 0;
    frame_counter++;
    
    if (frame_start - last_fps_update >= 1000000000ULL) { /* 1 second */
        comp->current_fps = frame_counter;
        graphics_subsystem.current_fps = comp->current_fps;
        if (comp->current_fps > graphics_subsystem.peak_fps) {
            graphics_subsystem.peak_fps = comp->current_fps;
        }
        frame_counter = 0;
        last_fps_update = frame_start;
    }
    
    return STATUS_OK;
}

/* Add window to compositor */
static status_t compositor_add_window(compositor_t* comp, window_t* window) {
    if (!comp || !window) {
        return STATUS_INVALID;
    }
    
    /* Add window to list */
    window->next = comp->windows;
    comp->windows = window;
    comp->window_count++;
    
    /* Set focus if this is the first normal window */
    if (window->type == WINDOW_TYPE_NORMAL && !comp->focused_window) {
        comp->focused_window = window;
        window->focused = true;
    }
    
    KLOG_INFO("GFX", "Added window %u '%s' to compositor (%ux%u)",
              window->id, window->title, window->bounds.width, window->bounds.height);
    
    return STATUS_OK;
}

/* Initialize GPU adapter */
static gpu_adapter_t* gfx_init_gpu_adapter(uint16_t vendor_id, uint16_t device_id, const char* name) {
    gpu_adapter_t* gpu = (gpu_adapter_t*)kalloc(sizeof(gpu_adapter_t));
    if (!gpu) {
        return NULL;
    }
    
    memset(gpu, 0, sizeof(*gpu));
    gpu->id = graphics_subsystem.adapter_count + 1;
    gpu->vendor_id = vendor_id;
    gpu->device_id = device_id;
    strncpy(gpu->name, name, sizeof(gpu->name) - 1);
    strncpy(gpu->driver_version, "1.0.0", sizeof(gpu->driver_version) - 1);
    
    /* Set capabilities based on vendor */
    switch (vendor_id) {
        case GPU_VENDOR_NVIDIA:
            gpu->vram_size = 8ULL * 1024 * 1024 * 1024; /* 8GB VRAM */
            gpu->max_texture_size = 16384;
            gpu->supports_opengl = true;
            gpu->supports_vulkan = true;
            gpu->supports_directx = true;
            gpu->supports_compute = true;
            gpu->supports_tessellation = true;
            gpu->supports_geometry_shader = true;
            gpu->opengl_version_major = 4;
            gpu->opengl_version_minor = 6;
            gpu->vulkan_version = 0x00401000; /* Vulkan 1.1 */
            break;
            
        case GPU_VENDOR_AMD:
            gpu->vram_size = 16ULL * 1024 * 1024 * 1024; /* 16GB VRAM */
            gpu->max_texture_size = 16384;
            gpu->supports_opengl = true;
            gpu->supports_vulkan = true;
            gpu->supports_directx = true;
            gpu->supports_compute = true;
            gpu->supports_tessellation = true;
            gpu->supports_geometry_shader = true;
            gpu->opengl_version_major = 4;
            gpu->opengl_version_minor = 6;
            gpu->vulkan_version = 0x00401000; /* Vulkan 1.1 */
            break;
            
        case GPU_VENDOR_INTEL:
            gpu->vram_size = 2ULL * 1024 * 1024 * 1024; /* 2GB shared memory */
            gpu->max_texture_size = 8192;
            gpu->supports_opengl = true;
            gpu->supports_vulkan = true;
            gpu->supports_directx = true;
            gpu->supports_compute = false;
            gpu->supports_tessellation = false;
            gpu->supports_geometry_shader = true;
            gpu->opengl_version_major = 4;
            gpu->opengl_version_minor = 5;
            gpu->vulkan_version = 0x00400000; /* Vulkan 1.0 */
            break;
            
        default:
            gpu->vram_size = 1ULL * 1024 * 1024 * 1024; /* 1GB */
            gpu->max_texture_size = 4096;
            gpu->supports_opengl = true;
            gpu->opengl_version_major = 3;
            gpu->opengl_version_minor = 3;
            break;
    }
    
    /* Set common capabilities */
    gpu->max_render_targets = 8;
    gpu->max_vertex_attributes = 16;
    gpu->max_shader_uniforms = 1024;
    
    /* Set up function pointers */
    gpu->create_buffer = gpu_create_buffer;
    gpu->create_texture = gpu_create_texture;
    gpu->compile_shader = gpu_compile_shader;
    gpu->draw_primitives = gpu_draw_primitives;
    
    return gpu;
}

/* Initialize compositor */
static compositor_t* gfx_init_compositor(void) {
    compositor_t* comp = (compositor_t*)kalloc(sizeof(compositor_t));
    if (!comp) {
        return NULL;
    }
    
    memset(comp, 0, sizeof(*comp));
    comp->id = 1;
    strncpy(comp->name, "LimitlessOS Compositor", sizeof(comp->name) - 1);
    
    /* Use primary display dimensions */
    if (graphics_subsystem.primary_display) {
        comp->width = graphics_subsystem.primary_display->current_mode.width;
        comp->height = graphics_subsystem.primary_display->current_mode.height;
    } else {
        comp->width = 1920;  /* Default 1080p */
        comp->height = 1080;
    }
    
    /* Create composition render target */
    comp->composition_target = (render_target_t*)kalloc(sizeof(render_target_t));
    if (comp->composition_target) {
        comp->composition_target->id = 1;
        comp->composition_target->width = comp->width;
        comp->composition_target->height = comp->height;
        comp->composition_target->format = PIXEL_FORMAT_RGBA8888;
        comp->composition_target->has_depth = true;
        comp->composition_target->has_stencil = false;
    }
    
    /* Set compositor properties */
    comp->compositing_mode = RENDER_MODE_RETAINED;
    comp->vsync_enabled = true;
    comp->triple_buffering = true;
    comp->blur_enabled = true;
    comp->transparency_enabled = true;
    comp->animation_enabled = true;
    comp->blur_radius = 5.0f;
    comp->target_fps = 60;
    
    /* Set up function pointers */
    comp->compose_frame = compositor_compose_frame;
    comp->add_window = compositor_add_window;
    
    return comp;
}

/* Print graphics statistics */
void graphics_print_stats(void) {
    kprintf("=== Graphics Subsystem Statistics ===\n");
    
    kprintf("\nGPU Adapters:\n");
    kprintf("  Total Adapters: %u\n", graphics_subsystem.adapter_count);
    
    gpu_adapter_t* gpu = graphics_subsystem.adapters;
    while (gpu) {
        const char* vendor_name = "Unknown";
        if ((gpu->vendor_id & 0xFF) < 256) {
            vendor_name = gpu_vendor_names[gpu->vendor_id & 0xFF];
        }
        
        kprintf("    GPU %u: %s (%s)\n", gpu->id, gpu->name, vendor_name);
        kprintf("      VRAM: %llu MB (%llu MB used)\n",
                gpu->vram_size / (1024*1024), gpu->vram_used / (1024*1024));
        kprintf("      Max Texture Size: %u, Max Render Targets: %u\n",
                gpu->max_texture_size, gpu->max_render_targets);
        
        kprintf("      Supported APIs: ");
        if (gpu->supports_opengl) kprintf("OpenGL %u.%u ", gpu->opengl_version_major, gpu->opengl_version_minor);
        if (gpu->supports_vulkan) kprintf("Vulkan %u.%u ", (gpu->vulkan_version >> 22) & 0x3FF, (gpu->vulkan_version >> 12) & 0x3FF);
        if (gpu->supports_directx) kprintf("DirectX ");
        kprintf("\n");
        
        kprintf("      Features: ");
        if (gpu->supports_compute) kprintf("Compute ");
        if (gpu->supports_tessellation) kprintf("Tessellation ");
        if (gpu->supports_geometry_shader) kprintf("GeometryShader ");
        kprintf("\n");
        
        kprintf("      Performance: %llu triangles, %llu draw calls, %u%% GPU util\n",
                gpu->triangles_rendered, gpu->draw_calls, gpu->gpu_utilization);
        
        gpu = gpu->next;
    }
    
    kprintf("\nDisplays:\n");
    kprintf("  Connected Displays: %u\n", graphics_subsystem.display_count);
    
    display_output_t* display = graphics_subsystem.displays;
    while (display) {
        kprintf("    Display %u: %s (%s %s)\n",
                display->id, display->name, display->manufacturer, display->model);
        kprintf("      Resolution: %ux%u @ %u Hz (%s)\n",
                display->current_mode.width, display->current_mode.height,
                display->current_mode.refresh_rate,
                pixel_format_names[display->current_mode.pixel_format < 10 ? display->current_mode.pixel_format : 0]);
        kprintf("      Physical: %ux%u mm (%.1f\" diagonal)\n",
                display->width_mm, display->height_mm,
                sqrt(display->width_mm * display->width_mm + display->height_mm * display->height_mm) / 25.4f);
        kprintf("      DPI: %.1fx%.1f, Color Depth: %u-bit\n",
                display->dpi_x, display->dpi_y, display->current_mode.bit_depth);
        
        kprintf("      Features: ");
        if (display->supports_hdcp) kprintf("HDCP ");
        if (display->supports_hdr) kprintf("HDR ");
        if (display->supports_vrr) kprintf("VRR ");
        kprintf("\n");
        
        kprintf("      Performance: %llu frames, %u FPS\n",
                display->frame_count, display->current_fps);
        
        display = display->next;
    }
    
    if (graphics_subsystem.compositor) {
        compositor_t* comp = graphics_subsystem.compositor;
        kprintf("\nCompositor:\n");
        kprintf("  Name: %s\n", comp->name);
        kprintf("  Resolution: %ux%u\n", comp->width, comp->height);
        kprintf("  Windows: %u (Focused: %u)\n", comp->window_count, 
                comp->focused_window ? comp->focused_window->id : 0);
        kprintf("  Performance: %llu frames composed, %u FPS (target: %u)\n",
                comp->frames_composed, comp->current_fps, comp->target_fps);
        
        kprintf("  Features: ");
        if (comp->vsync_enabled) kprintf("VSync ");
        if (comp->triple_buffering) kprintf("TripleBuffer ");
        if (comp->blur_enabled) kprintf("Blur ");
        if (comp->transparency_enabled) kprintf("Transparency ");
        if (comp->animation_enabled) kprintf("Animation ");
        kprintf("\n");
    }
    
    kprintf("\nWindows:\n");
    kprintf("  Total Windows: %u\n", graphics_subsystem.window_count);
    
    window_t* window = graphics_subsystem.windows;
    int window_count = 0;
    while (window && window_count < 10) { /* Show first 10 windows */
        kprintf("    Window %u: '%s' (%ux%u at %d,%d)\n",
                window->id, window->title,
                window->bounds.width, window->bounds.height,
                window->bounds.x, window->bounds.y);
        kprintf("      State: %s%s%s%s, Opacity: %u, Paints: %u\n",
                window->visible ? "Visible " : "",
                window->focused ? "Focused " : "",
                window->minimized ? "Minimized " : "",
                window->maximized ? "Maximized " : "",
                window->opacity, window->paint_count);
        
        window = window->next;
        window_count++;
    }
    
    kprintf("\nGraphics Resources:\n");
    kprintf("  Buffers: %u\n", graphics_subsystem.buffer_count);
    kprintf("  Textures: %u\n", graphics_subsystem.texture_count);
    kprintf("  Shaders: %u\n", graphics_subsystem.shader_count);
    kprintf("  Fonts: %u\n", graphics_subsystem.font_count);
    
    kprintf("\nMemory Usage:\n");
    kprintf("  Total VRAM Allocated: %llu MB\n", graphics_subsystem.total_vram_allocated / (1024*1024));
    kprintf("  Total System Memory: %llu MB\n", graphics_subsystem.total_system_memory / (1024*1024));
    
    kprintf("\nPerformance:\n");
    kprintf("  Total Triangles Rendered: %llu\n", graphics_subsystem.total_triangles);
    kprintf("  Total Draw Calls: %llu\n", graphics_subsystem.total_draw_calls);
    kprintf("  Current FPS: %u\n", graphics_subsystem.current_fps);
    kprintf("  Peak FPS: %u\n", graphics_subsystem.peak_fps);
    
    kprintf("\nConfiguration:\n");
    kprintf("  Default API: %s\n", api_names[graphics_subsystem.default_api < 5 ? graphics_subsystem.default_api : 0]);
    kprintf("  Hardware Acceleration: %s\n", graphics_subsystem.hardware_acceleration ? "Enabled" : "Disabled");
    kprintf("  Multisampling: %s", graphics_subsystem.multisampling_enabled ? "Enabled" : "Disabled");
    if (graphics_subsystem.multisampling_enabled) {
        kprintf(" (%ux MSAA)", graphics_subsystem.msaa_samples);
    }
    kprintf("\n");
    kprintf("  Anisotropic Filtering: %s\n", graphics_subsystem.anisotropic_filtering ? "Enabled" : "Disabled");
    
    kprintf("=== End Graphics Statistics ===\n");
}

/* Initialize graphics subsystem */
status_t graphics_subsystem_init(void) {
    KLOG_INFO("GFX", "Initializing advanced graphics subsystem");
    
    memset(&graphics_subsystem, 0, sizeof(graphics_subsystem));
    graphics_subsystem.next_window_id = 1;
    graphics_subsystem.default_api = GFX_API_OPENGL;
    graphics_subsystem.hardware_acceleration = true;
    graphics_subsystem.multisampling_enabled = true;
    graphics_subsystem.msaa_samples = 4;
    graphics_subsystem.anisotropic_filtering = true;
    
    /* Initialize GPU adapters */
    gpu_adapter_t* nvidia_gpu = gfx_init_gpu_adapter(GPU_VENDOR_NVIDIA, 0x2080, 
                                                    "NVIDIA GeForce RTX 4080");
    if (nvidia_gpu) {
        nvidia_gpu->next = graphics_subsystem.adapters;
        graphics_subsystem.adapters = nvidia_gpu;
        graphics_subsystem.adapter_count++;
        graphics_subsystem.primary_adapter = nvidia_gpu; /* Set as primary */
        
        KLOG_INFO("GFX", "NVIDIA GPU adapter initialized (%llu MB VRAM)", 
                  nvidia_gpu->vram_size / (1024*1024));
    }
    
    gpu_adapter_t* intel_gpu = gfx_init_gpu_adapter(GPU_VENDOR_INTEL, 0x4680, 
                                                   "Intel Arc A770");
    if (intel_gpu) {
        intel_gpu->next = graphics_subsystem.adapters;
        graphics_subsystem.adapters = intel_gpu;
        graphics_subsystem.adapter_count++;
        
        KLOG_INFO("GFX", "Intel GPU adapter initialized (%llu MB VRAM)", 
                  intel_gpu->vram_size / (1024*1024));
    }
    
    /* Initialize displays */
    display_output_t* hdmi_display = gfx_create_display(DISPLAY_INTERFACE_HDMI, "HDMI-1");
    if (hdmi_display) {
        hdmi_display->primary = true;
        hdmi_display->next = graphics_subsystem.displays;
        graphics_subsystem.displays = hdmi_display;
        graphics_subsystem.display_count++;
        graphics_subsystem.primary_display = hdmi_display;
        
        KLOG_INFO("GFX", "HDMI display initialized (%ux%u @ %u Hz)",
                  hdmi_display->current_mode.width, hdmi_display->current_mode.height,
                  hdmi_display->current_mode.refresh_rate);
    }
    
    display_output_t* dp_display = gfx_create_display(DISPLAY_INTERFACE_DP, "DP-1");
    if (dp_display) {
        dp_display->next = graphics_subsystem.displays;
        graphics_subsystem.displays = dp_display;
        graphics_subsystem.display_count++;
        
        KLOG_INFO("GFX", "DisplayPort display initialized (%ux%u @ %u Hz)",
                  dp_display->current_mode.width, dp_display->current_mode.height,
                  dp_display->current_mode.refresh_rate);
    }
    
    /* Initialize compositor */
    graphics_subsystem.compositor = gfx_init_compositor();
    if (graphics_subsystem.compositor) {
        KLOG_INFO("GFX", "Desktop compositor initialized (%ux%u)",
                  graphics_subsystem.compositor->width, graphics_subsystem.compositor->height);
    }
    
    /* Load default fonts */
    font_t* system_font = gfx_load_font("System", "/fonts/system.ttf", 12);
    if (system_font) {
        system_font->next = graphics_subsystem.fonts;
        graphics_subsystem.fonts = system_font;
        graphics_subsystem.font_count++;
    }
    
    font_t* title_font = gfx_load_font("Title", "/fonts/title.ttf", 16);
    if (title_font) {
        title_font->next = graphics_subsystem.fonts;
        graphics_subsystem.fonts = title_font;
        graphics_subsystem.font_count++;
    }
    
    /* Create desktop window */
    rect_t desktop_bounds = {0, 0, 1920, 1080};
    if (graphics_subsystem.primary_display) {
        desktop_bounds.width = graphics_subsystem.primary_display->current_mode.width;
        desktop_bounds.height = graphics_subsystem.primary_display->current_mode.height;
    }
    
    window_t* desktop = gfx_create_window(WINDOW_TYPE_DESKTOP, "Desktop", desktop_bounds);
    if (desktop) {
        desktop->background_color = (color_t){64, 128, 192, 255}; /* Blue desktop */
        
        if (graphics_subsystem.compositor) {
            graphics_subsystem.compositor->desktop_window = desktop;
            graphics_subsystem.compositor->add_window(graphics_subsystem.compositor, desktop);
        }
        
        desktop->next = graphics_subsystem.windows;
        graphics_subsystem.windows = desktop;
        graphics_subsystem.window_count++;
    }
    
    /* Create some example windows */
    window_t* terminal = gfx_create_window(WINDOW_TYPE_NORMAL, "Terminal", 
                                         (rect_t){100, 100, 800, 600});
    if (terminal) {
        terminal->background_color = (color_t){32, 32, 32, 255}; /* Dark terminal */
        
        if (graphics_subsystem.compositor) {
            graphics_subsystem.compositor->add_window(graphics_subsystem.compositor, terminal);
        }
        
        terminal->next = graphics_subsystem.windows;
        graphics_subsystem.windows = terminal;
        graphics_subsystem.window_count++;
    }
    
    window_t* browser = gfx_create_window(WINDOW_TYPE_NORMAL, "Web Browser",
                                        (rect_t){200, 150, 1200, 800});
    if (browser) {
        if (graphics_subsystem.compositor) {
            graphics_subsystem.compositor->add_window(graphics_subsystem.compositor, browser);
        }
        
        browser->next = graphics_subsystem.windows;
        graphics_subsystem.windows = browser;
        graphics_subsystem.window_count++;
    }
    
    KLOG_INFO("GFX", "Advanced graphics subsystem initialization complete");
    KLOG_INFO("GFX", "  GPU Adapters: %u", graphics_subsystem.adapter_count);
    KLOG_INFO("GFX", "  Displays: %u", graphics_subsystem.display_count);
    KLOG_INFO("GFX", "  Windows: %u", graphics_subsystem.window_count);
    KLOG_INFO("GFX", "  Fonts: %u", graphics_subsystem.font_count);
    
    return STATUS_OK;
}