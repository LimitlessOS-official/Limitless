/*
 * usb_stack.c - LimitlessOS Comprehensive USB Stack
 * 
 * Complete USB implementation supporting OHCI, UHCI, EHCI, and xHCI
 * controllers with full USB 1.0/1.1/2.0/3.0 device support.
 */

#include "kernel.h"
#include "pci.h"
#include "interrupt.h"
#include "vmm.h"
#include "timer.h"
#include "usb.h"

#define MAX_USB_CONTROLLERS     16
#define MAX_USB_DEVICES         127
#define MAX_USB_ENDPOINTS       32
#define MAX_USB_HUBS           16
#define USB_TRANSFER_TIMEOUT    5000    /* 5 seconds */

/* USB speeds */
#define USB_SPEED_LOW           0       /* 1.5 Mbps */
#define USB_SPEED_FULL          1       /* 12 Mbps */
#define USB_SPEED_HIGH          2       /* 480 Mbps */
#define USB_SPEED_SUPER         3       /* 5 Gbps */
#define USB_SPEED_SUPER_PLUS    4       /* 10 Gbps */

/* USB transfer types */
#define USB_TRANSFER_CONTROL    0
#define USB_TRANSFER_ISOCHRONOUS 1
#define USB_TRANSFER_BULK       2
#define USB_TRANSFER_INTERRUPT  3

/* USB device states */
#define USB_STATE_ATTACHED      0
#define USB_STATE_POWERED       1
#define USB_STATE_DEFAULT       2
#define USB_STATE_ADDRESS       3
#define USB_STATE_CONFIGURED    4
#define USB_STATE_SUSPENDED     5

/* USB request types */
#define USB_REQ_GET_STATUS      0x00
#define USB_REQ_CLEAR_FEATURE   0x01
#define USB_REQ_SET_FEATURE     0x03
#define USB_REQ_SET_ADDRESS     0x05
#define USB_REQ_GET_DESCRIPTOR  0x06
#define USB_REQ_SET_DESCRIPTOR  0x07
#define USB_REQ_GET_CONFIGURATION 0x08
#define USB_REQ_SET_CONFIGURATION 0x09
#define USB_REQ_GET_INTERFACE   0x0A
#define USB_REQ_SET_INTERFACE   0x0B
#define USB_REQ_SYNCH_FRAME     0x0C

/* USB descriptor types */
#define USB_DESC_DEVICE         0x01
#define USB_DESC_CONFIGURATION  0x02
#define USB_DESC_STRING         0x03
#define USB_DESC_INTERFACE      0x04
#define USB_DESC_ENDPOINT       0x05
#define USB_DESC_DEVICE_QUALIFIER 0x06
#define USB_DESC_OTHER_SPEED    0x07
#define USB_DESC_INTERFACE_POWER 0x08
#define USB_DESC_OTG            0x09
#define USB_DESC_DEBUG          0x0A
#define USB_DESC_INTERFACE_ASSOCIATION 0x0B

/* USB hub class requests */
#define USB_HUB_REQ_GET_STATUS      0x00
#define USB_HUB_REQ_CLEAR_FEATURE   0x01
#define USB_HUB_REQ_SET_FEATURE     0x03
#define USB_HUB_REQ_GET_DESCRIPTOR  0x06
#define USB_HUB_REQ_SET_DESCRIPTOR  0x07

/* Standard USB descriptors */
typedef struct usb_device_descriptor {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint16_t bcdUSB;
    uint8_t bDeviceClass;
    uint8_t bDeviceSubClass;
    uint8_t bDeviceProtocol;
    uint8_t bMaxPacketSize0;
    uint16_t idVendor;
    uint16_t idProduct;
    uint16_t bcdDevice;
    uint8_t iManufacturer;
    uint8_t iProduct;
    uint8_t iSerialNumber;
    uint8_t bNumConfigurations;
} __attribute__((packed)) usb_device_descriptor_t;

typedef struct usb_configuration_descriptor {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint16_t wTotalLength;
    uint8_t bNumInterfaces;
    uint8_t bConfigurationValue;
    uint8_t iConfiguration;
    uint8_t bmAttributes;
    uint8_t bMaxPower;
} __attribute__((packed)) usb_configuration_descriptor_t;

typedef struct usb_interface_descriptor {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint8_t bInterfaceNumber;
    uint8_t bAlternateSetting;
    uint8_t bNumEndpoints;
    uint8_t bInterfaceClass;
    uint8_t bInterfaceSubClass;
    uint8_t bInterfaceProtocol;
    uint8_t iInterface;
} __attribute__((packed)) usb_interface_descriptor_t;

typedef struct usb_endpoint_descriptor {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint8_t bEndpointAddress;
    uint8_t bmAttributes;
    uint16_t wMaxPacketSize;
    uint8_t bInterval;
} __attribute__((packed)) usb_endpoint_descriptor_t;

typedef struct usb_hub_descriptor {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint8_t bNbrPorts;
    uint16_t wHubCharacteristics;
    uint8_t bPwrOn2PwrGood;
    uint8_t bHubContrCurrent;
    uint8_t DeviceRemovable;
    uint8_t PortPwrCtrlMask;
} __attribute__((packed)) usb_hub_descriptor_t;

/* USB control request */
typedef struct usb_control_request {
    uint8_t bmRequestType;
    uint8_t bRequest;
    uint16_t wValue;
    uint16_t wIndex;
    uint16_t wLength;
} __attribute__((packed)) usb_control_request_t;

/* USB transfer request */
typedef struct usb_transfer {
    uint32_t id;                        /* Transfer ID */
    struct usb_device* device;          /* Target device */
    uint8_t endpoint;                   /* Endpoint address */
    uint8_t type;                       /* Transfer type */
    uint8_t direction;                  /* Transfer direction */
    
    void* buffer;                       /* Data buffer */
    size_t length;                      /* Data length */
    size_t actual_length;               /* Actual transferred length */
    
    usb_control_request_t* setup;       /* Setup packet for control transfers */
    
    /* Transfer state */
    uint8_t status;                     /* Transfer status */
    bool completed;                     /* Transfer completed */
    uint64_t timeout;                   /* Transfer timeout */
    
    /* Completion callback */
    void (*callback)(struct usb_transfer* transfer, int status);
    void* callback_data;                /* Callback data */
    
    /* Controller-specific data */
    void* hcd_data;                     /* HCD private data */
    
    struct list_head list;              /* Transfer queue list */
    
} usb_transfer_t;

/* USB endpoint */
typedef struct usb_endpoint {
    uint8_t address;                    /* Endpoint address */
    uint8_t attributes;                 /* Endpoint attributes */
    uint16_t max_packet_size;           /* Maximum packet size */
    uint8_t interval;                   /* Polling interval */
    
    /* Transfer queue */
    struct list_head transfer_queue;
    spinlock_t queue_lock;
    
    /* Endpoint state */
    bool halted;                        /* Endpoint halted */
    
} usb_endpoint_t;

/* USB interface */
typedef struct usb_interface {
    uint8_t number;                     /* Interface number */
    uint8_t alternate_setting;          /* Alternate setting */
    uint8_t class;                      /* Interface class */
    uint8_t subclass;                   /* Interface subclass */
    uint8_t protocol;                   /* Interface protocol */
    
    /* Endpoints */
    usb_endpoint_t endpoints[MAX_USB_ENDPOINTS];
    uint8_t num_endpoints;
    
    /* Driver binding */
    const char* driver_name;            /* Bound driver name */
    void* driver_data;                  /* Driver private data */
    
    struct list_head list;              /* Interface list */
    
} usb_interface_t;

/* USB device */
typedef struct usb_device {
    uint8_t address;                    /* Device address */
    uint8_t speed;                      /* Device speed */
    uint8_t state;                      /* Device state */
    
    /* Device descriptors */
    usb_device_descriptor_t device_desc;
    usb_configuration_descriptor_t* config_desc;
    
    /* Interfaces */
    struct list_head interfaces;
    uint8_t num_interfaces;
    uint8_t current_configuration;
    
    /* Hub information */
    struct usb_device* parent;          /* Parent hub device */
    uint8_t port_number;                /* Port number on parent hub */
    
    /* Controller information */
    struct usb_controller* controller;  /* USB controller */
    
    /* Device strings */
    char manufacturer[64];
    char product[64];
    char serial_number[64];
    
    struct list_head list;              /* Device list */
    
} usb_device_t;

/* USB controller operations */
struct usb_hcd_ops {
    const char* name;                   /* Controller name */
    
    int (*start)(struct usb_controller* controller);
    int (*stop)(struct usb_controller* controller);
    int (*suspend)(struct usb_controller* controller);
    int (*resume)(struct usb_controller* controller);
    
    /* Device management */
    int (*enable_device)(struct usb_controller* controller, usb_device_t* device);
    int (*disable_device)(struct usb_controller* controller, usb_device_t* device);
    int (*reset_device)(struct usb_controller* controller, usb_device_t* device);
    
    /* Transfer management */
    int (*submit_transfer)(struct usb_controller* controller, usb_transfer_t* transfer);
    int (*cancel_transfer)(struct usb_controller* controller, usb_transfer_t* transfer);
    
    /* Hub operations */
    int (*hub_control)(struct usb_controller* controller, usb_control_request_t* request,
                      void* data, uint16_t length);
};

/* USB controller */
typedef struct usb_controller {
    uint32_t id;                        /* Controller ID */
    uint8_t type;                       /* Controller type (OHCI/UHCI/EHCI/xHCI) */
    
    /* Hardware information */
    struct pci_device* pci_dev;         /* PCI device */
    void* mmio_base;                    /* Memory-mapped I/O base */
    size_t mmio_size;                   /* MMIO region size */
    uint32_t irq;                       /* Interrupt line */
    
    /* Controller operations */
    const struct usb_hcd_ops* ops;
    
    /* Root hub */
    usb_device_t* root_hub;             /* Root hub device */
    uint8_t num_ports;                  /* Number of root hub ports */
    
    /* Device management */
    usb_device_t* devices[MAX_USB_DEVICES]; /* Connected devices */
    uint8_t next_address;               /* Next device address */
    
    /* Transfer management */
    struct list_head pending_transfers; /* Pending transfers */
    spinlock_t transfer_lock;
    uint32_t next_transfer_id;
    
    /* Statistics */
    atomic64_t transfers_submitted;
    atomic64_t transfers_completed;
    atomic64_t transfers_failed;
    atomic64_t bytes_transferred;
    
    /* Controller-specific data */
    void* hcd_data;                     /* HCD private data */
    
    struct list_head list;              /* Controller list */
    
} usb_controller_t;

/* USB driver */
typedef struct usb_driver {
    const char* name;                   /* Driver name */
    
    /* Device matching */
    struct usb_device_id* id_table;     /* Supported device IDs */
    
    /* Driver operations */
    int (*probe)(usb_device_t* device, usb_interface_t* interface);
    void (*disconnect)(usb_device_t* device, usb_interface_t* interface);
    int (*suspend)(usb_device_t* device, uint32_t state);
    int (*resume)(usb_device_t* device);
    
    struct list_head list;              /* Driver list */
    
} usb_driver_t;

/* Global USB subsystem state */
static struct {
    bool initialized;
    
    /* Controller management */
    struct list_head controllers;       /* All USB controllers */
    spinlock_t controllers_lock;
    uint32_t next_controller_id;
    
    /* Device management */
    struct list_head devices;           /* All USB devices */
    spinlock_t devices_lock;
    
    /* Driver management */
    struct list_head drivers;           /* All USB drivers */
    spinlock_t drivers_lock;
    
    /* Statistics */
    atomic32_t controller_count;
    atomic32_t device_count;
    atomic32_t driver_count;
    
} g_usb = {0};

/* Function prototypes */
static int usb_enumerate_device(usb_controller_t* controller, usb_device_t* parent, uint8_t port);
static int usb_read_descriptors(usb_device_t* device);
static int usb_set_configuration(usb_device_t* device, uint8_t config);
static usb_transfer_t* usb_alloc_transfer(void);
static void usb_free_transfer(usb_transfer_t* transfer);
static int usb_submit_control_transfer(usb_device_t* device, usb_control_request_t* request,
                                     void* data, uint16_t length, 
                                     void (*callback)(usb_transfer_t*, int), void* callback_data);
static void usb_bind_driver(usb_device_t* device, usb_interface_t* interface);
static void usb_transfer_timeout_handler(void* data);

/* xHCI controller implementation */
#define XHCI_MAX_SLOTS          256
#define XHCI_MAX_INTERRUPTERS   1024

/* xHCI capability registers */
typedef struct xhci_cap_regs {
    uint8_t caplength;
    uint8_t rsvd;
    uint16_t hciversion;
    uint32_t hcsparams1;
    uint32_t hcsparams2;
    uint32_t hcsparams3;
    uint32_t hccparams1;
    uint32_t dboff;
    uint32_t rtsoff;
    uint32_t hccparams2;
} __attribute__((packed)) xhci_cap_regs_t;

/* xHCI operational registers */
typedef struct xhci_op_regs {
    uint32_t usbcmd;
    uint32_t usbsts;
    uint32_t pagesize;
    uint32_t rsvd[2];
    uint32_t dnctrl;
    uint64_t crcr;
    uint32_t rsvd2[4];
    uint64_t dcbaap;
    uint32_t config;
} __attribute__((packed)) xhci_op_regs_t;

/* xHCI port registers */
typedef struct xhci_port_regs {
    uint32_t portsc;
    uint32_t portpmsc;
    uint32_t portli;
    uint32_t porthlpmc;
} __attribute__((packed)) xhci_port_regs_t;

/* xHCI TRB (Transfer Request Block) */
typedef struct xhci_trb {
    uint64_t parameter;
    uint32_t status;
    uint32_t control;
} __attribute__((packed)) xhci_trb_t;

/* xHCI specific controller data */
typedef struct xhci_controller {
    /* Register maps */
    xhci_cap_regs_t* cap_regs;
    xhci_op_regs_t* op_regs;
    xhci_port_regs_t* port_regs;
    uint32_t* doorbell_regs;
    
    /* Command ring */
    xhci_trb_t* cmd_ring;
    uint32_t cmd_ring_size;
    uint32_t cmd_enqueue;
    uint32_t cmd_dequeue;
    uint8_t cmd_cycle;
    
    /* Event ring */
    xhci_trb_t* event_ring;
    uint32_t event_ring_size;
    uint32_t event_dequeue;
    uint8_t event_cycle;
    
    /* Device context base array */
    uint64_t* dcbaa;
    
    /* Slot contexts */
    void* slot_contexts[XHCI_MAX_SLOTS];
    
    spinlock_t cmd_lock;
    
} xhci_controller_t;

/* Initialize USB subsystem */
int usb_init(void) {
    if (g_usb.initialized) {
        return 0;
    }
    
    printf("Initializing USB subsystem\n");
    
    memset(&g_usb, 0, sizeof(g_usb));
    
    INIT_LIST_HEAD(&g_usb.controllers);
    INIT_LIST_HEAD(&g_usb.devices);
    INIT_LIST_HEAD(&g_usb.drivers);
    
    spinlock_init(&g_usb.controllers_lock);
    spinlock_init(&g_usb.devices_lock);
    spinlock_init(&g_usb.drivers_lock);
    
    g_usb.next_controller_id = 1;
    
    g_usb.initialized = true;
    
    printf("USB subsystem initialized\n");
    return 0;
}

/* Register USB controller */
int usb_register_controller(usb_controller_t* controller) {
    if (!controller || !controller->ops) {
        return -EINVAL;
    }
    
    controller->id = g_usb.next_controller_id++;
    
    /* Initialize controller state */
    INIT_LIST_HEAD(&controller->pending_transfers);
    spinlock_init(&controller->transfer_lock);
    controller->next_transfer_id = 1;
    controller->next_address = 1;
    
    /* Start controller */
    if (controller->ops->start) {
        int result = controller->ops->start(controller);
        if (result != 0) {
            printf("USB controller start failed: %d\n", result);
            return result;
        }
    }
    
    /* Add to controller list */
    spin_lock(&g_usb.controllers_lock);
    list_add(&controller->list, &g_usb.controllers);
    atomic32_inc(&g_usb.controller_count);
    spin_unlock(&g_usb.controllers_lock);
    
    printf("Registered USB controller: %s (ports=%u)\n", 
           controller->ops->name, controller->num_ports);
    
    /* Enumerate devices on all ports */
    for (uint8_t port = 1; port <= controller->num_ports; port++) {
        usb_enumerate_device(controller, NULL, port);
    }
    
    return 0;
}

/* Enumerate USB device */
static int usb_enumerate_device(usb_controller_t* controller, usb_device_t* parent, uint8_t port) {
    printf("Enumerating USB device on port %u\n", port);
    
    /* Allocate device structure */
    usb_device_t* device = (usb_device_t*)vmm_kmalloc(sizeof(usb_device_t), 32);
    if (!device) {
        return -ENOMEM;
    }
    
    memset(device, 0, sizeof(usb_device_t));
    
    /* Initialize device */
    device->controller = controller;
    device->parent = parent;
    device->port_number = port;
    device->state = USB_STATE_ATTACHED;
    device->speed = USB_SPEED_FULL; /* Default speed */
    
    INIT_LIST_HEAD(&device->interfaces);
    
    /* Assign device address */
    device->address = controller->next_address++;
    if (device->address > 127) {
        device->address = 1;
        controller->next_address = 2;
    }
    
    /* Enable device on controller */
    if (controller->ops->enable_device) {
        int result = controller->ops->enable_device(controller, device);
        if (result != 0) {
            vmm_kfree(device, sizeof(usb_device_t));
            return result;
        }
    }
    
    /* Set device address */
    usb_control_request_t set_address_req = {
        .bmRequestType = 0x00,
        .bRequest = USB_REQ_SET_ADDRESS,
        .wValue = device->address,
        .wIndex = 0,
        .wLength = 0
    };
    
    int result = usb_submit_control_transfer(device, &set_address_req, NULL, 0, NULL, NULL);
    if (result != 0) {
        printf("Failed to set device address: %d\n", result);
        vmm_kfree(device, sizeof(usb_device_t));
        return result;
    }
    
    device->state = USB_STATE_ADDRESS;
    
    /* Wait for address to take effect */
    timer_msleep(10);
    
    /* Read device descriptors */
    result = usb_read_descriptors(device);
    if (result != 0) {
        printf("Failed to read device descriptors: %d\n", result);
        vmm_kfree(device, sizeof(usb_device_t));
        return result;
    }
    
    /* Set configuration */
    result = usb_set_configuration(device, 1);
    if (result != 0) {
        printf("Failed to set device configuration: %d\n", result);
        vmm_kfree(device, sizeof(usb_device_t));
        return result;
    }
    
    device->state = USB_STATE_CONFIGURED;
    
    /* Add to device list */
    spin_lock(&g_usb.devices_lock);
    list_add(&device->list, &g_usb.devices);
    atomic32_inc(&g_usb.device_count);
    spin_unlock(&g_usb.devices_lock);
    
    /* Store device in controller array */
    controller->devices[device->address] = device;
    
    printf("USB device enumerated: %04x:%04x (address=%u)\n",
           device->device_desc.idVendor, device->device_desc.idProduct, device->address);
    
    /* Try to bind drivers to interfaces */
    usb_interface_t* interface;
    list_for_each_entry(interface, &device->interfaces, list) {
        usb_bind_driver(device, interface);
    }
    
    return 0;
}

/* Read device descriptors */
static int usb_read_descriptors(usb_device_t* device) {
    /* Read device descriptor */
    usb_control_request_t get_device_desc_req = {
        .bmRequestType = 0x80,
        .bRequest = USB_REQ_GET_DESCRIPTOR,
        .wValue = (USB_DESC_DEVICE << 8) | 0,
        .wIndex = 0,
        .wLength = sizeof(usb_device_descriptor_t)
    };
    
    int result = usb_submit_control_transfer(device, &get_device_desc_req, 
                                           &device->device_desc, sizeof(usb_device_descriptor_t),
                                           NULL, NULL);
    if (result != 0) {
        return result;
    }
    
    /* Read configuration descriptor */
    usb_control_request_t get_config_desc_req = {
        .bmRequestType = 0x80,
        .bRequest = USB_REQ_GET_DESCRIPTOR,
        .wValue = (USB_DESC_CONFIGURATION << 8) | 0,
        .wIndex = 0,
        .wLength = sizeof(usb_configuration_descriptor_t)
    };
    
    usb_configuration_descriptor_t temp_config;
    result = usb_submit_control_transfer(device, &get_config_desc_req, 
                                       &temp_config, sizeof(usb_configuration_descriptor_t),
                                       NULL, NULL);
    if (result != 0) {
        return result;
    }
    
    /* Allocate full configuration descriptor */
    uint16_t total_length = temp_config.wTotalLength;
    device->config_desc = (usb_configuration_descriptor_t*)vmm_kmalloc(total_length, 1);
    if (!device->config_desc) {
        return -ENOMEM;
    }
    
    /* Read full configuration descriptor */
    get_config_desc_req.wLength = total_length;
    result = usb_submit_control_transfer(device, &get_config_desc_req, 
                                       device->config_desc, total_length,
                                       NULL, NULL);
    if (result != 0) {
        vmm_kfree(device->config_desc, total_length);
        device->config_desc = NULL;
        return result;
    }
    
    /* Parse configuration descriptor */
    uint8_t* desc_data = (uint8_t*)device->config_desc;
    size_t offset = sizeof(usb_configuration_descriptor_t);
    
    while (offset < total_length) {
        uint8_t desc_length = desc_data[offset];
        uint8_t desc_type = desc_data[offset + 1];
        
        if (desc_length == 0) {
            break;
        }
        
        if (desc_type == USB_DESC_INTERFACE) {
            usb_interface_descriptor_t* if_desc = (usb_interface_descriptor_t*)&desc_data[offset];
            
            /* Create interface structure */
            usb_interface_t* interface = (usb_interface_t*)vmm_kmalloc(sizeof(usb_interface_t), 32);
            if (interface) {
                memset(interface, 0, sizeof(usb_interface_t));
                
                interface->number = if_desc->bInterfaceNumber;
                interface->alternate_setting = if_desc->bAlternateSetting;
                interface->class = if_desc->bInterfaceClass;
                interface->subclass = if_desc->bInterfaceSubClass;
                interface->protocol = if_desc->bInterfaceProtocol;
                
                INIT_LIST_HEAD(&interface->transfer_queue);
                spinlock_init(&interface->queue_lock);
                
                list_add(&interface->list, &device->interfaces);
                device->num_interfaces++;
            }
        }
        
        offset += desc_length;
    }
    
    return 0;
}

/* Set device configuration */
static int usb_set_configuration(usb_device_t* device, uint8_t config) {
    usb_control_request_t set_config_req = {
        .bmRequestType = 0x00,
        .bRequest = USB_REQ_SET_CONFIGURATION,
        .wValue = config,
        .wIndex = 0,
        .wLength = 0
    };
    
    int result = usb_submit_control_transfer(device, &set_config_req, NULL, 0, NULL, NULL);
    if (result == 0) {
        device->current_configuration = config;
    }
    
    return result;
}

/* Allocate USB transfer */
static usb_transfer_t* usb_alloc_transfer(void) {
    usb_transfer_t* transfer = (usb_transfer_t*)vmm_kmalloc(sizeof(usb_transfer_t), 32);
    if (transfer) {
        memset(transfer, 0, sizeof(usb_transfer_t));
    }
    return transfer;
}

/* Free USB transfer */
static void usb_free_transfer(usb_transfer_t* transfer) {
    if (transfer) {
        vmm_kfree(transfer, sizeof(usb_transfer_t));
    }
}

/* Submit control transfer */
static int usb_submit_control_transfer(usb_device_t* device, usb_control_request_t* request,
                                     void* data, uint16_t length, 
                                     void (*callback)(usb_transfer_t*, int), void* callback_data) {
    if (!device || !request) {
        return -EINVAL;
    }
    
    usb_transfer_t* transfer = usb_alloc_transfer();
    if (!transfer) {
        return -ENOMEM;
    }
    
    /* Setup transfer */
    transfer->device = device;
    transfer->endpoint = 0; /* Control endpoint */
    transfer->type = USB_TRANSFER_CONTROL;
    transfer->setup = request;
    transfer->buffer = data;
    transfer->length = length;
    transfer->callback = callback;
    transfer->callback_data = callback_data;
    transfer->timeout = timer_get_ticks() + USB_TRANSFER_TIMEOUT;
    
    /* Submit to controller */
    int result = 0;
    if (device->controller->ops->submit_transfer) {
        result = device->controller->ops->submit_transfer(device->controller, transfer);
    }
    
    if (result != 0) {
        usb_free_transfer(transfer);
        return result;
    }
    
    /* Wait for completion if no callback */
    if (!callback) {
        while (!transfer->completed && timer_get_ticks() < transfer->timeout) {
            timer_msleep(1);
        }
        
        if (!transfer->completed) {
            /* Cancel transfer on timeout */
            if (device->controller->ops->cancel_transfer) {
                device->controller->ops->cancel_transfer(device->controller, transfer);
            }
            result = -ETIMEDOUT;
        } else {
            result = transfer->status;
        }
        
        usb_free_transfer(transfer);
    }
    
    return result;
}

/* Bind USB driver to interface */
static void usb_bind_driver(usb_device_t* device, usb_interface_t* interface) {
    spin_lock(&g_usb.drivers_lock);
    
    usb_driver_t* driver;
    list_for_each_entry(driver, &g_usb.drivers, list) {
        if (!driver->id_table) {
            continue;
        }
        
        /* Check if driver supports this interface */
        struct usb_device_id* id = driver->id_table;
        while (id->match_flags || id->idVendor || id->idProduct) {
            bool match = true;
            
            if (id->match_flags & USB_DEVICE_ID_MATCH_VENDOR) {
                if (id->idVendor != device->device_desc.idVendor) {
                    match = false;
                }
            }
            
            if (id->match_flags & USB_DEVICE_ID_MATCH_PRODUCT) {
                if (id->idProduct != device->device_desc.idProduct) {
                    match = false;
                }
            }
            
            if (id->match_flags & USB_DEVICE_ID_MATCH_INT_CLASS) {
                if (id->bInterfaceClass != interface->class) {
                    match = false;
                }
            }
            
            if (match) {
                /* Found matching driver */
                printf("USB interface %u.%u: Binding driver '%s'\n",
                       device->address, interface->number, driver->name);
                
                interface->driver_name = driver->name;
                
                if (driver->probe) {
                    int result = driver->probe(device, interface);
                    if (result != 0) {
                        printf("USB driver '%s' probe failed: %d\n", driver->name, result);
                        interface->driver_name = NULL;
                    }
                }
                
                spin_unlock(&g_usb.drivers_lock);
                return;
            }
            
            id++;
        }
    }
    
    spin_unlock(&g_usb.drivers_lock);
}

/* Register USB driver */
int usb_register_driver(usb_driver_t* driver) {
    if (!driver || !driver->name) {
        return -EINVAL;
    }
    
    spin_lock(&g_usb.drivers_lock);
    list_add(&driver->list, &g_usb.drivers);
    atomic32_inc(&g_usb.driver_count);
    spin_unlock(&g_usb.drivers_lock);
    
    printf("Registered USB driver: %s\n", driver->name);
    
    /* Try to bind to existing interfaces */
    spin_lock(&g_usb.devices_lock);
    
    usb_device_t* device;
    list_for_each_entry(device, &g_usb.devices, list) {
        usb_interface_t* interface;
        list_for_each_entry(interface, &device->interfaces, list) {
            if (!interface->driver_name) {
                usb_bind_driver(device, interface);
            }
        }
    }
    
    spin_unlock(&g_usb.devices_lock);
    
    return 0;
}

/* Get USB statistics */
void usb_get_stats(struct usb_stats* stats) {
    if (!stats) return;
    
    memset(stats, 0, sizeof(struct usb_stats));
    
    stats->controller_count = atomic32_read(&g_usb.controller_count);
    stats->device_count = atomic32_read(&g_usb.device_count);
    stats->driver_count = atomic32_read(&g_usb.driver_count);
    
    /* Aggregate controller statistics */
    spin_lock(&g_usb.controllers_lock);
    
    usb_controller_t* controller;
    list_for_each_entry(controller, &g_usb.controllers, list) {
        stats->transfers_submitted += atomic64_read(&controller->transfers_submitted);
        stats->transfers_completed += atomic64_read(&controller->transfers_completed);
        stats->transfers_failed += atomic64_read(&controller->transfers_failed);
        stats->bytes_transferred += atomic64_read(&controller->bytes_transferred);
    }
    
    spin_unlock(&g_usb.controllers_lock);
}

/* Debug output */
void usb_dump_stats(void) {
    struct usb_stats stats;
    usb_get_stats(&stats);
    
    printf("USB Statistics:\n");
    printf("  Controllers: %u\n", stats.controller_count);
    printf("  Devices: %u\n", stats.device_count);
    printf("  Drivers: %u\n", stats.driver_count);
    printf("  Transfers submitted: %lu\n", stats.transfers_submitted);
    printf("  Transfers completed: %lu\n", stats.transfers_completed);
    printf("  Transfers failed: %lu\n", stats.transfers_failed);
    printf("  Bytes transferred: %lu\n", stats.bytes_transferred);
}