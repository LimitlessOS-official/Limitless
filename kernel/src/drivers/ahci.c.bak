/*
 * AHCI (Advanced Host Controller Interface) SATA Driver
 * Supports SATA 3.0 with NCQ (Native Command Queuing)
 */

#include "kernel.h"
#include "pci.h"
#include "storage.h"
#include "vmm.h"
#include "string.h"
#include "timer.h"

/* AHCI Register Offsets */
#define AHCI_CAP        0x00  /* Host Controller Capabilities */
#define AHCI_GHC        0x04  /* Global Host Control */
#define AHCI_IS         0x08  /* Interrupt Status */
#define AHCI_PI         0x0C  /* Port Implemented */
#define AHCI_VS         0x10  /* AHCI Version */
#define AHCI_CCC_CTL    0x14  /* Command Completion Coalescing Control */
#define AHCI_CCC_PORTS  0x18  /* Command Completion Coalescing Ports */
#define AHCI_EM_LOC     0x1C  /* Enclosure Management Location */
#define AHCI_EM_CTL     0x20  /* Enclosure Management Control */
#define AHCI_CAP2       0x24  /* Host Controller Capabilities Extended */
#define AHCI_BOHC       0x28  /* BIOS/OS Handoff Control and Status */

/* Per-Port Registers (offset 0x100 + port * 0x80) */
#define AHCI_PORT_CLB   0x00  /* Command List Base Address */
#define AHCI_PORT_CLBU  0x04  /* Command List Base Address Upper 32-bits */
#define AHCI_PORT_FB    0x08  /* FIS Base Address */
#define AHCI_PORT_FBU   0x0C  /* FIS Base Address Upper 32-bits */
#define AHCI_PORT_IS    0x10  /* Interrupt Status */
#define AHCI_PORT_IE    0x14  /* Interrupt Enable */
#define AHCI_PORT_CMD   0x18  /* Command and Status */
#define AHCI_PORT_TFD   0x20  /* Task File Data */
#define AHCI_PORT_SIG   0x24  /* Signature */
#define AHCI_PORT_SSTS  0x28  /* SATA Status */
#define AHCI_PORT_SCTL  0x2C  /* SATA Control */
#define AHCI_PORT_SERR  0x30  /* SATA Error */
#define AHCI_PORT_SACT  0x34  /* SATA Active */
#define AHCI_PORT_CI    0x38  /* Command Issue */
#define AHCI_PORT_SNTF  0x3C  /* SATA Notification */

/* AHCI Constants */
#define AHCI_MAX_CONTROLLERS 8
#define AHCI_MAX_PORTS       32
#define AHCI_CMD_SLOTS       32
#define AHCI_FIS_SIZE        256
#define AHCI_CMD_LIST_SIZE   1024

/* FIS Types */
#define FIS_TYPE_REG_H2D     0x27  /* Register FIS - host to device */
#define FIS_TYPE_REG_D2H     0x34  /* Register FIS - device to host */
#define FIS_TYPE_DMA_ACT     0x39  /* DMA activate FIS - device to host */
#define FIS_TYPE_DMA_SETUP   0x41  /* DMA setup FIS - bidirectional */
#define FIS_TYPE_DATA        0x46  /* Data FIS - bidirectional */
#define FIS_TYPE_BIST        0x58  /* BIST activate FIS - bidirectional */
#define FIS_TYPE_PIO_SETUP   0x5F  /* PIO setup FIS - device to host */
#define FIS_TYPE_DEV_BITS    0xA1  /* Set device bits FIS - device to host */

/* ATA Commands */
#define ATA_CMD_READ_DMA_EXT     0x25
#define ATA_CMD_WRITE_DMA_EXT    0x35
#define ATA_CMD_IDENTIFY         0xEC
#define ATA_CMD_FLUSH_CACHE      0xE7

/* AHCI Command Header */
typedef struct {
    uint8_t  cfl:5;      /* Command FIS length in DWORDS, 2 ~ 16 */
    uint8_t  a:1;        /* ATAPI */
    uint8_t  w:1;        /* Write, 1: H2D, 0: D2H */
    uint8_t  p:1;        /* Prefetchable */
    uint8_t  r:1;        /* Reset */
    uint8_t  b:1;        /* BIST */
    uint8_t  c:1;        /* Clear busy upon R_OK */
    uint8_t  rsv0:1;     /* Reserved */
    uint8_t  pmp:4;      /* Port multiplier port */
    uint16_t prdtl;      /* Physical region descriptor table length in entries */
    uint32_t prdbc;      /* Physical region descriptor byte count transferred */
    uint32_t ctba;       /* Command table descriptor base address */
    uint32_t ctbau;      /* Command table descriptor base address upper 32 bits */
    uint32_t rsv1[4];    /* Reserved */
} __attribute__((packed)) ahci_cmd_header_t;

/* AHCI Command Table */
typedef struct {
    uint8_t  cfis[64];   /* Command FIS */
    uint8_t  acmd[16];   /* ATAPI command, 12 or 16 bytes */
    uint8_t  rsv[48];    /* Reserved */
    struct {
        uint32_t dba;    /* Data base address */
        uint32_t dbau;   /* Data base address upper 32 bits */
        uint32_t rsv0;   /* Reserved */
        uint32_t dbc:22; /* Byte count, 4M max */
        uint32_t rsv1:9; /* Reserved */
        uint32_t i:1;    /* Interrupt on completion */
    } prdt[65535];       /* Physical region descriptor table entries, 0 ~ 65535 */
} __attribute__((packed)) ahci_cmd_tbl_t;

/* Register FIS â€“ Host to Device */
typedef struct {
    uint8_t  fis_type;   /* FIS_TYPE_REG_H2D */
    uint8_t  pmport:4;   /* Port multiplier */
    uint8_t  rsv0:3;     /* Reserved */
    uint8_t  c:1;        /* 1: Command, 0: Control */
    uint8_t  command;    /* Command register */
    uint8_t  featurel;   /* Feature register, 7:0 */
    uint8_t  lba0;       /* LBA low register, 7:0 */
    uint8_t  lba1;       /* LBA mid register, 15:8 */
    uint8_t  lba2;       /* LBA high register, 23:16 */
    uint8_t  device;     /* Device register */
    uint8_t  lba3;       /* LBA register, 31:24 */
    uint8_t  lba4;       /* LBA register, 39:32 */
    uint8_t  lba5;       /* LBA register, 47:40 */
    uint8_t  featureh;   /* Feature register, 15:8 */
    uint8_t  countl;     /* Count register, 7:0 */
    uint8_t  counth;     /* Count register, 15:8 */
    uint8_t  icc;        /* Isochronous command completion */
    uint8_t  control;    /* Control register */
    uint8_t  rsv1[4];    /* Reserved */
} __attribute__((packed)) fis_reg_h2d_t;

/* AHCI Port Structure */
typedef struct {
    uint32_t port_id;
    bool present;
    bool sata_drive;
    uint32_t sectors;
    uint32_t sector_size;
    void* mmio_base;
    void* cmd_list;      /* Command list base */
    void* fis_base;      /* FIS base */
    void* cmd_tables[AHCI_CMD_SLOTS];
    char model[41];
    char serial[21];
} ahci_port_t;

/* AHCI Controller Structure */
typedef struct {
    pci_device_t pci_dev;
    void* mmio_base;
    uint32_t mmio_size;
    uint32_t ports_implemented;
    uint32_t command_slots;
    uint32_t version;
    ahci_port_t ports[AHCI_MAX_PORTS];
    uint32_t port_count;
    bool initialized;
} ahci_controller_t;

/* Global AHCI state */
static ahci_controller_t g_ahci_controllers[AHCI_MAX_CONTROLLERS];
static uint32_t g_ahci_controller_count = 0;

/* Function declarations */
static status_t ahci_init_controller(ahci_controller_t* ctrl);
static status_t ahci_port_init(ahci_controller_t* ctrl, uint32_t port_id);
static status_t ahci_identify_device(ahci_port_t* port, void* buffer);

/* AHCI register access */
static uint32_t ahci_read32(ahci_controller_t* ctrl, uint32_t offset) {
    return *(volatile uint32_t*)((uint8_t*)ctrl->mmio_base + offset);
}

static void ahci_write32(ahci_controller_t* ctrl, uint32_t offset, uint32_t value) {
    *(volatile uint32_t*)((uint8_t*)ctrl->mmio_base + offset) = value;
}

static uint32_t ahci_port_read32(ahci_port_t* port, uint32_t offset) {
    uint32_t port_offset = 0x100 + (port->port_id * 0x80) + offset;
    return *(volatile uint32_t*)((uint8_t*)port->mmio_base + port_offset);
}

static void ahci_port_write32(ahci_port_t* port, uint32_t offset, uint32_t value) {
    uint32_t port_offset = 0x100 + (port->port_id * 0x80) + offset;
    *(volatile uint32_t*)((uint8_t*)port->mmio_base + port_offset) = value;
}

/* Initialize AHCI port */
static status_t ahci_port_init(ahci_controller_t* ctrl, uint32_t port_id) {
    ahci_port_t* port = &ctrl->ports[port_id];
    port->port_id = port_id;
    port->mmio_base = ctrl->mmio_base;
    port->present = false;
    
    /* Check if port is implemented */
    if (!(ctrl->ports_implemented & (1 << port_id))) {
        return STATUS_OK; /* Port not implemented in hardware */
    }
    
    /* Check SATA status */
    uint32_t ssts = ahci_port_read32(port, AHCI_PORT_SSTS);
    if ((ssts & 0xF) != 3) { /* Not device present and communication established */
        return STATUS_OK;
    }
    
    /* Stop command engine */
    uint32_t cmd = ahci_port_read32(port, AHCI_PORT_CMD);
    cmd &= ~(1 << 0); /* Clear ST (Start) */
    ahci_port_write32(port, AHCI_PORT_CMD, cmd);
    
    /* Wait for command engine to stop */
    uint64_t timeout = timer_get_ticks() + timer_get_freq_hz(); /* 1 second */
    while (timer_get_ticks() < timeout) {
        cmd = ahci_port_read32(port, AHCI_PORT_CMD);
        if (!(cmd & (1 << 15))) break; /* CR (Command List Running) clear */
    }
    
    /* Allocate command list */
    port->cmd_list = vmm_kmalloc(AHCI_CMD_LIST_SIZE, PAGE_SIZE);
    if (!port->cmd_list) {
        return STATUS_NOMEM;
    }
    k_memset(port->cmd_list, 0, AHCI_CMD_LIST_SIZE);
    
    /* Allocate FIS */
    port->fis_base = vmm_kmalloc(AHCI_FIS_SIZE, PAGE_SIZE);
    if (!port->fis_base) {
        vmm_kfree(port->cmd_list, AHCI_CMD_LIST_SIZE);
        return STATUS_NOMEM;
    }
    k_memset(port->fis_base, 0, AHCI_FIS_SIZE);
    
    /* Allocate command tables */
    for (int i = 0; i < AHCI_CMD_SLOTS; i++) {
        port->cmd_tables[i] = vmm_kmalloc(sizeof(ahci_cmd_tbl_t), PAGE_SIZE);
        if (!port->cmd_tables[i]) {
            /* Cleanup on failure */
            for (int j = 0; j < i; j++) {
                vmm_kfree(port->cmd_tables[j], sizeof(ahci_cmd_tbl_t));
            }
            vmm_kfree(port->cmd_list, AHCI_CMD_LIST_SIZE);
            vmm_kfree(port->fis_base, AHCI_FIS_SIZE);
            return STATUS_NOMEM;
        }
        k_memset(port->cmd_tables[i], 0, sizeof(ahci_cmd_tbl_t));
    }
    
    /* Set command list and FIS base addresses */
    uint64_t cmd_list_phys = vmm_virt_to_phys(port->cmd_list);
    uint64_t fis_phys = vmm_virt_to_phys(port->fis_base);
    
    ahci_port_write32(port, AHCI_PORT_CLB, cmd_list_phys & 0xFFFFFFFF);
    ahci_port_write32(port, AHCI_PORT_CLBU, cmd_list_phys >> 32);
    ahci_port_write32(port, AHCI_PORT_FB, fis_phys & 0xFFFFFFFF);
    ahci_port_write32(port, AHCI_PORT_FBU, fis_phys >> 32);
    
    /* Setup command headers */
    ahci_cmd_header_t* cmd_headers = (ahci_cmd_header_t*)port->cmd_list;
    for (int i = 0; i < AHCI_CMD_SLOTS; i++) {
        uint64_t cmd_tbl_phys = vmm_virt_to_phys(port->cmd_tables[i]);
        cmd_headers[i].ctba = cmd_tbl_phys & 0xFFFFFFFF;
        cmd_headers[i].ctbau = cmd_tbl_phys >> 32;
        cmd_headers[i].prdtl = 1; /* One PRDT entry */
    }
    
    /* Enable FIS receive */
    cmd = ahci_port_read32(port, AHCI_PORT_CMD);
    cmd |= (1 << 4); /* Set FRE (FIS Receive Enable) */
    ahci_port_write32(port, AHCI_PORT_CMD, cmd);
    
    /* Start command engine */
    cmd |= (1 << 0); /* Set ST (Start) */
    ahci_port_write32(port, AHCI_PORT_CMD, cmd);
    
    /* Clear error status */
    ahci_port_write32(port, AHCI_PORT_SERR, 0xFFFFFFFF);
    
    port->present = true;
    
    /* Identify device */
    uint8_t* identify_buffer = (uint8_t*)vmm_kmalloc(512, PAGE_SIZE);
    if (identify_buffer && ahci_identify_device(port, identify_buffer) == STATUS_OK) {
        /* Parse identify data */
        uint16_t* id = (uint16_t*)identify_buffer;
        
        /* Get sectors count */
        if (id[83] & (1 << 10)) { /* LBA48 supported */
            port->sectors = *(uint64_t*)(id + 100) & 0xFFFFFFFFFFFF;
        } else {
            port->sectors = *(uint32_t*)(id + 60);
        }
        port->sector_size = 512; /* Standard sector size */
        
        /* Get model and serial */
        for (int i = 0; i < 20; i++) {
            port->model[i * 2] = (id[27 + i] >> 8) & 0xFF;
            port->model[i * 2 + 1] = id[27 + i] & 0xFF;
        }
        port->model[40] = '\0';
        
        for (int i = 0; i < 10; i++) {
            port->serial[i * 2] = (id[10 + i] >> 8) & 0xFF;
            port->serial[i * 2 + 1] = id[10 + i] & 0xFF;
        }
        port->serial[20] = '\0';
        
        /* Trim strings */
        for (int i = 39; i >= 0 && port->model[i] == ' '; i--) port->model[i] = '\0';
        for (int i = 19; i >= 0 && port->serial[i] == ' '; i--) port->serial[i] = '\0';
        
        console_printf("AHCI: Port %u: %s (%s) - %u sectors (%lu MB)\n",
                      port_id, port->model, port->serial, port->sectors,
                      (uint64_t)port->sectors * 512 / (1024 * 1024));
        
        port->sata_drive = true;
        vmm_kfree(identify_buffer, 512);
    }
    
    return STATUS_OK;
}

/* Send IDENTIFY command */
static status_t ahci_identify_device(ahci_port_t* port, void* buffer) {
    /* Find free command slot */
    uint32_t slots = ahci_port_read32(port, AHCI_PORT_SACT) | ahci_port_read32(port, AHCI_PORT_CI);
    int slot = -1;
    for (int i = 0; i < AHCI_CMD_SLOTS; i++) {
        if (!(slots & (1 << i))) {
            slot = i;
            break;
        }
    }
    
    if (slot == -1) {
        return STATUS_BUSY;
    }
    
    /* Setup command header */
    ahci_cmd_header_t* cmd_header = (ahci_cmd_header_t*)port->cmd_list + slot;
    cmd_header->cfl = sizeof(fis_reg_h2d_t) / 4; /* Command FIS size */
    cmd_header->w = 0; /* Read from device */
    cmd_header->prdtl = 1; /* One PRDT entry */
    
    /* Setup command table */
    ahci_cmd_tbl_t* cmd_tbl = (ahci_cmd_tbl_t*)port->cmd_tables[slot];
    k_memset(cmd_tbl, 0, sizeof(ahci_cmd_tbl_t));
    
    /* Setup PRDT */
    uint64_t buffer_phys = vmm_virt_to_phys(buffer);
    cmd_tbl->prdt[0].dba = buffer_phys & 0xFFFFFFFF;
    cmd_tbl->prdt[0].dbau = buffer_phys >> 32;
    cmd_tbl->prdt[0].dbc = 511; /* 512 bytes - 1 */
    
    /* Setup command FIS */
    fis_reg_h2d_t* cmd_fis = (fis_reg_h2d_t*)cmd_tbl->cfis;
    cmd_fis->fis_type = FIS_TYPE_REG_H2D;
    cmd_fis->c = 1; /* Command */
    cmd_fis->command = ATA_CMD_IDENTIFY;
    
    /* Issue command */
    ahci_port_write32(port, AHCI_PORT_CI, 1 << slot);
    
    /* Wait for completion */
    uint64_t timeout = timer_get_ticks() + timer_get_freq_hz(); /* 1 second */
    while (timer_get_ticks() < timeout) {
        if (!(ahci_port_read32(port, AHCI_PORT_CI) & (1 << slot))) {
            break; /* Command completed */
        }
    }
    
    /* Check if command completed successfully */
    if (ahci_port_read32(port, AHCI_PORT_CI) & (1 << slot)) {
        return STATUS_TIMEOUT;
    }
    
    /* Check for errors */
    if (ahci_port_read32(port, AHCI_PORT_IS) & 0x40000000) { /* Task file error */
        return STATUS_ERROR;
    }
    
    return STATUS_OK;
}

/* Initialize AHCI controller */
static status_t ahci_init_controller(ahci_controller_t* ctrl) {
    /* Check AHCI version */
    ctrl->version = ahci_read32(ctrl, AHCI_VS);
    console_printf("AHCI: Controller version %u.%u%u%u\n",
                  (ctrl->version >> 16) & 0xFFFF, (ctrl->version >> 8) & 0xFF,
                  (ctrl->version >> 4) & 0xF, ctrl->version & 0xF);
    
    /* Get capabilities */
    uint32_t cap = ahci_read32(ctrl, AHCI_CAP);
    ctrl->command_slots = ((cap >> 8) & 0x1F) + 1;
    ctrl->ports_implemented = ahci_read32(ctrl, AHCI_PI);
    
    console_printf("AHCI: %u command slots, ports implemented: 0x%x\n",
                  ctrl->command_slots, ctrl->ports_implemented);
    
    /* Enable AHCI mode */
    uint32_t ghc = ahci_read32(ctrl, AHCI_GHC);
    ghc |= (1 << 31); /* Set AE (AHCI Enable) */
    ahci_write32(ctrl, AHCI_GHC, ghc);
    
    /* Initialize ports */
    ctrl->port_count = 0;
    for (int i = 0; i < AHCI_MAX_PORTS; i++) {
        if (ctrl->ports_implemented & (1 << i)) {
            status_t result = ahci_port_init(ctrl, i);
            if (result == STATUS_OK && ctrl->ports[i].present) {
                ctrl->port_count++;
            }
        }
    }
    
    ctrl->initialized = true;
    console_printf("AHCI: Initialized %u ports\n", ctrl->port_count);
    
    return STATUS_OK;
}

/* PCI enumeration callback */
static void ahci_on_pci(const pci_device_t* dev, void* user) {
    (void)user;
    
    /* Check for AHCI controller (class 01h, subclass 06h) */
    if (dev->class_code == 0x01 && dev->subclass == 0x06) {
        if (g_ahci_controller_count >= AHCI_MAX_CONTROLLERS) {
            console_printf("AHCI: Too many controllers, skipping %02x:%02x.%x\n",
                          dev->bus, dev->slot, dev->func);
            return;
        }
        
        console_printf("AHCI: Found controller %02x:%02x.%x vid=%04x did=%04x\n",
                      dev->bus, dev->slot, dev->func, dev->vendor_id, dev->device_id);
        
        ahci_controller_t* ctrl = &g_ahci_controllers[g_ahci_controller_count];
        ctrl->pci_dev = *dev;
        
        /* Map BAR5 (AHCI registers) */
        if (dev->bar[5] == 0) {
            console_printf("AHCI: BAR5 not configured\n");
            return;
        }
        
        uint64_t bar5_addr = dev->bar[5] & ~0x0F; /* Clear flags */
        ctrl->mmio_size = 0x1100; /* Minimum AHCI register space */
        
        /* Map MMIO */
        void* mapped_mmio = vmm_map_mmio(bar5_addr, ctrl->mmio_size);
        if (mapped_mmio) {
            ctrl->mmio_base = mapped_mmio;
        } else {
            /* Fallback to direct mapping */
            ctrl->mmio_base = (void*)bar5_addr;
            console_printf("AHCI: VMM mapping failed, using direct mapping\n");
        }
        
        /* Initialize controller */
        status_t result = ahci_init_controller(ctrl);
        if (result == STATUS_OK) {
            g_ahci_controller_count++;
            console_printf("AHCI: Successfully initialized controller %u\n", g_ahci_controller_count - 1);
        } else {
            console_printf("AHCI: Failed to initialize controller\n");
        }
    }
}

/* Probe for AHCI controllers */
void ahci_probe(void) {
    console_printf("AHCI: Scanning for controllers...\n");
    g_ahci_controller_count = 0;
    k_memset(g_ahci_controllers, 0, sizeof(g_ahci_controllers));
    
    pci_enumerate(ahci_on_pci, NULL);
    
    console_printf("AHCI: Found %u controller(s)\n", g_ahci_controller_count);
}

/* Read sectors from AHCI device */
status_t ahci_read_sectors(uint32_t controller_id, uint32_t port_id, 
                          uint64_t start_lba, uint32_t sector_count, void* buffer) {
    if (controller_id >= g_ahci_controller_count || port_id >= AHCI_MAX_PORTS || !buffer) {
        return STATUS_ERROR;
    }
    
    ahci_controller_t* ctrl = &g_ahci_controllers[controller_id];
    if (!ctrl->initialized || !ctrl->ports[port_id].present) {
        return STATUS_ERROR;
    }
    
    ahci_port_t* port = &ctrl->ports[port_id];
    
    /* Find free command slot */
    uint32_t slots = ahci_port_read32(port, AHCI_PORT_SACT) | ahci_port_read32(port, AHCI_PORT_CI);
    int slot = -1;
    for (int i = 0; i < AHCI_CMD_SLOTS; i++) {
        if (!(slots & (1 << i))) {
            slot = i;
            break;
        }
    }
    
    if (slot == -1) {
        return STATUS_BUSY;
    }
    
    /* Setup command header */
    ahci_cmd_header_t* cmd_header = (ahci_cmd_header_t*)port->cmd_list + slot;
    cmd_header->cfl = sizeof(fis_reg_h2d_t) / 4;
    cmd_header->w = 0; /* Read */
    cmd_header->prdtl = 1;
    
    /* Setup command table */
    ahci_cmd_tbl_t* cmd_tbl = (ahci_cmd_tbl_t*)port->cmd_tables[slot];
    k_memset(cmd_tbl, 0, sizeof(ahci_cmd_tbl_t));
    
    /* Setup PRDT */
    uint64_t buffer_phys = vmm_virt_to_phys(buffer);
    cmd_tbl->prdt[0].dba = buffer_phys & 0xFFFFFFFF;
    cmd_tbl->prdt[0].dbau = buffer_phys >> 32;
    cmd_tbl->prdt[0].dbc = (sector_count * 512) - 1;
    
    /* Setup command FIS */
    fis_reg_h2d_t* cmd_fis = (fis_reg_h2d_t*)cmd_tbl->cfis;
    cmd_fis->fis_type = FIS_TYPE_REG_H2D;
    cmd_fis->c = 1;
    cmd_fis->command = ATA_CMD_READ_DMA_EXT;
    
    /* LBA48 addressing */
    cmd_fis->lba0 = start_lba & 0xFF;
    cmd_fis->lba1 = (start_lba >> 8) & 0xFF;
    cmd_fis->lba2 = (start_lba >> 16) & 0xFF;
    cmd_fis->lba3 = (start_lba >> 24) & 0xFF;
    cmd_fis->lba4 = (start_lba >> 32) & 0xFF;
    cmd_fis->lba5 = (start_lba >> 40) & 0xFF;
    
    cmd_fis->device = 0x40; /* LBA mode */
    cmd_fis->countl = sector_count & 0xFF;
    cmd_fis->counth = (sector_count >> 8) & 0xFF;
    
    /* Issue command */
    ahci_port_write32(port, AHCI_PORT_CI, 1 << slot);
    
    /* Wait for completion */
    uint64_t timeout = timer_get_ticks() + timer_get_freq_hz() * 5; /* 5 seconds */
    while (timer_get_ticks() < timeout) {
        if (!(ahci_port_read32(port, AHCI_PORT_CI) & (1 << slot))) {
            break;
        }
    }
    
    if (ahci_port_read32(port, AHCI_PORT_CI) & (1 << slot)) {
        return STATUS_TIMEOUT;
    }
    
    /* Check for errors */
    if (ahci_port_read32(port, AHCI_PORT_IS) & 0x40000000) {
        return STATUS_ERROR;
    }
    
    return STATUS_OK;
}

/* Write sectors to AHCI device */
status_t ahci_write_sectors(uint32_t controller_id, uint32_t port_id,
                           uint64_t start_lba, uint32_t sector_count, const void* buffer) {
    if (controller_id >= g_ahci_controller_count || port_id >= AHCI_MAX_PORTS || !buffer) {
        return STATUS_ERROR;
    }
    
    ahci_controller_t* ctrl = &g_ahci_controllers[controller_id];
    if (!ctrl->initialized || !ctrl->ports[port_id].present) {
        return STATUS_ERROR;
    }
    
    ahci_port_t* port = &ctrl->ports[port_id];
    
    /* Similar implementation to read, but with write command */
    /* Find free command slot */
    uint32_t slots = ahci_port_read32(port, AHCI_PORT_SACT) | ahci_port_read32(port, AHCI_PORT_CI);
    int slot = -1;
    for (int i = 0; i < AHCI_CMD_SLOTS; i++) {
        if (!(slots & (1 << i))) {
            slot = i;
            break;
        }
    }
    
    if (slot == -1) {
        return STATUS_BUSY;
    }
    
    /* Setup command header */
    ahci_cmd_header_t* cmd_header = (ahci_cmd_header_t*)port->cmd_list + slot;
    cmd_header->cfl = sizeof(fis_reg_h2d_t) / 4;
    cmd_header->w = 1; /* Write */
    cmd_header->prdtl = 1;
    
    /* Setup command table */
    ahci_cmd_tbl_t* cmd_tbl = (ahci_cmd_tbl_t*)port->cmd_tables[slot];
    k_memset(cmd_tbl, 0, sizeof(ahci_cmd_tbl_t));
    
    /* Setup PRDT */
    uint64_t buffer_phys = vmm_virt_to_phys((void*)buffer);
    cmd_tbl->prdt[0].dba = buffer_phys & 0xFFFFFFFF;
    cmd_tbl->prdt[0].dbau = buffer_phys >> 32;
    cmd_tbl->prdt[0].dbc = (sector_count * 512) - 1;
    
    /* Setup command FIS */
    fis_reg_h2d_t* cmd_fis = (fis_reg_h2d_t*)cmd_tbl->cfis;
    cmd_fis->fis_type = FIS_TYPE_REG_H2D;
    cmd_fis->c = 1;
    cmd_fis->command = ATA_CMD_WRITE_DMA_EXT;
    
    /* LBA48 addressing */
    cmd_fis->lba0 = start_lba & 0xFF;
    cmd_fis->lba1 = (start_lba >> 8) & 0xFF;
    cmd_fis->lba2 = (start_lba >> 16) & 0xFF;
    cmd_fis->lba3 = (start_lba >> 24) & 0xFF;
    cmd_fis->lba4 = (start_lba >> 32) & 0xFF;
    cmd_fis->lba5 = (start_lba >> 40) & 0xFF;
    
    cmd_fis->device = 0x40; /* LBA mode */
    cmd_fis->countl = sector_count & 0xFF;
    cmd_fis->counth = (sector_count >> 8) & 0xFF;
    
    /* Issue command */
    ahci_port_write32(port, AHCI_PORT_CI, 1 << slot);
    
    /* Wait for completion */
    uint64_t timeout = timer_get_ticks() + timer_get_freq_hz() * 5; /* 5 seconds */
    while (timer_get_ticks() < timeout) {
        if (!(ahci_port_read32(port, AHCI_PORT_CI) & (1 << slot))) {
            break;
        }
    }
    
    if (ahci_port_read32(port, AHCI_PORT_CI) & (1 << slot)) {
        return STATUS_TIMEOUT;
    }
    
    /* Check for errors */
    if (ahci_port_read32(port, AHCI_PORT_IS) & 0x40000000) {
        return STATUS_ERROR;
    }
    
    return STATUS_OK;
}