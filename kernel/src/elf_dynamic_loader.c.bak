/**
 * Enhanced ELF Dynamic Loader Integration
 * Provides high-level interface for loading executables with full dynamic linking support
 */

#include "kernel.h"
#include "elf_loader.h"
#include "dynamic_linker.h"
#include "vmm.h"
#include "vfs.h"
#include "log.h"
#include "string.h"

/* ELF interpreter (dynamic linker) */
#define ELF_INTERPRETER "/lib64/ld-linux-x86-64.so.2"

/* Load executable with full dynamic linking support */
int elf_load_executable(vmm_aspace_t* aspace, const char* path, const char* const argv[], 
                       const char* const envp[], elf_load_result_t* result) {
    if (!aspace || !path || !result) return K_EINVAL;
    
    KLOG_INFO("elf", "Loading executable: %s", path);
    
    /* Initialize dynamic linker for this address space */
    int ret = dynlink_init(aspace);
    if (ret != 0) {
        KLOG_ERROR("elf", "Failed to initialize dynamic linker: %d", ret);
        return ret;
    }
    
    /* Load the main executable */
    ret = elf_load_into_aspace(aspace, path, 0, result);
    if (ret != ELF_OK) {
        KLOG_ERROR("elf", "Failed to load main executable: %d", ret);
        return ret;
    }
    
    /* Check if this is a dynamically linked executable */
    bool is_dynamic = false;
    file_t* f = NULL;
    if (vfs_open(path, VFS_O_RDONLY, &f) == 0) {
        Elf64_Ehdr ehdr;
        uint64_t bytes_read;
        
        if (vfs_read(f, &ehdr, sizeof(ehdr), &bytes_read) == 0 && 
            bytes_read == sizeof(ehdr)) {
            
            /* Check for PT_INTERP (dynamic linker) segment */
            if (ehdr.e_phnum > 0) {
                vfs_seek(f, ehdr.e_phoff, VFS_SEEK_SET);
                
                for (int i = 0; i < ehdr.e_phnum; i++) {
                    Elf64_Phdr phdr;
                    if (vfs_read(f, &phdr, sizeof(phdr), &bytes_read) == 0 && 
                        bytes_read == sizeof(phdr)) {
                        
                        if (phdr.p_type == PT_INTERP) {
                            is_dynamic = true;
                            break;
                        }
                    }
                }
            }
        }
        vfs_close(f);
    }
    
    if (is_dynamic) {
        KLOG_INFO("elf", "Executable requires dynamic linking");
        
        /* Load dynamic linker/loader */
        uint64_t ld_base;
        ret = dynlink_load_library(ELF_INTERPRETER, &ld_base);
        if (ret != 0) {
            KLOG_WARN("elf", "Failed to load dynamic linker, using fallback");
            /* Continue without dynamic linker for basic functionality */
        } else {
            KLOG_INFO("elf", "Dynamic linker loaded at 0x%llx", ld_base);
        }
        
        /* Parse DT_NEEDED dependencies and load them */
        ret = elf_load_dependencies(aspace, path);
        if (ret != 0) {
            KLOG_WARN("elf", "Some dependencies failed to load: %d", ret);
        }
    }
    
    /* Set up initial process environment */
    ret = elf_setup_process_environment(aspace, argv, envp, result);
    if (ret != 0) {
        KLOG_ERROR("elf", "Failed to setup process environment: %d", ret);
        return ret;
    }
    
    KLOG_INFO("elf", "Successfully loaded executable %s (entry: 0x%llx)", 
              path, result->entry);
    
    return 0;
}

/* Load all dependencies specified in DT_NEEDED entries */
int elf_load_dependencies(vmm_aspace_t* aspace, const char* main_path) {
    if (!aspace || !main_path) return K_EINVAL;
    
    file_t* f = NULL;
    int ret = vfs_open(main_path, VFS_O_RDONLY, &f);
    if (ret != 0) return ret;
    
    /* Read ELF header */
    Elf64_Ehdr ehdr;
    uint64_t bytes_read;
    ret = vfs_read(f, &ehdr, sizeof(ehdr), &bytes_read);
    if (ret != 0 || bytes_read != sizeof(ehdr)) {
        vfs_close(f);
        return K_EIO;
    }
    
    /* Find PT_DYNAMIC segment */
    vfs_seek(f, ehdr.e_phoff, VFS_SEEK_SET);
    Elf64_Phdr dynamic_phdr = {0};
    bool found_dynamic = false;
    
    for (int i = 0; i < ehdr.e_phnum; i++) {
        Elf64_Phdr phdr;
        if (vfs_read(f, &phdr, sizeof(phdr), &bytes_read) == 0 && 
            bytes_read == sizeof(phdr)) {
            
            if (phdr.p_type == PT_DYNAMIC) {
                dynamic_phdr = phdr;
                found_dynamic = true;
                break;
            }
        }
    }
    
    if (!found_dynamic) {
        vfs_close(f);
        return 0;  /* No dependencies */
    }
    
    /* Read dynamic section */
    size_t dynamic_size = dynamic_phdr.p_filesz;
    void* dynamic_data = kalloc(dynamic_size);
    if (!dynamic_data) {
        vfs_close(f);
        return K_ENOMEM;
    }
    
    vfs_seek(f, dynamic_phdr.p_offset, VFS_SEEK_SET);
    ret = vfs_read(f, dynamic_data, dynamic_size, &bytes_read);
    vfs_close(f);
    
    if (ret != 0 || bytes_read != dynamic_size) {
        kfree(dynamic_data);
        return K_EIO;
    }
    
    /* Parse dynamic entries */
    const Elf64_Dyn* dynamic = (const Elf64_Dyn*)dynamic_data;
    size_t dyn_count = dynamic_size / sizeof(Elf64_Dyn);
    
    /* Find string table first */
    const char* strtab = NULL;
    size_t strtab_size = 0;
    
    for (size_t i = 0; i < dyn_count; i++) {
        if (dynamic[i].d_tag == DT_NULL) break;
        
        if (dynamic[i].d_tag == DT_STRTAB) {
            /* This is a file offset in the current implementation */
            strtab = (const char*)dynamic_data + dynamic[i].d_un.d_ptr;
        } else if (dynamic[i].d_tag == DT_STRSZ) {
            strtab_size = dynamic[i].d_un.d_val;
        }
    }
    
    if (!strtab) {
        kfree(dynamic_data);
        return K_EINVAL;
    }
    
    /* Load DT_NEEDED libraries */
    uint32_t loaded_count = 0;
    for (size_t i = 0; i < dyn_count; i++) {
        if (dynamic[i].d_tag == DT_NULL) break;
        
        if (dynamic[i].d_tag == DT_NEEDED) {
            uint64_t name_offset = dynamic[i].d_un.d_val;
            if (name_offset >= strtab_size) continue;
            
            const char* lib_name = strtab + name_offset;
            char lib_path[256];
            
            /* Try standard library paths */
            const char* lib_paths[] = {
                "/lib64/",
                "/usr/lib64/", 
                "/lib/",
                "/usr/lib/",
                NULL
            };
            
            bool loaded = false;
            for (int j = 0; lib_paths[j] && !loaded; j++) {
                k_snprintf(lib_path, sizeof(lib_path), "%s%s", lib_paths[j], lib_name);
                
                uint64_t lib_base;
                if (dynlink_load_library(lib_path, &lib_base) == 0) {
                    KLOG_INFO("elf", "Loaded dependency: %s at 0x%llx", lib_path, lib_base);
                    loaded = true;
                    loaded_count++;
                }
            }
            
            if (!loaded) {
                KLOG_WARN("elf", "Failed to load dependency: %s", lib_name);
            }
        }
    }
    
    kfree(dynamic_data);
    
    KLOG_INFO("elf", "Loaded %u dependencies", loaded_count);
    return 0;
}

/* Setup process environment (argv, envp, auxiliary vector) */
int elf_setup_process_environment(vmm_aspace_t* aspace, const char* const argv[], 
                                 const char* const envp[], elf_load_result_t* result) {
    if (!aspace || !result) return K_EINVAL;
    
    /* Calculate sizes needed */
    size_t argc = 0;
    size_t argv_size = 0;
    if (argv) {
        while (argv[argc]) {
            argv_size += k_strlen(argv[argc]) + 1;
            argc++;
        }
    }
    
    size_t envc = 0;
    size_t envp_size = 0;
    if (envp) {
        while (envp[envc]) {
            envp_size += k_strlen(envp[envc]) + 1;
            envc++;
        }
    }
    
    /* Allocate stack space for arguments and environment */
    size_t total_size = (argc + 1) * sizeof(char*) +    /* argv pointers */
                       (envc + 1) * sizeof(char*) +     /* envp pointers */ 
                       argv_size + envp_size +          /* string data */
                       16 * sizeof(uint64_t);           /* auxiliary vector */
    
    total_size = align_up(total_size, PAGE_SIZE);
    
    /* Map stack pages */
    virt_addr_t stack_base = result->user_stack - total_size;
    for (size_t offset = 0; offset < total_size; offset += PAGE_SIZE) {
        phys_addr_t page = hal_phys_alloc_page();
        if (!page) return K_ENOMEM;
        
        int map_ret = vmm_map_page(aspace, stack_base + offset, page, 
                                  VMM_FLAG_USER | VMM_FLAG_WRITE | VMM_FLAG_READ);
        if (map_ret != 0) {
            hal_phys_free_page(page);
            return map_ret;
        }
    }
    
    /* Copy arguments and environment to user space */
    uint64_t* stack_ptr = (uint64_t*)stack_base;
    
    /* argc */
    *stack_ptr++ = argc;
    
    /* argv pointers */
    char** argv_ptrs = (char**)stack_ptr;
    stack_ptr += argc + 1;
    
    /* envp pointers */
    char** envp_ptrs = (char**)stack_ptr;
    stack_ptr += envc + 1;
    
    /* String data area */
    char* str_data = (char*)stack_ptr;
    
    /* Copy argv strings */
    char* str_ptr = str_data;
    for (size_t i = 0; i < argc; i++) {
        size_t len = k_strlen(argv[i]) + 1;
        k_memcpy(str_ptr, argv[i], len);
        argv_ptrs[i] = str_ptr;
        str_ptr += len;
    }
    argv_ptrs[argc] = NULL;
    
    /* Copy envp strings */
    for (size_t i = 0; i < envc; i++) {
        size_t len = k_strlen(envp[i]) + 1;
        k_memcpy(str_ptr, envp[i], len);
        envp_ptrs[i] = str_ptr;
        str_ptr += len;
    }
    envp_ptrs[envc] = NULL;
    
    /* Auxiliary vector (AT_*) */
    uint64_t* auxv = (uint64_t*)align_up((uintptr_t)str_ptr, sizeof(uint64_t));
    *auxv++ = AT_PHDR; *auxv++ = result->image_base;  /* Program headers */
    *auxv++ = AT_PHENT; *auxv++ = sizeof(Elf64_Phdr); /* PHdr entry size */
    *auxv++ = AT_PHNUM; *auxv++ = 0;                  /* PHdr count (TODO) */
    *auxv++ = AT_PAGESZ; *auxv++ = PAGE_SIZE;         /* Page size */
    *auxv++ = AT_BASE; *auxv++ = 0;                   /* Interpreter base */
    *auxv++ = AT_ENTRY; *auxv++ = result->entry;      /* Entry point */
    *auxv++ = AT_UID; *auxv++ = 1000;                 /* Real UID */
    *auxv++ = AT_GID; *auxv++ = 1000;                 /* Real GID */
    *auxv++ = AT_EUID; *auxv++ = 1000;                /* Effective UID */
    *auxv++ = AT_EGID; *auxv++ = 1000;                /* Effective GID */
    *auxv++ = AT_NULL; *auxv++ = 0;                   /* End marker */
    
    /* Update stack pointer */
    result->user_stack = stack_base;
    
    KLOG_INFO("elf", "Process environment setup complete (argc=%zu, envc=%zu)", argc, envc);
    return 0;
}

/* Get information about loaded executable */
int elf_get_executable_info(const char* path, elf_executable_info_t* info) {
    if (!path || !info) return K_EINVAL;
    
    k_memset(info, 0, sizeof(elf_executable_info_t));
    
    file_t* f = NULL;
    int ret = vfs_open(path, VFS_O_RDONLY, &f);
    if (ret != 0) return ret;
    
    /* Read ELF header */
    uint64_t bytes_read;
    ret = vfs_read(f, &info->ehdr, sizeof(info->ehdr), &bytes_read);
    if (ret != 0 || bytes_read != sizeof(info->ehdr)) {
        vfs_close(f);
        return K_EIO;
    }
    
    /* Validate ELF header */
    if (info->ehdr.e_ident[EI_MAG0] != ELFMAG0 ||
        info->ehdr.e_ident[EI_MAG1] != ELFMAG1 ||
        info->ehdr.e_ident[EI_MAG2] != ELFMAG2 ||
        info->ehdr.e_ident[EI_MAG3] != ELFMAG3) {
        vfs_close(f);
        return K_EINVAL;
    }
    
    if (info->ehdr.e_ident[EI_CLASS] != ELFCLASS64 ||
        info->ehdr.e_machine != EM_X86_64) {
        vfs_close(f);
        return K_ENOTSUP;
    }
    
    info->is_64bit = true;
    info->is_executable = (info->ehdr.e_type == ET_EXEC);
    info->is_shared_object = (info->ehdr.e_type == ET_DYN);
    info->entry_point = info->ehdr.e_entry;
    
    /* Check for interpreter */
    if (info->ehdr.e_phnum > 0) {
        vfs_seek(f, info->ehdr.e_phoff, VFS_SEEK_SET);
        
        for (int i = 0; i < info->ehdr.e_phnum; i++) {
            Elf64_Phdr phdr;
            if (vfs_read(f, &phdr, sizeof(phdr), &bytes_read) == 0 && 
                bytes_read == sizeof(phdr)) {
                
                if (phdr.p_type == PT_INTERP) {
                    info->has_interpreter = true;
                    info->is_dynamic = true;
                    
                    /* Read interpreter path */
                    if (phdr.p_filesz < sizeof(info->interpreter)) {
                        vfs_seek(f, phdr.p_offset, VFS_SEEK_SET);
                        vfs_read(f, info->interpreter, phdr.p_filesz, &bytes_read);
                        info->interpreter[bytes_read] = '\0';
                    }
                    break;
                }
            }
        }
    }
    
    vfs_close(f);
    return 0;
}