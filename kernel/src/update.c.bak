// Kernel OTA Update module (A/B slots)
#include "kernel.h"
#include "string.h"
#include "vfs.h"
#include "update.h"
#include "policy.h"

static update_meta_t g_meta;
static int meta_loaded = 0;

/* Local lightweight libc-style helpers (avoid pulling full implementations) */
static size_t k_strlcpy_local(char* dst, const char* src, size_t n){ if(!dst||!src||n==0) return 0; size_t i=0; for(; i+1<n && src[i]; ++i) dst[i]=src[i]; if(n) dst[i]=0; while(src[i]) ++i; return i; }
static u32 k_strtou32_local(const char* s, int base){ if(!s||base<2||base>16) return 0; u32 v=0; while(*s){ char c=*s++; int d=-1; if(c>='0'&&c<='9') d=c-'0'; else if(c>='a'&&c<='f') d=10+(c-'a'); else if(c>='A'&&c<='F') d=10+(c-'A'); else break; if(d>=base) break; v = v* (u32)base + (u32)d; } return v; }
static int k_memcmp_local(const void* a,const void* b,size_t n){ const u8* x=(const u8*)a; const u8* y=(const u8*)b; for(size_t i=0;i<n;i++){ if(x[i]!=y[i]) return (int)x[i] - (int)y[i]; } return 0; }
/* minimal scanner for "%2x" sequences used in hex_to_bytes */
static int hexval(char c){ if(c>='0'&&c<='9') return c-'0'; if(c>='a'&&c<='f') return 10+(c-'a'); if(c>='A'&&c<='F') return 10+(c-'A'); return -1; }
static int k_sscanf_hex2(const char* s, unsigned int* out){ if(!s||!out) return 0; int hi=hexval(s[0]); int lo=hexval(s[1]); if(hi<0||lo<0) return 0; *out=(unsigned int)(hi*16+lo); return 1; }
/* Macros mapping original names used in code */
#define k_strlcpy k_strlcpy_local
#define k_strtou32 k_strtou32_local
#define k_memcmp k_memcmp_local
#define k_sscanf(ptr,fmt,outptr) k_sscanf_hex2((ptr),(outptr))

static int meta_path(char* out, size_t n){ k_strlcpy(out, "/boot/slots.meta", n); return 0; }

static void meta_defaults(update_meta_t* m){
    m->active = 'A'; m->previous='-'; m->pending=0; m->boot_success=1; m->boot_count=0;
}

/* Read entire small text file into buffer */
static int read_small_file(const char* path, char* buf, size_t cap, size_t* out_len){
    file_t* f=NULL; u64 rd=0; int rc = vfs_open(path, VFS_O_RDONLY, &f); if(rc!=0) return rc;
    vfs_seek(f, 0, VFS_SEEK_END); u64 sz = vfs_tell(f); vfs_seek(f, 0, VFS_SEEK_SET);
    if (sz >= cap) sz = cap-1;
    rc = vfs_read(f, buf, sz, &rd); vfs_close(f); if(rc!=0) return rc; buf[rd]=0; if(out_len) *out_len = rd; return 0;
}

static int meta_load(update_meta_t* m){
    char path[64]; meta_path(path,sizeof(path));
    char text[512]; size_t n=0; int rc = read_small_file(path, text, sizeof(text), &n);
    if (rc!=0){ meta_defaults(m); return 0; }
    meta_defaults(m);
    /* parse key=value per line */
    const char* s = text; while (*s){
        const char* line = s; while (*s && *s!='\n' && *s!='\r') s++; size_t len = (size_t)(s - line);
        while (*s=='\r' || *s=='\n') s++;
        if (!len) continue; char key[32]={0}, val[32]={0};
        size_t i=0; while (i<len && i<sizeof(key)-1 && line[i] != '='){ key[i]=line[i]; i++; }
        size_t j=0; if (i<len && line[i]=='='){ i++; for(; i<len && j<sizeof(val)-1; ++i,++j) val[j]=line[i]; }
        if (key[0]==0) continue;
        if (k_strcmp(key,"active")==0 && val[0]) m->active = val[0];
        else if (k_strcmp(key,"previous")==0 && val[0]) m->previous = val[0];
        else if (k_strcmp(key,"pending")==0) m->pending = (val[0]=='1');
        else if (k_strcmp(key,"boot_success")==0) m->boot_success = (val[0]=='1');
        else if (k_strcmp(key,"boot_count")==0) m->boot_count = (int)k_strtou32(val,10);
    }
    return 0;
}

static int meta_save(const update_meta_t* m){
    char path[64]; meta_path(path,sizeof(path));
    /* Compose text */
    char text[128];
    int n = k_snprintf(text, sizeof(text), "active=%c\nprevious=%c\npending=%d\nboot_success=%d\nboot_count=%d\n",
                       m->active, m->previous, m->pending, m->boot_success, m->boot_count);
    if (n <= 0) return K_EIO;
    file_t* f=NULL; int rc = vfs_open(path, VFS_O_CREAT|VFS_O_WRONLY, &f); if(rc!=0) return rc;
    u64 wr=0; rc = vfs_write(f, text, (u64)n, &wr); vfs_close(f);
    return rc;
}

/* SHA-256 (local minimal) */
typedef struct { u32 h[8]; u8 buf[64]; u64 len; u32 idx; } sha256_ctx_t;
static const u32 Kt[64] = {
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};
static inline u32 ROR(u32 x,u32 n){ return (x>>n)|(x<<(32-n)); }
static inline u32 Ch(u32 x,u32 y,u32 z){ return (x & y) ^ (~x & z); }
static inline u32 Maj(u32 x,u32 y,u32 z){ return (x & y) ^ (x & z) ^ (y & z); }
static inline u32 S0(u32 x){ return ROR(x,2)^ROR(x,13)^ROR(x,22); }
static inline u32 S1(u32 x){ return ROR(x,6)^ROR(x,11)^ROR(x,25); }
static inline u32 s0(u32 x){ return ROR(x,7)^ROR(x,18)^(x>>3); }
static inline u32 s1(u32 x){ return ROR(x,17)^ROR(x,19)^(x>>10); }
static void sha256_init(sha256_ctx_t* c){ c->h[0]=0x6a09e667; c->h[1]=0xbb67ae85; c->h[2]=0x3c6ef372; c->h[3]=0xa54ff53a; c->h[4]=0x510e527f; c->h[5]=0x9b05688c; c->h[6]=0x1f83d9ab; c->h[7]=0x5be0cd19; c->len=0; c->idx=0; }
static void sha256_block(sha256_ctx_t* c,const u8 b[64]){ u32 w[64]; for(int i=0;i<16;i++){ w[i]=(b[i*4]<<24)|(b[i*4+1]<<16)|(b[i*4+2]<<8)|b[i*4+3]; } for(int i=16;i<64;i++){ w[i]=s1(w[i-2])+w[i-7]+s0(w[i-15])+w[i-16]; } u32 a=c->h[0],b0=c->h[1],d=c->h[3],e=c->h[4],f=c->h[5],g=c->h[6],h=c->h[7],bb=c->h[2]; for(int i=0;i<64;i++){ u32 T1=h+S1(e)+Ch(e,f,g)+Kt[i]+w[i]; u32 T2=S0(a)+Maj(a,b0,bb); h=g; g=f; f=e; e=d+T1; d=bb; bb=b0; b0=a; a=T1+T2; } c->h[0]+=a; c->h[1]+=b0; c->h[2]+=bb; c->h[3]+=d; c->h[4]+=e; c->h[5]+=f; c->h[6]+=g; c->h[7]+=h; }
static void sha256_update(sha256_ctx_t* c,const void* data,size_t len){ const u8* p=(const u8*)data; c->len += len; while(len--){ c->buf[c->idx++]=*p++; if(c->idx==64){ sha256_block(c,c->buf); c->idx=0; } } }
static void sha256_final(sha256_ctx_t* c,u8 out[32]){ u64 bits=c->len*8; c->buf[c->idx++]=0x80; if(c->idx>56){ while(c->idx<64) c->buf[c->idx++]=0; sha256_block(c,c->buf); c->idx=0; } while(c->idx<56) c->buf[c->idx++]=0; for(int i=7;i>=0;i--) c->buf[c->idx++]=(u8)((bits>>(i*8))&0xFF); sha256_block(c,c->buf); for(int i=0;i<8;i++){ out[i*4]=(u8)(c->h[i]>>24); out[i*4+1]=(u8)(c->h[i]>>16); out[i*4+2]=(u8)(c->h[i]>>8); out[i*4+3]=(u8)(c->h[i]); } }

/* HMAC-SHA256 with built-in public key placeholder (prototype uses symmetric key) */
static const u8 UPDATE_SIGN_KEY[32] = { 0x42,0x4f,0x58,0x2d,0x4b,0x45,0x59,0x21, 0,1,2,3,4,5,6,7, 8,9,10,11,12,13,14,15, 0xaa,0xbb,0xcc,0xdd,0xee,0xff,0x11,0x22 };
static void hmac_sha256(const u8* key,size_t klen,const u8* data,size_t dlen,u8 out[32]){
    u8 k0[64]; k_memset(k0,0,sizeof(k0)); if(klen>64){ sha256_ctx_t t; sha256_init(&t); sha256_update(&t,key,klen); sha256_final(&t,k0); } else { k_memcpy(k0,key,klen); }
    u8 ipad[64], opad[64]; for(int i=0;i<64;i++){ ipad[i]=k0[i]^0x36; opad[i]=k0[i]^0x5c; }
    sha256_ctx_t c; sha256_init(&c); sha256_update(&c,ipad,64); sha256_update(&c,data,dlen); u8 ih[32]; sha256_final(&c,ih);
    sha256_init(&c); sha256_update(&c,opad,64); sha256_update(&c,ih,32); sha256_final(&c,out);
}

static int hex_to_bytes(const char* hex, u8* out, size_t outlen){ size_t n=k_strlen(hex); size_t i=0,j=0; if(n%2) return -1; for(; i<n && j<outlen; i+=2, ++j){ unsigned int v=0; if (k_sscanf(&hex[i], "%2x", &v) <= 0) return -1; out[j]=(u8)v; } return 0; }

int update_init(void){
    if(meta_load(&g_meta)==0){ meta_loaded=1; }
    if(g_meta.pending && !g_meta.boot_success){
        g_meta.boot_count++;
        if(g_meta.boot_count > 1){
            char prev = g_meta.previous; if(prev=='A' || prev=='B'){
                g_meta.active = prev;
                g_meta.previous = '-';
                g_meta.pending = 0;
                g_meta.boot_success = 1;
                g_meta.boot_count = 0;
                meta_save(&g_meta);
            }
        } else {
            meta_save(&g_meta);
        }
    }
    return 0;
}

int update_get_meta(update_meta_t* out){ if(!meta_loaded) update_init(); if(!out) return -1; *out = g_meta; return 0; }

int update_begin(char* out_slot){
    if (!policy_updates_permitted()) return -1;
    if(!meta_loaded) update_init();
    char inactive = (g_meta.active=='A') ? 'B' : 'A';
    if(out_slot) *out_slot = inactive;
    g_meta.pending = 1; g_meta.previous = g_meta.active; g_meta.boot_success = 0; g_meta.boot_count = 0;
    return meta_save(&g_meta);
}

/* Optional Ed25519 verifier provided by platform: returns 0 on success */
extern int ed25519_verify(const u8 sig[64], const u8* msg, size_t msglen, const u8 pub[32]) __attribute__((weak));

static int read_hex_file(const char* path, u8* out, size_t outlen){
    char buf[2048]; size_t n=0; int rc = read_small_file(path, buf, sizeof(buf), &n); if(rc!=0) return rc;
    /* strip newlines */
    for(size_t i=0;i<n;i++){ if(buf[i]=='\r'||buf[i]=='\n'){ buf[i]=0; break; } }
    return hex_to_bytes(buf, out, outlen);
}

int update_apply_ota(const char* ota_dir){
    if (!policy_updates_permitted()) return -1;
    if(!ota_dir) return -1;
    char inactive = (g_meta.active=='A') ? 'B' : 'A'; (void)inactive;
    char imgpath[256]; k_snprintf(imgpath,sizeof(imgpath), "%s/root.img", ota_dir);
    file_t* f=NULL; int rc = vfs_open(imgpath, VFS_O_RDONLY, &f); if(rc!=0) return -4;
    sha256_ctx_t c; sha256_init(&c);
    u8 buf[4096]; u64 rd=0; for(;;){ rd=0; int r = vfs_read(f, buf, sizeof(buf), &rd); if(r!=0){ vfs_close(f); return -5; } if(rd==0) break; sha256_update(&c, buf, (size_t)rd); }
    vfs_close(f);
    u8 digest[32]; sha256_final(&c, digest);
    /* Try Ed25519 if pubkey and signature are present and verifier linked */
    char pubpath[256]; k_snprintf(pubpath,sizeof(pubpath), "/boot/ed25519.pub");
    char sigpath[256]; k_snprintf(sigpath,sizeof(sigpath), "%s/ota.sig", ota_dir);
    u8 pub[32]; u8 sig[64]; int ed_ok = 0;
    if (ed25519_verify) {
        if (read_hex_file(pubpath, pub, sizeof(pub))==0 && read_hex_file(sigpath, sig, sizeof(sig))==0) {
            /* Verify Ed25519 signature over the digest */
            if (ed25519_verify(sig, digest, sizeof(digest), pub) == 0) {
                ed_ok = 1;
            } else {
                return -6; /* signature invalid */
            }
        }
    }
    if (!ed_ok) {
        /* Fallback: accept legacy HMAC-SHA256 signatures */
        char shpath[256]; k_snprintf(shpath,sizeof(shpath), "%s/ota.hmac", ota_dir);
        u8 expect[32]; if (read_hex_file(shpath, expect, sizeof(expect))!=0) return -3;
        u8 mac[32]; hmac_sha256(UPDATE_SIGN_KEY, sizeof(UPDATE_SIGN_KEY), digest, 32, mac);
        if (k_memcmp(mac, expect, 32) != 0) return -6;
    }

    /* Platform-specific write to inactive slot */
    extern int platform_write_root_slot(char slot, const char* img_path) __attribute__((weak));
    if (platform_write_root_slot) {
        int wrc = platform_write_root_slot(inactive, imgpath);
        if (wrc!=0) return -7;
    } else {
        /* Fallback: write marker file indicating staged image path */
        char mark[256]; k_snprintf(mark,sizeof(mark), "/boot/update.%c.staged", inactive);
        file_t* mf=NULL; if (vfs_open(mark, VFS_O_CREAT|VFS_O_WRONLY, &mf)==0){ u64 ww=0; vfs_write(mf, imgpath, (u64)k_strlen(imgpath), &ww); vfs_close(mf); }
    }
    g_meta.pending = 1; g_meta.previous = g_meta.active; g_meta.boot_success = 0; g_meta.boot_count = 0;
    return meta_save(&g_meta);
}

int update_finalize(void){ if(!policy_updates_permitted()) return -1; if(!meta_loaded) update_init(); if(!g_meta.pending) return 0; g_meta.active = (g_meta.active=='A') ? 'B' : 'A'; return meta_save(&g_meta); }
int update_mark_success(void){ if(!meta_loaded) update_init(); g_meta.pending=0; g_meta.previous='-'; g_meta.boot_success=1; g_meta.boot_count=0; return meta_save(&g_meta); }
int update_rollback(void){ if(!meta_loaded) update_init(); if(g_meta.previous=='A'||g_meta.previous=='B'){ g_meta.active=g_meta.previous; g_meta.previous='-'; g_meta.pending=0; g_meta.boot_success=1; g_meta.boot_count=0; return meta_save(&g_meta);} return -1; }
