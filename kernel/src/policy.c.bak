#include "policy.h"
#include "vfs.h"
#include "string.h"
#include "net/filter.h"

static policy_t g_policy;
static int g_loaded = 0;

static void policy_defaults(policy_t* p){
    p->firewall_in_default = 0;  /* DROP */
    p->firewall_out_default = 0; /* DROP */
    p->updates_allowed = 1;
    p->update_window_start = 0;
    p->update_window_end = 0;
}

static int read_all(const char* path, char* buf, size_t cap, size_t* out){
    file_t* f=NULL; u64 rd=0; int rc = vfs_open(path, VFS_O_RDONLY, &f); if(rc!=0) return rc;
    vfs_seek(f, 0, VFS_SEEK_END); u64 sz = vfs_tell(f); vfs_seek(f, 0, VFS_SEEK_SET);
    if (sz >= cap) sz = cap-1;
    rc = vfs_read(f, buf, sz, &rd); vfs_close(f); if(rc!=0) return rc; buf[rd]=0; if(out) *out = rd; return 0;
}

/* Minimal JSON extractor: works for flat {"key": number, "key": bool} */
static int json_find_int(const char* s, const char* key, int* outv){
    char pat[64]; k_snprintf(pat, sizeof(pat), "\"%s\"", key);
    const char* p = k_strstr(s, pat); if(!p) return -1;
    p += k_strlen(pat);
    while (*p && (*p==' '||*p=='\t'||*p=='\r'||*p=='\n'||*p==':')) p++;
    int sign=1; if (*p=='-'){ sign=-1; p++; }
    int v=0; int any=0; while(*p>='0' && *p<='9'){ v = v*10 + (*p - '0'); p++; any=1; }
    if(!any) return -1; *outv = v*sign; return 0;
}
static int json_find_bool(const char* s, const char* key, int* outv){
    char pat[64]; k_snprintf(pat, sizeof(pat), "\"%s\"", key);
    const char* p = k_strstr(s, pat); if(!p) return -1;
    p += k_strlen(pat);
    while (*p && (*p==' '||*p=='\t'||*p=='\r'||*p=='\n'||*p==':')) p++;
    if (k_strncmp(p, "true", 4)==0){ *outv = 1; return 0; }
    if (k_strncmp(p, "false",5)==0){ *outv = 0; return 0; }
    return -1;
}

void policy_init(void){
    policy_defaults(&g_policy);
    char text[2048]; size_t n=0; if (read_all("/etc/policy.json", text, sizeof(text), &n)==0){
        int v=0;
        if (json_find_int(text, "firewall_in_default", &v)==0) g_policy.firewall_in_default = v?1:0;
        if (json_find_int(text, "firewall_out_default", &v)==0) g_policy.firewall_out_default = v?1:0;
        if (json_find_bool(text, "updates_allowed", &v)==0) g_policy.updates_allowed = v?1:0;
        if (json_find_int(text, "update_window_start", &v)==0) g_policy.update_window_start = v;
        if (json_find_int(text, "update_window_end", &v)==0) g_policy.update_window_end = v;
    }
    /* Apply firewall defaults */
    nf_set_default_policy(0, g_policy.firewall_in_default ? NF_ACCEPT : NF_DROP);
    nf_set_default_policy(1, g_policy.firewall_out_default ? NF_ACCEPT : NF_DROP);
    g_loaded = 1;
}

const policy_t* policy_current(void){ if(!g_loaded) policy_init(); return &g_policy; }

/* Naive window check: if start==end==0 -> allowed whenever; otherwise allow if within [start,end) hour window. */
int policy_updates_permitted(void){
    const policy_t* p = policy_current();
    if (!p->updates_allowed) return 0;
    if (p->update_window_start==0 && p->update_window_end==0) return 1;
    /* No RTC/time-of-day available in Phase 6; treat window as always open for now. */
    return 1;
}
