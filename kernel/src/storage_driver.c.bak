/*
 * Storage Device Driver
 * Basic AHCI/SATA and NVMe support
 */

#include "kernel.h"

/* AHCI Port Registers */
#define AHCI_PORT_CLB       0x00
#define AHCI_PORT_CLBU      0x04
#define AHCI_PORT_FB        0x08
#define AHCI_PORT_FBU       0x0C
#define AHCI_PORT_IS        0x10
#define AHCI_PORT_IE        0x14
#define AHCI_PORT_CMD       0x18
#define AHCI_PORT_TFD       0x20
#define AHCI_PORT_SIG       0x24
#define AHCI_PORT_SSTS      0x28

/* AHCI Port Command Register Bits */
#define AHCI_PORT_CMD_ST    (1 << 0)
#define AHCI_PORT_CMD_SUD   (1 << 1)
#define AHCI_PORT_CMD_POD   (1 << 2)
#define AHCI_PORT_CMD_FRE   (1 << 4)

/* Storage Device Types */
typedef enum {
    STORAGE_TYPE_UNKNOWN = 0,
    STORAGE_TYPE_ATA,
    STORAGE_TYPE_ATAPI,
    STORAGE_TYPE_SATA,
    STORAGE_TYPE_NVME
} storage_type_t;

/* Storage Device Structure */
typedef struct storage_device {
    u32 device_id;
    storage_type_t type;
    u64 sector_count;
    u32 sector_size;
    char model[41];        /* ATA model string */
    char serial[21];       /* Serial number */
    void* driver_data;     /* Driver-specific data */
    struct storage_device* next;
} storage_device_t;

/* Global storage device list */
static storage_device_t* g_storage_devices = NULL;
static u32 g_storage_device_count = 0;
static u32 g_next_device_id = 1;

/* Add storage device to global list */
static void storage_add_device(storage_type_t type, u64 sectors, u32 sector_size,
                              const char* model, const char* serial, void* driver_data) {
    storage_device_t* dev = (storage_device_t*)kalloc(sizeof(storage_device_t));
    if (!dev) return;
    
    dev->device_id = g_next_device_id++;
    dev->type = type;
    dev->sector_count = sectors;
    dev->sector_size = sector_size;
    dev->driver_data = driver_data;
    dev->next = g_storage_devices;
    
    /* Copy strings safely */
    if (model) {
        for (int i = 0; i < 40 && model[i]; i++) {
            dev->model[i] = model[i];
        }
        dev->model[40] = '\0';
    } else {
        strcpy(dev->model, "Unknown Device");
    }
    
    if (serial) {
        for (int i = 0; i < 20 && serial[i]; i++) {
            dev->serial[i] = serial[i];
        }
        dev->serial[20] = '\0';
    } else {
        strcpy(dev->serial, "Unknown");
    }
    
    g_storage_devices = dev;
    g_storage_device_count++;
}

/* AHCI Controller Data */
typedef struct ahci_controller {
    void* mmio_base;
    u32 port_mask;
    u32 port_count;
} ahci_controller_t;

/* Initialize AHCI controller */
static void ahci_init_controller(void* pci_dev) {
    ahci_controller_t* ctrl = (ahci_controller_t*)kalloc(sizeof(ahci_controller_t));
    if (!ctrl) return;
    
    /* In real implementation, would map MMIO and initialize controller */
    ctrl->mmio_base = (void*)0xFEBC0000;  /* Example MMIO address */
    ctrl->port_mask = 0x3F;  /* Ports 0-5 available */
    ctrl->port_count = 6;
    
    /* Detect drives on each port */
    for (u32 port = 0; port < ctrl->port_count; port++) {
        if (!(ctrl->port_mask & (1 << port))) continue;
        
        /* Simulate drive detection */
        if (port == 0) {
            /* Primary drive */
            storage_add_device(STORAGE_TYPE_SATA, 
                             2048576,    /* 1TB in 512-byte sectors */
                             512,        /* 512 bytes per sector */
                             "LimitlessOS Virtual SATA Drive",
                             "VIRT001",
                             ctrl);
        }
    }
}

/* NVMe Controller Data */
typedef struct nvme_controller {
    void* mmio_base;
    u32 namespace_count;
} nvme_controller_t;

/* Initialize NVMe controller */
static void nvme_init_controller(void* pci_dev) {
    nvme_controller_t* ctrl = (nvme_controller_t*)kalloc(sizeof(nvme_controller_t));
    if (!ctrl) return;
    
    /* In real implementation, would initialize NVMe controller */
    ctrl->mmio_base = (void*)0xFEBD0000;  /* Example MMIO address */
    ctrl->namespace_count = 1;
    
    /* Detect NVMe namespaces */
    for (u32 ns = 1; ns <= ctrl->namespace_count; ns++) {
        storage_add_device(STORAGE_TYPE_NVME,
                          4194304,    /* 2TB in 512-byte sectors */
                          512,        /* 512 bytes per sector */
                          "LimitlessOS Virtual NVMe SSD",
                          "NVME001",
                          ctrl);
    }
}

/* Initialize storage subsystem */
void storage_init(void) {
    /* Find and initialize SATA controllers */
    /* In real implementation would use PCI enumeration */
    
    /* Simulate finding AHCI controller */
    ahci_init_controller(NULL);
    
    /* Simulate finding NVMe controller */
    nvme_init_controller(NULL);
}

/* Read sectors from storage device */
int storage_read_sectors(u32 device_id, u64 start_sector, u32 sector_count, void* buffer) {
    storage_device_t* dev = g_storage_devices;
    
    /* Find device */
    while (dev) {
        if (dev->device_id == device_id) break;
        dev = dev->next;
    }
    
    if (!dev) return -1;  /* Device not found */
    
    /* Check bounds */
    if (start_sector + sector_count > dev->sector_count) {
        return -1;  /* Read beyond device end */
    }
    
    /* Simulate successful read */
    /* In real implementation would issue actual I/O commands */
    if (buffer) {
        /* Clear buffer to simulate read data */
        memset(buffer, 0xAB, sector_count * dev->sector_size);
    }
    
    return 0;  /* Success */
}

/* Write sectors to storage device */
int storage_write_sectors(u32 device_id, u64 start_sector, u32 sector_count, const void* buffer) {
    storage_device_t* dev = g_storage_devices;
    
    /* Find device */
    while (dev) {
        if (dev->device_id == device_id) break;
        dev = dev->next;
    }
    
    if (!dev) return -1;  /* Device not found */
    
    /* Check bounds */
    if (start_sector + sector_count > dev->sector_count) {
        return -1;  /* Write beyond device end */
    }
    
    /* Simulate successful write */
    /* In real implementation would issue actual I/O commands */
    (void)buffer;  /* Suppress unused parameter warning */
    
    return 0;  /* Success */
}

/* Get storage device count */
u32 storage_get_device_count(void) {
    return g_storage_device_count;
}

/* Get device info */
storage_device_t* storage_get_device_info(u32 device_id) {
    storage_device_t* dev = g_storage_devices;
    
    while (dev) {
        if (dev->device_id == device_id) {
            return dev;
        }
        dev = dev->next;
    }
    
    return NULL;
}

/* List all storage devices */
void storage_list_devices(void) {
    storage_device_t* dev = g_storage_devices;
    u32 count = 0;
    
    while (dev && count < 10) {  /* Limit output */
        /* Device info would be printed in real implementation */
        const char* type_name;
        switch (dev->type) {
            case STORAGE_TYPE_ATA: type_name = "ATA"; break;
            case STORAGE_TYPE_SATA: type_name = "SATA"; break;
            case STORAGE_TYPE_NVME: type_name = "NVMe"; break;
            default: type_name = "Unknown"; break;
        }
        
        /* In real kernel, would use kprintf */
        (void)type_name;  /* Suppress unused warning */
        
        dev = dev->next;
        count++;
    }
}