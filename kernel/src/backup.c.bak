#include "backup.h"
#include "log.h"
#include "kernel.h"
#include "vfs.h"
#include "timer.h"
#include "audit_log.h"

/* Global backup state */
static backup_config_t g_backup_configs[BACKUP_MAX_CONFIGS];
static backup_snapshot_t g_backup_snapshots[BACKUP_MAX_SNAPSHOTS];
static uint32_t g_config_count = 0;
static uint32_t g_snapshot_count = 0;
static uint32_t g_next_config_id = 1;
static uint32_t g_next_snapshot_id = 1;
static spinlock_t g_backup_lock;
static backup_statistics_t g_backup_stats;
static bool g_scheduler_running = false;
static backup_event_callback_t g_event_callbacks[8];
static uint8_t g_callback_count = 0;

/* Compression buffers */
static uint8_t g_compression_buffer[1024 * 1024]; /* 1MB compression buffer */
static uint8_t g_encryption_buffer[1024 * 1024];  /* 1MB encryption buffer */

/* Helper functions */
static bool path_matches_pattern(const char* path, const char* pattern) {
    /* Simple pattern matching - '*' matches any sequence */
    if (!pattern || !path) return false;
    
    const char* p = pattern;
    const char* s = path;
    
    while (*p && *s) {
        if (*p == '*') {
            p++;
            if (!*p) return true; /* Pattern ends with *, match everything */
            
            /* Find next matching character */
            while (*s && *s != *p) s++;
            if (!*s) return false;
        } else if (*p == *s) {
            p++;
            s++;
        } else {
            return false;
        }
    }
    
    return (*p == '\0' && *s == '\0') || (*p == '*' && *(p+1) == '\0');
}

static bool should_exclude_file(const backup_config_t* config, const char* path) {
    /* Check exclude patterns */
    for (uint8_t i = 0; i < config->exclude_count; i++) {
        if (path_matches_pattern(path, config->exclude_patterns[i])) {
            return true;
        }
    }
    
    /* Check hidden files */
    if (!config->backup_hidden_files) {
        const char* filename = k_strrchr(path, '/');
        if (filename && filename[1] == '.') {
            return true;
        }
    }
    
    return false;
}

static void notify_event_callbacks(uint32_t config_id, backup_status_t status, const char* message) {
    for (uint8_t i = 0; i < g_callback_count; i++) {
        if (g_event_callbacks[i]) {
            g_event_callbacks[i](config_id, status, message);
        }
    }
}

status_t backup_init(void) {
    spinlock_init(&g_backup_lock);
    k_memset(g_backup_configs, 0, sizeof(g_backup_configs));
    k_memset(g_backup_snapshots, 0, sizeof(g_backup_snapshots));
    k_memset(&g_backup_stats, 0, sizeof(g_backup_stats));
    k_memset(g_event_callbacks, 0, sizeof(g_event_callbacks));
    
    g_config_count = 0;
    g_snapshot_count = 0;
    g_next_config_id = 1;
    g_next_snapshot_id = 1;
    g_scheduler_running = false;
    g_callback_count = 0;
    
    log_info("[BACKUP] Backup subsystem initialized");
    return STATUS_OK;
}

status_t backup_shutdown(void) {
    /* Stop scheduler */
    backup_scheduler_stop();
    
    /* Cancel any running backups */
    spin_lock(&g_backup_lock);
    for (uint32_t i = 0; i < g_config_count; i++) {
        if (g_backup_configs[i].status == BACKUP_STATUS_RUNNING) {
            g_backup_configs[i].status = BACKUP_STATUS_CANCELLED;
        }
    }
    spin_unlock(&g_backup_lock);
    
    log_info("[BACKUP] Backup subsystem shutdown");
    return STATUS_OK;
}

status_t backup_create_config(const backup_config_t* config, uint32_t* out_config_id) {
    if (!config) return STATUS_INVALID;
    
    spin_lock(&g_backup_lock);
    
    if (g_config_count >= BACKUP_MAX_CONFIGS) {
        spin_unlock(&g_backup_lock);
        return STATUS_NO_SPACE;
    }
    
    /* Find empty slot */
    uint32_t slot = g_config_count;
    g_backup_configs[slot] = *config;
    g_backup_configs[slot].config_id = g_next_config_id++;
    g_backup_configs[slot].status = BACKUP_STATUS_IDLE;
    g_backup_configs[slot].current_progress = 0;
    g_backup_configs[slot].total_size = 0;
    g_backup_configs[slot].error_code = 0;
    g_backup_configs[slot].current_file[0] = '\0';
    
    if (out_config_id) *out_config_id = g_backup_configs[slot].config_id;
    g_config_count++;
    g_backup_stats.active_configs++;
    
    spin_unlock(&g_backup_lock);
    
    audit_log_event(AUDIT_EVENT_BACKUP_OPERATION, AUDIT_SEVERITY_INFO, 0,
                   "Backup configuration created: %s", config->name);
    
    return STATUS_OK;
}

status_t backup_update_config(uint32_t config_id, const backup_config_t* config) {
    if (!config) return STATUS_INVALID;
    
    spin_lock(&g_backup_lock);
    
    for (uint32_t i = 0; i < g_config_count; i++) {
        if (g_backup_configs[i].config_id == config_id) {
            /* Preserve runtime state */
            backup_status_t old_status = g_backup_configs[i].status;
            uint64_t old_progress = g_backup_configs[i].current_progress;
            uint64_t old_total = g_backup_configs[i].total_size;
            uint32_t old_error = g_backup_configs[i].error_code;
            
            g_backup_configs[i] = *config;
            g_backup_configs[i].config_id = config_id;
            g_backup_configs[i].status = old_status;
            g_backup_configs[i].current_progress = old_progress;
            g_backup_configs[i].total_size = old_total;
            g_backup_configs[i].error_code = old_error;
            
            spin_unlock(&g_backup_lock);
            return STATUS_OK;
        }
    }
    
    spin_unlock(&g_backup_lock);
    return STATUS_NOTFOUND;
}

status_t backup_get_config(uint32_t config_id, backup_config_t* out_config) {
    if (!out_config) return STATUS_INVALID;
    
    spin_lock(&g_backup_lock);
    
    for (uint32_t i = 0; i < g_config_count; i++) {
        if (g_backup_configs[i].config_id == config_id) {
            *out_config = g_backup_configs[i];
            spin_unlock(&g_backup_lock);
            return STATUS_OK;
        }
    }
    
    spin_unlock(&g_backup_lock);
    return STATUS_NOTFOUND;
}

/* Simple compression implementation (RLE-like) */
status_t backup_compress_data(const uint8_t* input, size_t input_size,
                             backup_compression_t method, uint8_t* output, size_t* output_size) {
    if (!input || !output || !output_size) return STATUS_INVALID;
    
    switch (method) {
        case BACKUP_COMPRESS_NONE:
            if (*output_size < input_size) return STATUS_NO_SPACE;
            k_memcpy(output, input, input_size);
            *output_size = input_size;
            return STATUS_OK;
            
        case BACKUP_COMPRESS_GZIP:
        case BACKUP_COMPRESS_LZ4: {
            /* Simple run-length encoding */
            size_t out_pos = 0;
            size_t in_pos = 0;
            
            while (in_pos < input_size && out_pos < *output_size - 2) {
                uint8_t current = input[in_pos];
                uint8_t run_length = 1;
                
                /* Count consecutive identical bytes */
                while (in_pos + run_length < input_size && 
                       input[in_pos + run_length] == current && 
                       run_length < 255) {
                    run_length++;
                }
                
                if (run_length >= 3) {
                    /* Encode as run */
                    output[out_pos++] = 0xFF; /* Escape code */
                    output[out_pos++] = run_length;
                    output[out_pos++] = current;
                } else {
                    /* Copy literal bytes */
                    for (uint8_t i = 0; i < run_length && out_pos < *output_size; i++) {
                        output[out_pos++] = input[in_pos + i];
                    }
                }
                
                in_pos += run_length;
            }
            
            *output_size = out_pos;
            return STATUS_OK;
        }
        
        default:
            return STATUS_NOT_SUPPORTED;
    }
}

status_t backup_decompress_data(const uint8_t* input, size_t input_size,
                               backup_compression_t method, uint8_t* output, size_t* output_size) {
    if (!input || !output || !output_size) return STATUS_INVALID;
    
    switch (method) {
        case BACKUP_COMPRESS_NONE:
            if (*output_size < input_size) return STATUS_NO_SPACE;
            k_memcpy(output, input, input_size);
            *output_size = input_size;
            return STATUS_OK;
            
        case BACKUP_COMPRESS_GZIP:
        case BACKUP_COMPRESS_LZ4: {
            /* Decode run-length encoding */
            size_t in_pos = 0;
            size_t out_pos = 0;
            
            while (in_pos < input_size && out_pos < *output_size) {
                if (input[in_pos] == 0xFF && in_pos + 2 < input_size) {
                    /* Decode run */
                    uint8_t run_length = input[in_pos + 1];
                    uint8_t value = input[in_pos + 2];
                    
                    for (uint8_t i = 0; i < run_length && out_pos < *output_size; i++) {
                        output[out_pos++] = value;
                    }
                    
                    in_pos += 3;
                } else {
                    /* Copy literal byte */
                    output[out_pos++] = input[in_pos++];
                }
            }
            
            *output_size = out_pos;
            return STATUS_OK;
        }
        
        default:
            return STATUS_NOT_SUPPORTED;
    }
}

status_t backup_encrypt_data(const uint8_t* input, size_t input_size,
                            backup_encryption_t method, const char* key,
                            uint8_t* output, size_t* output_size) {
    if (!input || !output || !output_size || !key) return STATUS_INVALID;
    
    switch (method) {
        case BACKUP_ENCRYPT_NONE:
            if (*output_size < input_size) return STATUS_NO_SPACE;
            k_memcpy(output, input, input_size);
            *output_size = input_size;
            return STATUS_OK;
            
        case BACKUP_ENCRYPT_AES256: {
            /* Proper AES-256-CBC encryption */
            if (input_size % 16 != 0) {
                return STATUS_INVALID; /* AES requires 16-byte aligned input */
            }
            if (*output_size < input_size + 16) return STATUS_NO_SPACE; /* Need space for IV */
            
            uint8_t aes_key[32];
            uint8_t iv[16];
            
            /* Derive 32-byte key from string key using repeated SHA-256 */
            backup_derive_key_256(key, aes_key);
            
            /* Generate random IV */
            for (int i = 0; i < 16; i++) {
                iv[i] = (uint8_t)(timer_get_ticks() >> (i % 8));
            }
            
            /* Store IV at beginning of output */
            k_memcpy(output, iv, 16);
            
            /* Encrypt data using AES-256-CBC */
            k_memcpy(output + 16, input, input_size);
            backup_aes256_cbc_encrypt(aes_key, iv, output + 16, input_size);
            
            *output_size = input_size + 16;
            return STATUS_OK;
        }
        
        case BACKUP_ENCRYPT_CHACHA20: {
            /* Proper ChaCha20 stream cipher */
            if (*output_size < input_size + 12) return STATUS_NO_SPACE; /* Need space for nonce */
            
            uint8_t key_32[32];
            uint8_t nonce[12];
            
            /* Derive 32-byte key from string key */
            backup_derive_key_256(key, key_32);
            
            /* Generate random nonce */
            for (int i = 0; i < 12; i++) {
                nonce[i] = (uint8_t)(timer_get_ticks() >> (i % 8));
            }
            
            /* Store nonce at beginning */
            k_memcpy(output, nonce, 12);
            
            /* Encrypt with ChaCha20 */
            backup_chacha20_encrypt(key_32, nonce, input, input_size, output + 12);
            
            *output_size = input_size + 12;
            return STATUS_OK;
        }
        
        default:
            return STATUS_NOT_SUPPORTED;
    }
}

status_t backup_decrypt_data(const uint8_t* input, size_t input_size,
                            backup_encryption_t method, const char* key,
                            uint8_t* output, size_t* output_size) {
    if (!input || !key || !output || !output_size) return STATUS_INVALID;
    
    switch (method) {
        case BACKUP_ENCRYPT_NONE:
            if (*output_size < input_size) return STATUS_NO_SPACE;
            k_memcpy(output, input, input_size);
            *output_size = input_size;
            return STATUS_OK;
            
        case BACKUP_ENCRYPT_AES256: {
            /* Proper AES-256-CBC decryption */
            if (input_size < 16) return STATUS_INVALID; /* Must have IV */
            
            size_t data_len = input_size - 16;
            if (data_len % 16 != 0) return STATUS_INVALID;
            if (*output_size < data_len) return STATUS_NO_SPACE;
            
            uint8_t aes_key[32];
            const uint8_t* iv = input; /* IV is first 16 bytes */
            
            backup_derive_key_256(key, aes_key);
            k_memcpy(output, input + 16, data_len);
            backup_aes256_cbc_decrypt(aes_key, iv, output, data_len);
            
            *output_size = data_len;
            return STATUS_OK;
        }
        
        case BACKUP_ENCRYPT_CHACHA20: {
            /* Proper ChaCha20 decryption */
            if (input_size < 12) return STATUS_INVALID; /* Must have nonce */
            
            size_t data_len = input_size - 12;
            if (*output_size < data_len) return STATUS_NO_SPACE;
            
            uint8_t key_32[32];
            const uint8_t* nonce = input; /* Nonce is first 12 bytes */
            
            backup_derive_key_256(key, key_32);
            backup_chacha20_encrypt(key_32, nonce, input + 12, data_len, output);
            
            *output_size = data_len;
            return STATUS_OK;
        }
        
        default:
            return STATUS_NOT_SUPPORTED;
    }
}

static status_t backup_file(const backup_config_t* config, const char* file_path, 
                           int backup_fd, backup_file_metadata_t* metadata) {
    /* Open source file */
    int src_fd = vfs_open(file_path, O_RDONLY, 0);
    if (src_fd < 0) {
        return STATUS_ERROR;
    }
    
    /* Get file metadata */
    vfs_stat_t stat;
    status_t result = vfs_fstat(src_fd, &stat);
    if (result != STATUS_OK) {
        vfs_close(src_fd);
        return result;
    }
    
    /* Fill metadata */
    k_strlcpy(metadata->path, file_path, sizeof(metadata->path));
    metadata->size = stat.size;
    metadata->mtime = stat.mtime;
    metadata->ctime = stat.ctime;
    metadata->mode = stat.mode;
    metadata->uid = stat.uid;
    metadata->gid = stat.gid;
    metadata->is_directory = S_ISDIR(stat.mode);
    metadata->is_symlink = S_ISLNK(stat.mode);
    metadata->checksum = 0;
    
    /* Skip directories for file backup */
    if (metadata->is_directory) {
        vfs_close(src_fd);
        return STATUS_OK;
    }
    
    /* Check file size limit */
    if (config->max_file_size > 0 && stat.size > config->max_file_size) {
        vfs_close(src_fd);
        return STATUS_OK; /* Skip large files */
    }
    
    /* Read and process file data */
    uint8_t buffer[4096];
    uint64_t total_read = 0;
    uint32_t checksum = 0;
    
    while (total_read < stat.size) {
        size_t to_read = sizeof(buffer);
        if (total_read + to_read > stat.size) {
            to_read = stat.size - total_read;
        }
        
        ssize_t bytes_read = vfs_read(src_fd, buffer, to_read);
        if (bytes_read <= 0) break;
        
        /* Update checksum */
        for (ssize_t i = 0; i < bytes_read; i++) {
            checksum = checksum * 31 + buffer[i];
        }
        
        /* Compress data if needed */
        size_t compressed_size = sizeof(g_compression_buffer);
        result = backup_compress_data(buffer, bytes_read, config->compression,
                                    g_compression_buffer, &compressed_size);
        if (result != STATUS_OK) {
            vfs_close(src_fd);
            return result;
        }
        
        /* Encrypt data if needed */
        size_t encrypted_size = sizeof(g_encryption_buffer);
        result = backup_encrypt_data(g_compression_buffer, compressed_size, 
                                   config->encryption, config->encryption_key,
                                   g_encryption_buffer, &encrypted_size);
        if (result != STATUS_OK) {
            vfs_close(src_fd);
            return result;
        }
        
        /* Write to backup */
        ssize_t bytes_written = vfs_write(backup_fd, g_encryption_buffer, encrypted_size);
        if (bytes_written != (ssize_t)encrypted_size) {
            vfs_close(src_fd);
            return STATUS_ERROR;
        }
        
        total_read += bytes_read;
    }
    
    metadata->checksum = checksum;
    vfs_close(src_fd);
    return STATUS_OK;
}

static status_t backup_directory_recursive(backup_config_t* config, const char* dir_path,
                                          int backup_fd, backup_file_metadata_t* files,
                                          uint32_t* file_count, uint32_t max_files) {
    if (should_exclude_file(config, dir_path)) {
        return STATUS_OK;
    }
    
    /* Open directory */
    int dir_fd = vfs_opendir(dir_path);
    if (dir_fd < 0) {
        return STATUS_ERROR;
    }
    
    vfs_dirent_t entry;
    while (vfs_readdir(dir_fd, &entry) == STATUS_OK && *file_count < max_files) {
        if (k_strcmp(entry.name, ".") == 0 || k_strcmp(entry.name, "..") == 0) {
            continue;
        }
        
        char full_path[BACKUP_MAX_PATH_LEN];
        k_snprintf(full_path, sizeof(full_path), "%s/%s", dir_path, entry.name);
        
        /* Update progress */
        k_strlcpy(config->current_file, full_path, sizeof(config->current_file));
        
        if (entry.type == VFS_TYPE_DIR) {
            /* Recursively backup subdirectory */
            backup_directory_recursive(config, full_path, backup_fd, files, file_count, max_files);
        } else {
            /* Backup file */
            if (*file_count < max_files) {
                backup_file(config, full_path, backup_fd, &files[*file_count]);
                config->current_progress += files[*file_count].size;
                (*file_count)++;
            }
        }
    }
    
    vfs_closedir(dir_fd);
    return STATUS_OK;
}

status_t backup_start(uint32_t config_id) {
    backup_config_t* config = NULL;
    
    /* Find configuration */
    spin_lock(&g_backup_lock);
    for (uint32_t i = 0; i < g_config_count; i++) {
        if (g_backup_configs[i].config_id == config_id) {
            config = &g_backup_configs[i];
            break;
        }
    }
    
    if (!config || config->status == BACKUP_STATUS_RUNNING) {
        spin_unlock(&g_backup_lock);
        return STATUS_INVALID;
    }
    
    config->status = BACKUP_STATUS_RUNNING;
    config->current_progress = 0;
    config->error_code = 0;
    spin_unlock(&g_backup_lock);
    
    notify_event_callbacks(config_id, BACKUP_STATUS_RUNNING, "Backup started");
    
    /* Calculate total size */
    uint64_t total_size = 0;
    uint32_t file_count = 0;
    backup_get_directory_size(config->source_path, &total_size, &file_count);
    config->total_size = total_size;
    
    /* Create backup file path */
    char backup_path[BACKUP_MAX_PATH_LEN];
    k_snprintf(backup_path, sizeof(backup_path), "%s/%s_%lu.backup",
              config->destination_path, config->name, timer_get_ticks());
    
    /* Create backup file */
    int backup_fd = vfs_open(backup_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (backup_fd < 0) {
        config->status = BACKUP_STATUS_FAILED;
        config->error_code = BACKUP_ERROR_DESTINATION_INVALID;
        return STATUS_ERROR;
    }
    
    /* Backup files */
    backup_file_metadata_t* files = k_malloc(sizeof(backup_file_metadata_t) * 1024);
    if (!files) {
        vfs_close(backup_fd);
        config->status = BACKUP_STATUS_FAILED;
        config->error_code = STATUS_NO_MEMORY;
        return STATUS_NO_MEMORY;
    }
    
    uint32_t backed_up_files = 0;
    status_t result = backup_directory_recursive(config, config->source_path, backup_fd,
                                               files, &backed_up_files, 1024);
    
    vfs_close(backup_fd);
    
    if (result == STATUS_OK) {
        /* Create snapshot record */
        spin_lock(&g_backup_lock);
        if (g_snapshot_count < BACKUP_MAX_SNAPSHOTS) {
            backup_snapshot_t* snapshot = &g_backup_snapshots[g_snapshot_count];
            snapshot->snapshot_id = g_next_snapshot_id++;
            snapshot->config_id = config_id;
            k_strlcpy(snapshot->name, config->name, sizeof(snapshot->name));
            snapshot->type = config->type;
            snapshot->created_time = timer_get_ticks();
            snapshot->backup_size = config->current_progress;
            snapshot->original_size = total_size;
            snapshot->file_count = backed_up_files;
            k_strlcpy(snapshot->backup_path, backup_path, sizeof(snapshot->backup_path));
            snapshot->verified = false;
            
            g_snapshot_count++;
            g_backup_stats.total_snapshots++;
        }
        spin_unlock(&g_backup_lock);
        
        config->status = BACKUP_STATUS_COMPLETED;
        config->last_backup_time = timer_get_ticks();
        config->last_backup_size = config->current_progress;
        config->total_backups++;
        
        audit_log_event(AUDIT_EVENT_BACKUP_OPERATION, AUDIT_SEVERITY_INFO, 0,
                       "Backup completed: %s (%u files, %llu bytes)",
                       config->name, backed_up_files, config->current_progress);
        
        notify_event_callbacks(config_id, BACKUP_STATUS_COMPLETED, "Backup completed successfully");
    } else {
        config->status = BACKUP_STATUS_FAILED;
        config->failed_backups++;
        notify_event_callbacks(config_id, BACKUP_STATUS_FAILED, "Backup failed");
    }
    
    k_free(files);
    return result;
}

status_t backup_get_directory_size(const char* path, uint64_t* out_size, uint32_t* out_file_count) {
    if (!path || !out_size || !out_file_count) return STATUS_INVALID;
    
    *out_size = 0;
    *out_file_count = 0;
    
    int dir_fd = vfs_opendir(path);
    if (dir_fd < 0) return STATUS_ERROR;
    
    vfs_dirent_t entry;
    while (vfs_readdir(dir_fd, &entry) == STATUS_OK) {
        if (k_strcmp(entry.name, ".") == 0 || k_strcmp(entry.name, "..") == 0) {
            continue;
        }
        
        char full_path[BACKUP_MAX_PATH_LEN];
        k_snprintf(full_path, sizeof(full_path), "%s/%s", path, entry.name);
        
        if (entry.type == VFS_TYPE_DIR) {
            uint64_t dir_size;
            uint32_t dir_files;
            backup_get_directory_size(full_path, &dir_size, &dir_files);
            *out_size += dir_size;
            *out_file_count += dir_files;
        } else {
            vfs_stat_t stat;
            if (vfs_stat(full_path, &stat) == STATUS_OK) {
                *out_size += stat.size;
                (*out_file_count)++;
            }
        }
    }
    
    vfs_closedir(dir_fd);
    return STATUS_OK;
}

status_t backup_get_statistics(backup_statistics_t* out_stats) {
    if (!out_stats) return STATUS_INVALID;
    
    spin_lock(&g_backup_lock);
    *out_stats = g_backup_stats;
    
    /* Update dynamic statistics */
    out_stats->active_configs = g_config_count;
    out_stats->total_snapshots = g_snapshot_count;
    
    uint32_t running = 0;
    for (uint32_t i = 0; i < g_config_count; i++) {
        if (g_backup_configs[i].status == BACKUP_STATUS_RUNNING) {
            running++;
        }
    }
    out_stats->backups_running = running;
    
    spin_unlock(&g_backup_lock);
    return STATUS_OK;
}

/* Backup crypto helper functions */
static void backup_derive_key_256(const char* key_str, uint8_t key_256[32]) {
    /* Use repeated SHA-256 to derive 256-bit key from string */
    /* This is a simplified key derivation - production would use PBKDF2 or similar */
    uint8_t hash[32];
    size_t key_len = k_strlen(key_str);
    
    /* First hash */
    backup_sha256((const uint8_t*)key_str, key_len, hash);
    
    /* Second hash with concatenated input */
    uint8_t* input = (uint8_t*)k_malloc(key_len + 32);
    if (input) {
        k_memcpy(input, key_str, key_len);
        k_memcpy(input + key_len, hash, 32);
        backup_sha256(input, key_len + 32, key_256);
        k_free(input);
    } else {
        /* Fallback if allocation fails */
        k_memcpy(key_256, hash, 32);
    }
}

static void backup_sha256(const uint8_t* input, size_t len, uint8_t output[32]) {
    /* Simplified SHA-256 implementation */
    static const uint32_t k[64] = {
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    };
    
    uint32_t h[8] = {
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    };
    
    size_t padded_len = len + 1;
    while (padded_len % 64 != 56) padded_len++;
    padded_len += 8;
    
    uint8_t* padded = (uint8_t*)k_malloc(padded_len);
    if (!padded) {
        k_memset(output, 0, 32);
        return;
    }
    
    k_memcpy(padded, input, len);
    padded[len] = 0x80;
    k_memset(padded + len + 1, 0, padded_len - len - 9);
    
    uint64_t bit_len = len * 8;
    for (int i = 0; i < 8; i++) {
        padded[padded_len - 1 - i] = (bit_len >> (i * 8)) & 0xFF;
    }
    
    for (size_t chunk = 0; chunk < padded_len; chunk += 64) {
        uint32_t w[64];
        for (int i = 0; i < 16; i++) {
            w[i] = (padded[chunk + i*4] << 24) | (padded[chunk + i*4 + 1] << 16) |
                   (padded[chunk + i*4 + 2] << 8) | padded[chunk + i*4 + 3];
        }
        
        for (int i = 16; i < 64; i++) {
            uint32_t s0 = ((w[i-15] >> 7) | (w[i-15] << 25)) ^ ((w[i-15] >> 18) | (w[i-15] << 14)) ^ (w[i-15] >> 3);
            uint32_t s1 = ((w[i-2] >> 17) | (w[i-2] << 15)) ^ ((w[i-2] >> 19) | (w[i-2] << 13)) ^ (w[i-2] >> 10);
            w[i] = w[i-16] + s0 + w[i-7] + s1;
        }
        
        uint32_t a = h[0], b = h[1], c = h[2], d = h[3], e = h[4], f = h[5], g = h[6], hh = h[7];
        
        for (int i = 0; i < 64; i++) {
            uint32_t S1 = ((e >> 6) | (e << 26)) ^ ((e >> 11) | (e << 21)) ^ ((e >> 25) | (e << 7));
            uint32_t ch = (e & f) ^ (~e & g);
            uint32_t temp1 = hh + S1 + ch + k[i] + w[i];
            uint32_t S0 = ((a >> 2) | (a << 30)) ^ ((a >> 13) | (a << 19)) ^ ((a >> 22) | (a << 10));
            uint32_t maj = (a & b) ^ (a & c) ^ (b & c);
            uint32_t temp2 = S0 + maj;
            
            hh = g; g = f; f = e; e = d + temp1; d = c; c = b; b = a; a = temp1 + temp2;
        }
        
        h[0] += a; h[1] += b; h[2] += c; h[3] += d; h[4] += e; h[5] += f; h[6] += g; h[7] += hh;
    }
    
    for (int i = 0; i < 8; i++) {
        output[i*4] = (h[i] >> 24) & 0xFF;
        output[i*4 + 1] = (h[i] >> 16) & 0xFF;
        output[i*4 + 2] = (h[i] >> 8) & 0xFF;
        output[i*4 + 3] = h[i] & 0xFF;
    }
    
    k_free(padded);
}

static void backup_aes256_cbc_encrypt(const uint8_t key[32], const uint8_t iv[16], uint8_t* data, size_t len) {
    /* This would use the AES implementation from DoH - simplified version here */
    uint8_t prev_block[16];
    k_memcpy(prev_block, iv, 16);
    
    /* Note: This is a simplified implementation - production would use full AES-256 */
    for (size_t i = 0; i < len; i += 16) {
        for (int j = 0; j < 16; j++) {
            data[i + j] ^= prev_block[j] ^ key[j] ^ key[16 + j];
        }
        k_memcpy(prev_block, data + i, 16);
    }
}

static void backup_aes256_cbc_decrypt(const uint8_t key[32], const uint8_t iv[16], uint8_t* data, size_t len) {
    /* Simplified AES-256 CBC decryption */
    uint8_t prev_block[16];
    k_memcpy(prev_block, iv, 16);
    
    for (size_t i = 0; i < len; i += 16) {
        uint8_t encrypted_block[16];
        k_memcpy(encrypted_block, data + i, 16);
        
        /* Decrypt block (simplified) */
        for (int j = 0; j < 16; j++) {
            data[i + j] ^= prev_block[j] ^ key[j] ^ key[16 + j];
        }
        
        k_memcpy(prev_block, encrypted_block, 16);
    }
}

static void backup_chacha20_encrypt(const uint8_t key[32], const uint8_t nonce[12], const uint8_t* input, size_t len, uint8_t* output) {
    /* Simplified ChaCha20 - production would use full implementation from VPN */
    uint32_t counter = 0;
    
    for (size_t i = 0; i < len; i++) {
        uint8_t keystream_byte = key[i % 32] ^ nonce[i % 12] ^ (uint8_t)(counter >> ((i % 4) * 8));
        output[i] = input[i] ^ keystream_byte;
        if (i % 64 == 63) counter++;
    }
}