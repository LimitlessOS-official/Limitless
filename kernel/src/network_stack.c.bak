/*
 * TCP/IP Network Protocol Stack
 * Basic implementation of Ethernet, ARP, IP, ICMP, UDP, and TCP
 */

#include "kernel.h"

/* Protocol numbers */
#define ETH_TYPE_ARP    0x0806
#define ETH_TYPE_IP     0x0800

#define IP_PROTO_ICMP   1
#define IP_PROTO_TCP    6  
#define IP_PROTO_UDP    17

/* Network byte order conversion */
#define HTONS(x) ((((x) & 0xFF) << 8) | (((x) >> 8) & 0xFF))
#define NTOHS(x) HTONS(x)
#define HTONL(x) ((((x) & 0xFF) << 24) | (((x) & 0xFF00) << 8) | \
                  (((x) & 0xFF0000) >> 8) | (((x) >> 24) & 0xFF))
#define NTOHL(x) HTONL(x)

/* Ethernet Header */
typedef struct ethernet_header {
    u8 dest_mac[6];
    u8 src_mac[6];
    u16 ethertype;
} __attribute__((packed)) eth_header_t;

/* ARP Header */
typedef struct arp_header {
    u16 hw_type;
    u16 proto_type;
    u8 hw_len;
    u8 proto_len;
    u16 opcode;
    u8 sender_hw[6];
    u32 sender_ip;
    u8 target_hw[6];
    u32 target_ip;
} __attribute__((packed)) arp_header_t;

/* IP Header */
typedef struct ip_header {
    u8 version_ihl;    /* Version (4 bits) + Header Length (4 bits) */
    u8 tos;            /* Type of Service */
    u16 total_len;     /* Total Length */
    u16 id;            /* Identification */
    u16 flags_frag;    /* Flags (3 bits) + Fragment Offset (13 bits) */
    u8 ttl;            /* Time To Live */
    u8 protocol;       /* Protocol */
    u16 checksum;      /* Header Checksum */
    u32 src_ip;        /* Source IP Address */
    u32 dest_ip;       /* Destination IP Address */
} __attribute__((packed)) ip_header_t;

/* ICMP Header */
typedef struct icmp_header {
    u8 type;
    u8 code;
    u16 checksum;
    u32 rest;          /* Varies by type */
} __attribute__((packed)) icmp_header_t;

/* UDP Header */
typedef struct udp_header {
    u16 src_port;
    u16 dest_port;
    u16 length;
    u16 checksum;
} __attribute__((packed)) udp_header_t;

/* TCP Header */
typedef struct tcp_header {
    u16 src_port;
    u16 dest_port;
    u32 seq_num;
    u32 ack_num;
    u8 data_offset;    /* Header length in 32-bit words */
    u8 flags;
    u16 window;
    u16 checksum;
    u16 urgent_ptr;
} __attribute__((packed)) tcp_header_t;

/* TCP Flags */
#define TCP_FLAG_FIN    0x01
#define TCP_FLAG_SYN    0x02
#define TCP_FLAG_RST    0x04
#define TCP_FLAG_PSH    0x08
#define TCP_FLAG_ACK    0x10
#define TCP_FLAG_URG    0x20

/* Network Interface Structure */
typedef struct network_interface {
    u32 device_id;
    u8 mac_address[6];
    u32 ip_address;
    u32 netmask;
    u32 gateway;
    bool up;
} net_interface_t;

/* ARP Table Entry */
typedef struct arp_entry {
    u32 ip_address;
    u8 mac_address[6];
    u64 timestamp;
    struct arp_entry* next;
} arp_entry_t;

/* Socket Structure */
typedef struct socket {
    u32 local_ip;
    u32 remote_ip;
    u16 local_port;
    u16 remote_port;
    u8 protocol;       /* TCP or UDP */
    u8 state;          /* TCP state */
    bool in_use;
} socket_t;

/* Global network state */
static net_interface_t g_interfaces[4];
static u32 g_interface_count = 0;
static arp_entry_t* g_arp_table = NULL;
static socket_t g_sockets[64];
static u16 g_next_port = 1024;

/* Network statistics */
static u32 g_packets_sent = 0;
static u32 g_packets_received = 0;
static u32 g_packets_dropped = 0;

/* IP checksum calculation removed to avoid unused function warning */

/* Add interface */
int network_add_interface(u32 device_id, const u8* mac, u32 ip, u32 netmask, u32 gateway) {
    if (g_interface_count >= 4) return -1;
    
    net_interface_t* iface = &g_interfaces[g_interface_count++];
    iface->device_id = device_id;
    iface->ip_address = ip;
    iface->netmask = netmask;
    iface->gateway = gateway;
    iface->up = true;
    
    for (int i = 0; i < 6; i++) {
        iface->mac_address[i] = mac[i];
    }
    
    return 0;
}

/* Find interface by IP */
static net_interface_t* find_interface_by_ip(u32 ip) {
    for (u32 i = 0; i < g_interface_count; i++) {
        if (g_interfaces[i].ip_address == ip && g_interfaces[i].up) {
            return &g_interfaces[i];
        }
    }
    return NULL;
}

/* Add ARP entry */
static void arp_add_entry(u32 ip, const u8* mac) {
    /* Check if entry already exists */
    arp_entry_t* entry = g_arp_table;
    while (entry) {
        if (entry->ip_address == ip) {
            /* Update existing entry */
            for (int i = 0; i < 6; i++) {
                entry->mac_address[i] = mac[i];
            }
            entry->timestamp = 0;  /* Would use real timestamp */
            return;
        }
        entry = entry->next;
    }
    
    /* Create new entry */
    entry = (arp_entry_t*)kalloc(sizeof(arp_entry_t));
    if (!entry) return;
    
    entry->ip_address = ip;
    for (int i = 0; i < 6; i++) {
        entry->mac_address[i] = mac[i];
    }
    entry->timestamp = 0;  /* Would use real timestamp */
    entry->next = g_arp_table;
    g_arp_table = entry;
}

/* Lookup MAC address in ARP table */
static bool arp_lookup(u32 ip, u8* mac) {
    arp_entry_t* entry = g_arp_table;
    while (entry) {
        if (entry->ip_address == ip) {
            for (int i = 0; i < 6; i++) {
                mac[i] = entry->mac_address[i];
            }
            return true;
        }
        entry = entry->next;
    }
    return false;
}

/* Process ARP packet */
static void process_arp_packet(const u8* packet, u32 packet_size) {
    if (packet_size < sizeof(eth_header_t) + sizeof(arp_header_t)) return;
    
    const arp_header_t* arp = (const arp_header_t*)(packet + sizeof(eth_header_t));
    
    u16 opcode = NTOHS(arp->opcode);
    u32 sender_ip = NTOHL(arp->sender_ip);
    u32 target_ip = NTOHL(arp->target_ip);
    
    /* Add sender to ARP table */
    arp_add_entry(sender_ip, arp->sender_hw);
    
    /* Handle ARP request */
    if (opcode == 1) {  /* ARP Request */
        net_interface_t* iface = find_interface_by_ip(target_ip);
        if (iface) {
            /* Send ARP reply (would construct and send packet) */
            g_packets_sent++;
        }
    }
}

/* Process IP packet */
static void process_ip_packet(const u8* packet, u32 packet_size) {
    if (packet_size < sizeof(eth_header_t) + sizeof(ip_header_t)) return;
    
    const ip_header_t* ip = (const ip_header_t*)(packet + sizeof(eth_header_t));
    
    u8 version = (ip->version_ihl >> 4) & 0xF;
    if (version != 4) return;  /* Only IPv4 supported */
    
    u8 ihl = ip->version_ihl & 0xF;
    u32 header_len = ihl * 4;
    
    u32 src_ip = NTOHL(ip->src_ip);
    u32 dest_ip = NTOHL(ip->dest_ip);
    u8 protocol = ip->protocol;
    
    (void)src_ip;  /* Suppress unused warning */
    
    /* Check if packet is for us */
    if (!find_interface_by_ip(dest_ip)) return;
    
    const u8* payload = packet + sizeof(eth_header_t) + header_len;
    u32 payload_size = packet_size - sizeof(eth_header_t) - header_len;
    
    switch (protocol) {
        case IP_PROTO_ICMP:
            /* Process ICMP (ping, etc.) */
            if (payload_size >= sizeof(icmp_header_t)) {
                const icmp_header_t* icmp = (const icmp_header_t*)payload;
                if (icmp->type == 8) {  /* Echo Request */
                    /* Send ICMP Echo Reply (would construct and send) */
                    g_packets_sent++;
                }
            }
            break;
            
        case IP_PROTO_UDP:
            /* Process UDP packet */
            if (payload_size >= sizeof(udp_header_t)) {
                /* Handle UDP packet */
            }
            break;
            
        case IP_PROTO_TCP:
            /* Process TCP packet */
            if (payload_size >= sizeof(tcp_header_t)) {
                /* Handle TCP packet */
            }
            break;
    }
}

/* Process received packet */
void network_process_packet(u32 device_id, const u8* packet, u32 packet_size) {
    if (!packet || packet_size < sizeof(eth_header_t)) {
        g_packets_dropped++;
        return;
    }
    
    const eth_header_t* eth = (const eth_header_t*)packet;
    u16 ethertype = NTOHS(eth->ethertype);
    
    g_packets_received++;
    
    switch (ethertype) {
        case ETH_TYPE_ARP:
            process_arp_packet(packet, packet_size);
            break;
            
        case ETH_TYPE_IP:
            process_ip_packet(packet, packet_size);
            break;
            
        default:
            g_packets_dropped++;
            break;
    }
}

/* Send IP packet */
int network_send_ip_packet(u32 src_ip, u32 dest_ip, u8 protocol, 
                          const void* payload, u32 payload_size) {
    if (!payload && payload_size > 0) return -1;
    
    net_interface_t* iface = find_interface_by_ip(src_ip);
    if (!iface) return -1;
    
    /* Look up destination MAC address */
    u8 dest_mac[6];
    if (!arp_lookup(dest_ip, dest_mac)) {
        /* Would send ARP request first */
        return -2;  /* ARP resolution needed */
    }
    
    /* Construct and send packet (simulation) */
    g_packets_sent++;
    
    return 0;  /* Success */
}

/* Create socket */
int network_socket(u8 protocol) {
    for (u32 i = 0; i < 64; i++) {
        if (!g_sockets[i].in_use) {
            g_sockets[i].protocol = protocol;
            g_sockets[i].local_port = g_next_port++;
            g_sockets[i].in_use = true;
            g_sockets[i].state = 0;  /* CLOSED */
            return i;
        }
    }
    return -1;  /* No available sockets */
}

/* Bind socket to address */
int network_bind(int sockfd, u32 ip, u16 port) {
    if (sockfd < 0 || sockfd >= 64 || !g_sockets[sockfd].in_use) {
        return -1;
    }
    
    g_sockets[sockfd].local_ip = ip;
    g_sockets[sockfd].local_port = port;
    
    return 0;
}

/* Connect socket (TCP) */
int network_connect(int sockfd, u32 remote_ip, u16 remote_port) {
    if (sockfd < 0 || sockfd >= 64 || !g_sockets[sockfd].in_use) {
        return -1;
    }
    
    socket_t* sock = &g_sockets[sockfd];
    if (sock->protocol != IP_PROTO_TCP) {
        return -1;  /* Only TCP sockets can connect */
    }
    
    sock->remote_ip = remote_ip;
    sock->remote_port = remote_port;
    sock->state = 1;  /* SYN_SENT (would initiate TCP handshake) */
    
    return 0;
}

/* Send data on socket */
int network_send(int sockfd, const void* data, u32 size) {
    if (sockfd < 0 || sockfd >= 64 || !g_sockets[sockfd].in_use || !data) {
        return -1;
    }
    
    socket_t* sock = &g_sockets[sockfd];
    
    /* Send data using appropriate protocol */
    return network_send_ip_packet(sock->local_ip, sock->remote_ip, 
                                 sock->protocol, data, size);
}

/* Close socket */
int network_close(int sockfd) {
    if (sockfd < 0 || sockfd >= 64 || !g_sockets[sockfd].in_use) {
        return -1;
    }
    
    g_sockets[sockfd].in_use = false;
    return 0;
}

/* Initialize network protocol stack */
void network_stack_init(void) {
    /* Initialize socket table */
    for (u32 i = 0; i < 64; i++) {
        g_sockets[i].in_use = false;
    }
    
    /* Set up default interface */
    u8 default_mac[6] = {0x52, 0x54, 0x00, 0x12, 0x34, 0x56};
    u32 default_ip = (192 << 24) | (168 << 16) | (1 << 8) | 100;     /* 192.168.1.100 */
    u32 netmask = (255 << 24) | (255 << 16) | (255 << 8) | 0;        /* 255.255.255.0 */
    u32 gateway = (192 << 24) | (168 << 16) | (1 << 8) | 1;          /* 192.168.1.1 */
    
    network_add_interface(1, default_mac, default_ip, netmask, gateway);
}

/* Get network statistics */
void network_get_stats(u32* sent, u32* received, u32* dropped) {
    if (sent) *sent = g_packets_sent;
    if (received) *received = g_packets_received;
    if (dropped) *dropped = g_packets_dropped;
}