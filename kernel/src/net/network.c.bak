/*
 * LimitlessOS TCP/IP Network Stack Implementation
 * Complete implementation with Ethernet, ARP, IP, ICMP, UDP, TCP
 */
#include "kernel.h"
#include "microkernel.h"
#include "net.h"
#include "log.h"
#include "vmm.h"
#include "hal.h"

#define MAX_INTERFACES 4
#define ARP_TABLE_SIZE 256
#define SOCKET_TABLE_SIZE 1024

/* Network byte order conversion */
uint16_t htons(uint16_t n) { return (uint16_t)((n << 8) | (n >> 8)); }
uint32_t htonl(uint32_t n) { return __builtin_bswap32(n); }
uint16_t ntohs(uint16_t n) { return htons(n); }
uint32_t ntohl(uint32_t n) { return htonl(n); }

/* IP checksum calculation */
uint16_t ip_checksum(const void* data, size_t len) {
    const uint16_t* ptr = (const uint16_t*)data;
    uint32_t sum = 0;
    
    /* Sum all 16-bit words */
    while (len > 1) {
        sum += *ptr++;
        len -= 2;
    }
    
    /* Add left-over byte, if any */
    if (len > 0) {
        sum += *(const uint8_t*)ptr;
    }
    
    /* Fold 32-bit sum to 16 bits */
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    
    return (uint16_t)~sum;
}

/* Global network state */
static struct {
    net_interface_t* interfaces[MAX_INTERFACES];
    int interface_count;
    
    struct {
        ipv4_addr_t ip;
        mac_addr_t mac;
        uint64_t timestamp;
        bool valid;
    } arp_table[ARP_TABLE_SIZE];
    
    socket_t* sockets[SOCKET_TABLE_SIZE];
    int socket_count;
    
    net_stats_t stats;
    bool initialized;
} g_net_state = {0};

/* Network initialization */
status_t net_init(void) {
    if (g_net_state.initialized) {
        return STATUS_OK;
    }
    
    k_memset(&g_net_state, 0, sizeof(g_net_state));
    g_net_state.initialized = true;
    
    KLOG_INFO("net", "Network stack initialized");
    return STATUS_OK;
}

void net_shutdown(void) {
    for (int i = 0; i < g_net_state.interface_count; i++) {
        if (g_net_state.interfaces[i]) {
            net_interface_down(g_net_state.interfaces[i]);
        }
    }
    g_net_state.initialized = false;
    KLOG_INFO("net", "Network stack shutdown");
}

status_t net_register_interface(net_interface_t* iface) {
    if (!iface || g_net_state.interface_count >= MAX_INTERFACES) {
        return STATUS_ERROR;
    }
    
    iface->id = g_net_state.interface_count;
    g_net_state.interfaces[g_net_state.interface_count++] = iface;
    
    KLOG_INFO("net", "Registered network interface %d", iface->id);
    return STATUS_OK;
}

net_interface_t* net_get_interface(uint8_t id) {
    if (id >= g_net_state.interface_count) {
        return NULL;
    }
    return g_net_state.interfaces[id];
}
/* Interface management */
status_t net_interface_up(net_interface_t* iface) {
    if (!iface) return STATUS_ERROR;
    
    iface->flags |= NET_IF_UP;
    KLOG_INFO("net", "Interface %d is up", iface->id);
    return STATUS_OK;
}

status_t net_interface_down(net_interface_t* iface) {
    if (!iface) return STATUS_ERROR;
    
    iface->flags &= ~NET_IF_UP;
    KLOG_INFO("net", "Interface %d is down", iface->id);
    return STATUS_OK;
}

/* Ethernet packet transmission */
status_t eth_send_packet(net_interface_t* iface, const mac_addr_t* dst, uint16_t ethertype, const void* payload, size_t len) {
    if (!iface || !dst || !payload || !(iface->flags & NET_IF_UP)) {
        return STATUS_ERROR;
    }
    
    /* Allocate buffer for ethernet frame */
    size_t frame_len = sizeof(eth_header_t) + len;
    uint8_t* frame = (uint8_t*)vmm_kmalloc(frame_len, 16);
    if (!frame) {
        return STATUS_NOMEM;
    }
    
    /* Build ethernet header */
    eth_header_t* eth_hdr = (eth_header_t*)frame;
    k_memcpy(&eth_hdr->dst, dst, sizeof(mac_addr_t));
    k_memcpy(&eth_hdr->src, &iface->mac, sizeof(mac_addr_t));
    eth_hdr->ethertype = htons(ethertype);
    
    /* Copy payload */
    k_memcpy(frame + sizeof(eth_header_t), payload, len);
    
    /* Send via driver */
    status_t result = STATUS_OK;
    if (iface->ops && iface->ops->send) {
        result = iface->ops->send(iface, frame, frame_len);
    }
    
    vmm_kfree(frame, frame_len);
    
    if (result == STATUS_OK) {
        g_net_state.stats.tx_packets++;
        g_net_state.stats.tx_bytes += frame_len;
    }
    
    return result;
}

/* ARP table management */
static uint32_t arp_hash(const ipv4_addr_t* ip) {
    return (ip->addr[0] ^ ip->addr[1] ^ ip->addr[2] ^ ip->addr[3]) % ARP_TABLE_SIZE;
}

status_t arp_add_entry(const ipv4_addr_t* ip, const mac_addr_t* mac) {
    if (!ip || !mac) return STATUS_ERROR;
    
    uint32_t hash = arp_hash(ip);
    
    /* Find empty slot or replace existing */
    for (int i = 0; i < 8; i++) {
        uint32_t idx = (hash + i) % ARP_TABLE_SIZE;
        
        if (!g_net_state.arp_table[idx].valid ||
            k_memcmp(&g_net_state.arp_table[idx].ip, ip, sizeof(ipv4_addr_t)) == 0) {
            
            k_memcpy(&g_net_state.arp_table[idx].ip, ip, sizeof(ipv4_addr_t));
            k_memcpy(&g_net_state.arp_table[idx].mac, mac, sizeof(mac_addr_t));
            g_net_state.arp_table[idx].timestamp = hal_timer_ticks();
            g_net_state.arp_table[idx].valid = true;
            
            return STATUS_OK;
        }
    }
    
    return STATUS_ERROR;
}

status_t arp_lookup(const ipv4_addr_t* ip, mac_addr_t* mac) {
    if (!ip || !mac) return STATUS_ERROR;
    
    uint32_t hash = arp_hash(ip);
    
    for (int i = 0; i < 8; i++) {
        uint32_t idx = (hash + i) % ARP_TABLE_SIZE;
        
        if (g_net_state.arp_table[idx].valid &&
            k_memcmp(&g_net_state.arp_table[idx].ip, ip, sizeof(ipv4_addr_t)) == 0) {
            
            k_memcpy(mac, &g_net_state.arp_table[idx].mac, sizeof(mac_addr_t));
            return STATUS_OK;
        }
    }
    
    return STATUS_NOTFOUND;
}

status_t arp_request(net_interface_t* iface, const ipv4_addr_t* target) {
    if (!iface || !target) return STATUS_ERROR;
    
    /* Build ARP request */
    arp_packet_t arp_pkt = {
        .hw_type = htons(ARP_HW_ETHERNET),
        .proto_type = htons(ETHERTYPE_IP),
        .hw_len = 6,
        .proto_len = 4,
        .opcode = htons(ARP_OP_REQUEST),
        .sender_ip = iface->ip,
        .target_ip = *target
    };
    
    k_memcpy(&arp_pkt.sender_mac, &iface->mac, sizeof(mac_addr_t));
    k_memset(&arp_pkt.target_mac, 0, sizeof(mac_addr_t));
    
    /* Broadcast ARP request */
    mac_addr_t broadcast = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};
    
    return eth_send_packet(iface, &broadcast, ETHERTYPE_ARP, &arp_pkt, sizeof(arp_pkt));
}
/* IP packet transmission */
status_t ip_send_packet(net_interface_t* iface, const ipv4_addr_t* dst, uint8_t protocol, const void* payload, size_t len) {
    if (!iface || !dst || !payload || len > 1500) {
        return STATUS_ERROR;
    }
    
    /* Look up destination MAC address */
    mac_addr_t dst_mac;
    if (arp_lookup(dst, &dst_mac) != STATUS_OK) {
        /* Send ARP request and queue packet (simplified: just fail for now) */
        arp_request(iface, dst);
        return STATUS_ERROR;
    }
    
    /* Build IP header */
    size_t ip_len = sizeof(ipv4_header_t) + len;
    uint8_t* packet = (uint8_t*)vmm_kmalloc(ip_len, 16);
    if (!packet) {
        return STATUS_NOMEM;
    }
    
    ipv4_header_t* ip_hdr = (ipv4_header_t*)packet;
    ip_hdr->version_ihl = 0x45;  /* IPv4, 20 byte header */
    ip_hdr->tos = 0;
    ip_hdr->total_length = htons(ip_len);
    ip_hdr->identification = htons(g_net_state.stats.tx_packets & 0xFFFF);
    ip_hdr->flags_fragment = 0;
    ip_hdr->ttl = 64;
    ip_hdr->protocol = protocol;
    ip_hdr->header_checksum = 0;
    ip_hdr->src_ip = iface->ip;
    ip_hdr->dst_ip = *dst;
    
    /* Calculate header checksum */
    ip_hdr->header_checksum = ip_checksum(ip_hdr, sizeof(ipv4_header_t));
    
    /* Copy payload */
    k_memcpy(packet + sizeof(ipv4_header_t), payload, len);
    
    /* Send ethernet frame */
    status_t result = eth_send_packet(iface, &dst_mac, ETHERTYPE_IP, packet, ip_len);
    
    vmm_kfree(packet, ip_len);
    return result;
}

/* ICMP implementation */
status_t icmp_send_echo_request(const ipv4_addr_t* dst, uint16_t id, uint16_t seq) {
    net_interface_t* iface = net_get_interface(0);  /* Use first interface */
    if (!iface || !dst) return STATUS_ERROR;
    
    icmp_header_t icmp_hdr = {
        .type = ICMP_TYPE_ECHO_REQUEST,
        .code = 0,
        .checksum = 0,
        .id = htons(id),
        .sequence = htons(seq)
    };
    
    icmp_hdr.checksum = ip_checksum(&icmp_hdr, sizeof(icmp_hdr));
    
    return ip_send_packet(iface, dst, IP_PROTO_ICMP, &icmp_hdr, sizeof(icmp_hdr));
}

status_t icmp_send_echo_reply(net_interface_t* iface, const ipv4_addr_t* dst, uint16_t id, uint16_t seq, const void* payload, size_t len) {
    if (!iface || !dst) return STATUS_ERROR;
    
    size_t icmp_len = sizeof(icmp_header_t) + len;
    uint8_t* icmp_packet = (uint8_t*)vmm_kmalloc(icmp_len, 16);
    if (!icmp_packet) return STATUS_NOMEM;
    
    icmp_header_t* icmp_hdr = (icmp_header_t*)icmp_packet;
    icmp_hdr->type = ICMP_TYPE_ECHO_REPLY;
    icmp_hdr->code = 0;
    icmp_hdr->checksum = 0;
    icmp_hdr->id = htons(id);
    icmp_hdr->sequence = htons(seq);
    
    if (payload && len > 0) {
        k_memcpy(icmp_packet + sizeof(icmp_header_t), payload, len);
    }
    
    icmp_hdr->checksum = ip_checksum(icmp_packet, icmp_len);
    
    status_t result = ip_send_packet(iface, dst, IP_PROTO_ICMP, icmp_packet, icmp_len);
    
    vmm_kfree(icmp_packet, icmp_len);
    return result;
}

/* Packet reception processing */
status_t net_receive_packet(net_interface_t* iface, const void* data, size_t len) {
    if (!iface || !data || len < sizeof(eth_header_t)) {
        return STATUS_ERROR;
    }
    
    g_net_state.stats.rx_packets++;
    g_net_state.stats.rx_bytes += len;
    
    const eth_header_t* eth_hdr = (const eth_header_t*)data;
    uint16_t ethertype = ntohs(eth_hdr->ethertype);
    
    const uint8_t* payload = (const uint8_t*)data + sizeof(eth_header_t);
    size_t payload_len = len - sizeof(eth_header_t);
    
    switch (ethertype) {
        case ETHERTYPE_ARP: {
            if (payload_len >= sizeof(arp_packet_t)) {
                const arp_packet_t* arp = (const arp_packet_t*)payload;
                if (ntohs(arp->opcode) == ARP_OP_REQUEST) {
                    /* Handle ARP request */
                    if (k_memcmp(&arp->target_ip, &iface->ip, sizeof(ipv4_addr_t)) == 0) {
                        /* This is for us - send ARP reply */
                        arp_add_entry(&arp->sender_ip, &arp->sender_mac);
                        
                        arp_packet_t reply = *arp;
                        reply.opcode = htons(ARP_OP_REPLY);
                        reply.target_mac = arp->sender_mac;
                        reply.target_ip = arp->sender_ip;
                        reply.sender_mac = iface->mac;
                        reply.sender_ip = iface->ip;
                        
                        eth_send_packet(iface, &arp->sender_mac, ETHERTYPE_ARP, &reply, sizeof(reply));
                    }
                } else if (ntohs(arp->opcode) == ARP_OP_REPLY) {
                    /* Handle ARP reply */
                    arp_add_entry(&arp->sender_ip, &arp->sender_mac);
                }
            }
            break;
        }
        
        case ETHERTYPE_IP: {
            if (payload_len >= sizeof(ipv4_header_t)) {
                const ipv4_header_t* ip_hdr = (const ipv4_header_t*)payload;
                
                /* Check if packet is for us */
                if (k_memcmp(&ip_hdr->dst_ip, &iface->ip, sizeof(ipv4_addr_t)) == 0) {
                    /* Handle IP packet */
                    const uint8_t* ip_payload = payload + sizeof(ipv4_header_t);
                    size_t ip_payload_len = ntohs(ip_hdr->total_length) - sizeof(ipv4_header_t);
                    
                    if (ip_hdr->protocol == IP_PROTO_ICMP && ip_payload_len >= sizeof(icmp_header_t)) {
                        const icmp_header_t* icmp = (const icmp_header_t*)ip_payload;
                        
                        if (icmp->type == ICMP_TYPE_ECHO_REQUEST) {
                            /* Respond to ping */
                            const void* icmp_payload = (ip_payload_len > sizeof(icmp_header_t)) ?
                                                     ip_payload + sizeof(icmp_header_t) : NULL;
                            size_t icmp_payload_size = (ip_payload_len > sizeof(icmp_header_t)) ?
                                                      ip_payload_len - sizeof(icmp_header_t) : 0;
                            
                            icmp_send_echo_reply(iface, &ip_hdr->src_ip, ntohs(icmp->id), 
                                               ntohs(icmp->sequence), icmp_payload, icmp_payload_size);
                        }
                    } else if (ip_hdr->protocol == IP_PROTO_TCP && ip_payload_len >= sizeof(tcp_header_t)) {
                        /* Handle TCP packet */
                        tcp_handle_incoming(ip_hdr->src_ip, ip_hdr->dst_ip, ip_payload, ip_payload_len);
                    } else if (ip_hdr->protocol == IP_PROTO_UDP && ip_payload_len >= sizeof(udp_header_t)) {
                        /* Handle UDP packet */
                        /* TODO: Implement UDP packet handling */
                    }
                }
            }
            break;
        }
    }
    
    return STATUS_OK;
}
/* Socket management implementation */
status_t net_socket_create(socket_type_t type, uint8_t protocol, socket_t** out) {
    if (!out) return STATUS_ERROR;
    
    /* Find free socket slot */
    for (int i = 0; i < MAX_SOCKETS; i++) {
        if (!g_net_state.socket_table[i].in_use) {
            socket_info_t* sock = &g_net_state.socket_table[i];
            k_memset(sock, 0, sizeof(socket_info_t));
            
            sock->in_use = true;
            sock->type = type;
            sock->protocol = protocol;
            sock->state = SOCK_STATE_CREATED;
            sock->local_port = 0;
            sock->remote_port = 0;
            
            /* Create socket structure */
            socket_t* socket = (socket_t*)vmm_kmalloc(sizeof(socket_t), 16);
            if (!socket) {
                sock->in_use = false;
                return STATUS_NOMEM;
            }
            
            socket->id = i;
            socket->type = type;
            socket->protocol = protocol;
            socket->state = SOCK_STATE_CREATED;
            
            *out = socket;
            return STATUS_OK;
        }
    }
    
    *out = NULL;
    return STATUS_ERROR;  /* No free sockets */
}

status_t net_socket_bind(socket_t* socket, const ipv4_addr_t* ip, uint16_t port) {
    if (!socket || socket->id >= MAX_SOCKETS || !g_net_state.socket_table[socket->id].in_use) {
        return STATUS_ERROR;
    }
    
    socket_info_t* sock_info = &g_net_state.socket_table[socket->id];
    
    if (ip) {
        sock_info->local_addr = *ip;
    } else {
        /* Bind to any interface */
        k_memset(&sock_info->local_addr, 0, sizeof(ipv4_addr_t));
    }
    
    sock_info->local_port = port;
    sock_info->state = SOCK_STATE_BOUND;
    socket->state = SOCK_STATE_BOUND;
    
    return STATUS_OK;
}

status_t net_socket_connect(socket_t* socket, const ipv4_addr_t* ip, uint16_t port) {
    if (!socket || !ip || socket->id >= MAX_SOCKETS || !g_net_state.socket_table[socket->id].in_use) {
        return STATUS_ERROR;
    }
    
    socket_info_t* sock_info = &g_net_state.socket_table[socket->id];
    
    sock_info->remote_addr = *ip;
    sock_info->remote_port = port;
    sock_info->state = SOCK_STATE_CONNECTED;
    socket->state = SOCK_STATE_CONNECTED;
    
    return STATUS_OK;
}

status_t net_socket_close(socket_t* socket) {
    if (!socket || socket->id >= MAX_SOCKETS || !g_net_state.socket_table[socket->id].in_use) {
        return STATUS_ERROR;
    }
    
    socket_info_t* sock_info = &g_net_state.socket_table[socket->id];
    k_memset(sock_info, 0, sizeof(socket_info_t));
    sock_info->in_use = false;
    
    vmm_kfree(socket, sizeof(socket_t));
    
    return STATUS_OK;
}

status_t net_get_stats(net_stats_t* stats) {
    if (!stats) return STATUS_ERROR;
    
    *stats = g_net_state.stats;
    return STATUS_OK;
}

/* UDP implementation */
status_t udp_send(socket_t* socket, const void* data, size_t len) {
    if (!socket || !data || len == 0 || socket->id >= MAX_SOCKETS) {
        return STATUS_ERROR;
    }
    
    socket_info_t* sock_info = &g_net_state.socket_table[socket->id];
    
    if (sock_info->type != SOCKET_UDP || sock_info->state != SOCK_STATE_CONNECTED) {
        return STATUS_ERROR;
    }
    
    /* Build UDP header */
    size_t udp_len = sizeof(udp_header_t) + len;
    uint8_t* udp_packet = (uint8_t*)vmm_kmalloc(udp_len, 16);
    if (!udp_packet) return STATUS_NOMEM;
    
    udp_header_t* udp_hdr = (udp_header_t*)udp_packet;
    udp_hdr->src_port = htons(sock_info->local_port);
    udp_hdr->dst_port = htons(sock_info->remote_port);
    udp_hdr->length = htons(udp_len);
    udp_hdr->checksum = 0;  /* Optional for IPv4 */
    
    /* Copy payload */
    k_memcpy(udp_packet + sizeof(udp_header_t), data, len);
    
    /* Send via IP */
    net_interface_t* iface = net_get_interface(0);
    status_t result = STATUS_ERROR;
    if (iface) {
        result = ip_send_packet(iface, &sock_info->remote_addr, IP_PROTO_UDP, udp_packet, udp_len);
    }
    
    vmm_kfree(udp_packet, udp_len);
    return result;
}

ssize_t udp_recv(socket_t* socket, void* buffer, size_t len) {
    if (!socket || !buffer || len == 0 || socket->id >= MAX_SOCKETS) {
        return -1;
    }
    
    socket_info_t* sock_info = &g_net_state.socket_table[socket->id];
    
    if (sock_info->type != SOCKET_UDP) {
        return -1;
    }
    
    /* For now, always return 0 (no data available) */
    /* Real implementation would have receive queues */
    return 0;
}
