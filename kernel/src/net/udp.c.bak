#include "kernel.h"
#include "net/net.h"
#include "net_ipc_hooks.h"

#pragma pack(push,1)
typedef struct {
    u16 src;
    u16 dst;
    u16 len;
    u16 csum;
} udp_hdr_t;
#pragma pack(pop)

/* UDP sockets and RX queues */
typedef struct {
    u8  buf[1500];
    u32 len;
    u32 src_ip_be;
    u16 src_port_be;
    int valid;
} udp_queue_entry_t;

typedef struct {
    int  in_use;
    u16  lport_be;
    net_if_t* nif;
    udp_queue_entry_t q[8];
    u32 rd, wr;
} udp_sock_t;

#define MAX_UDP_SOCK 32
static udp_sock_t g_usock[MAX_UDP_SOCK];
static u16 g_ephemeral_next = 49152;

static u16 alloc_ephemeral_port_be(void) {
    u16 p = g_ephemeral_next++;
    if (g_ephemeral_next == 65535) g_ephemeral_next = 49152;
    return net_htons(p);
}

int udp_socket_open(void) {
    for (int i=0;i<MAX_UDP_SOCK;i++) {
        if (!g_usock[i].in_use) {
            k_memset(&g_usock[i], 0, sizeof(g_usock[i]));
            g_usock[i].in_use = 1;
            g_usock[i].lport_be = 0; /* assigned on first send if needed */
            return i + 1; /* handle */
        }
    }
    return K_ENOSPC;
}

int udp_bind(sock_t s, const sockaddr_in_t* addr) {
    if (s <= 0 || s > MAX_UDP_SOCK || !addr) {
        return K_EINVAL;
    }
    
    udp_sock_t* sock = &g_usock[s - 1];
    if (!sock->in_use) {
        return K_EBADF;
    }
    
    sock->lport_be = addr->sin_port; /* Already in network byte order */
    return 0;
}

int udp_send(sock_t s, const void* data, u32 len) {
    if (s <= 0 || s > MAX_UDP_SOCK || !data) {
        return K_EINVAL;
    }
    
    udp_sock_t* sock = &g_usock[s - 1];
    if (!sock->in_use) {
        return K_EBADF;
    }
    
    /* TODO: Use connected remote address for connected UDP sockets */
    /* For now, return error - use sendto for UDP */
    return K_ENOTCONN;
}

int udp_sendto(int sid, const void* data, u32 len, u32 dst_ip_be, u16 dst_port_be) {
    if (sid <= 0 || sid > MAX_UDP_SOCK) return K_EBADF;
    udp_sock_t* s = &g_usock[sid-1];
    net_if_t* nif = s->nif;
    if (!nif) {
        extern net_if_t* _net_first_if(void);
        nif = _net_first_if();
    if (!nif) return K_ENOMEM;
        s->nif = nif;
    }
    if (s->lport_be == 0) s->lport_be = alloc_ephemeral_port_be();

    if (len > 1472) len = 1472; /* keep under MTU for simplicity */
    u8 pkt[8 + 1472];
    udp_hdr_t* uh = (udp_hdr_t*)pkt;
    uh->src = s->lport_be;
    uh->dst = dst_port_be;
    uh->len = net_htons((u16)(8 + len));
    uh->csum = 0; /* IPv4 UDP checksum optional */
    k_memcpy(pkt + 8, data, len);

    int rc = ipv4_send_packet(nif, 17, dst_ip_be, pkt, (u16)(8 + len));
    if (rc==0) __net_emit_packet_tx(0 /*src ip unknown here*/, dst_ip_be, 17, s->lport_be, dst_port_be, data, len);
    return rc;
}

int udp_recvfrom(sock_t s, void* buf, u32 len, u32* src_ip_be, u16* src_port_be) {
    if (s <= 0 || s > MAX_UDP_SOCK) return K_EBADF;
    udp_sock_t* us = &g_usock[s-1];
    /* Block until data arrives */
    for (;;) {
        if (us->rd != us->wr && us->q[us->rd % 8].valid) break;
        net_pump();
        __asm__ __volatile__("pause");
    }
    udp_queue_entry_t* qent = &us->q[us->rd++ % 8];
    u32 n = (len < qent->len) ? len : qent->len;
    k_memcpy(buf, qent->buf, n);
    if (src_ip_be) *src_ip_be = qent->src_ip_be;
    if (src_port_be) *src_port_be = qent->src_port_be;
    qent->valid = 0;
    return (int)n;
}

/* Inbound demux from IPv4 */
void udp_input(net_if_t* nif, const u8* pkt, u32 len) {
    if (len < 8) return;
    const udp_hdr_t* uh = (const udp_hdr_t*)pkt;
    u16 dport = uh->dst;
    u16 ulen = net_ntohs(uh->len);
    if (ulen > len) ulen = (u16)len;
    const u8* payload = pkt + 8;
    u32 plen = ulen - 8;
    __net_emit_packet_rx(0 /*src ip unavailable*/, 0 /*dst ip*/, 17, uh->src, uh->dst, payload, plen);

    /* Deliver to any socket with matching lport */
    for (int i=0;i<MAX_UDP_SOCK;i++) {
        udp_sock_t* s = &g_usock[i];
        if (!s->in_use) continue;
        /* If socket not bound, allow implicit bind on first receive to this port */
        if (s->lport_be == 0) s->lport_be = dport;
        if (s->lport_be == dport) {
            udp_queue_entry_t* e = &s->q[s->wr % 8];
            if (!e->valid) {
                u32 n = plen; if (n > sizeof(e->buf)) n = sizeof(e->buf);
                k_memcpy(e->buf, payload, n);
                e->len = n;
                /* src ip/port are unknown without outer IP header; leave zero for now */
                e->src_ip_be = 0;
                e->src_port_be = uh->src;
                e->valid = 1;
                s->wr++;
            }
        }
    }
}

/* Initialize UDP subsystem */
void udp_init(void) {
    k_memset(g_usock, 0, sizeof(g_usock));
    g_ephemeral_next = 49152;
}

/* UDP socket management for socket API */
int udp_socket_create(sock_t s) {
    if (s <= 0 || s > MAX_UDP_SOCK) {
        return K_EINVAL;
    }
    
    udp_sock_t* sock = &g_usock[s - 1];
    k_memset(sock, 0, sizeof(udp_sock_t));
    sock->in_use = 1;
    return 0;
}

int udp_socket_destroy(sock_t s) {
    if (s <= 0 || s > MAX_UDP_SOCK) {
        return K_EINVAL;
    }
    
    udp_sock_t* sock = &g_usock[s - 1];
    k_memset(sock, 0, sizeof(udp_sock_t));
    return 0;
}