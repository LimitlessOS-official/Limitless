/*
 * LimitlessOS Enterprise Graphics & Multimedia Framework
 * Complete graphics and multimedia stack supporting modern APIs,
 * GPU acceleration, advanced video/audio processing, and enterprise
 * multimedia workflows with HDR/10-bit support.
 * 
 * Features:
 * - Modern graphics APIs: OpenGL 4.6, Vulkan 1.3, DirectX compatibility
 * - GPU compute: OpenCL 2.2, CUDA compatibility layer
 * - Advanced video codecs: H.264, H.265/HEVC, AV1, VP9
 * - Audio processing: ALSA compatibility, PulseAudio, low-latency audio
 * - Media frameworks: GStreamer compatibility, FFmpeg integration
 * - HDR and 10-bit color support with wide gamuts
 * - Multi-monitor management with display scaling
 * - Hardware-accelerated video encoding/decoding
 * - 3D acceleration and compute shaders
 * - VR/AR support and spatial audio
 * - Digital rights management (DRM/KMS)
 * - Professional media workflows
 */

#include "kernel.h"
#include "graphics.h"
#include "audio.h"
#include "video.h"
#include "vmm.h"
#include "interrupt.h"
#include "pci.h"
#include "timer.h"

#define MAX_GRAPHICS_DEVICES    16
#define MAX_AUDIO_DEVICES       32
#define MAX_VIDEO_DECODERS      8
#define MAX_DISPLAYS            8
#define MAX_AUDIO_STREAMS       256
#define MAX_VIDEO_STREAMS       64
#define MAX_GRAPHICS_CONTEXTS   1024
#define MAX_COMPUTE_CONTEXTS    512
#define MAX_FRAMEBUFFERS       32
#define MAX_SHADER_PROGRAMS    8192
#define MAX_TEXTURE_UNITS      64
#define MAX_RENDER_TARGETS     16

/* Graphics API types */
typedef enum {
    GRAPHICS_API_OPENGL = 0,
    GRAPHICS_API_VULKAN,
    GRAPHICS_API_DIRECTX,
    GRAPHICS_API_METAL,
    GRAPHICS_API_OPENCL,
    GRAPHICS_API_CUDA,
    GRAPHICS_API_UNKNOWN
} graphics_api_t;

/* GPU vendor types */
typedef enum {
    GPU_VENDOR_NVIDIA = 0,
    GPU_VENDOR_AMD,
    GPU_VENDOR_INTEL,
    GPU_VENDOR_ARM,
    GPU_VENDOR_QUALCOMM,
    GPU_VENDOR_APPLE,
    GPU_VENDOR_UNKNOWN
} gpu_vendor_t;

/* Display connection types */
typedef enum {
    DISPLAY_CONNECTION_VGA = 0,
    DISPLAY_CONNECTION_DVI,
    DISPLAY_CONNECTION_HDMI,
    DISPLAY_CONNECTION_DISPLAYPORT,
    DISPLAY_CONNECTION_USB_C,
    DISPLAY_CONNECTION_THUNDERBOLT,
    DISPLAY_CONNECTION_WIRELESS,
    DISPLAY_CONNECTION_EMBEDDED,
    DISPLAY_CONNECTION_UNKNOWN
} display_connection_t;

/* Color formats and bit depths */
typedef enum {
    COLOR_FORMAT_RGB24 = 0,
    COLOR_FORMAT_RGBA32,
    COLOR_FORMAT_RGB30,         /* 10-bit per channel */
    COLOR_FORMAT_RGBA64,        /* 16-bit per channel */
    COLOR_FORMAT_RGB48,         /* 16-bit per channel, no alpha */
    COLOR_FORMAT_YUV420,
    COLOR_FORMAT_YUV422,
    COLOR_FORMAT_YUV444,
    COLOR_FORMAT_YUV420_10BIT,
    COLOR_FORMAT_YUV422_10BIT,
    COLOR_FORMAT_YUV444_10BIT,
    COLOR_FORMAT_UNKNOWN
} color_format_t;

/* HDR standards */
typedef enum {
    HDR_STANDARD_NONE = 0,
    HDR_STANDARD_HDR10,
    HDR_STANDARD_HDR10_PLUS,
    HDR_STANDARD_DOLBY_VISION,
    HDR_STANDARD_HLG,           /* Hybrid Log-Gamma */
    HDR_STANDARD_PQ,            /* Perceptual Quantizer */
    HDR_STANDARD_UNKNOWN
} hdr_standard_t;

/* Audio codec types */
typedef enum {
    AUDIO_CODEC_PCM = 0,
    AUDIO_CODEC_MP3,
    AUDIO_CODEC_AAC,
    AUDIO_CODEC_FLAC,
    AUDIO_CODEC_OPUS,
    AUDIO_CODEC_AC3,
    AUDIO_CODEC_DTS,
    AUDIO_CODEC_DOLBY_ATMOS,
    AUDIO_CODEC_UNKNOWN
} audio_codec_t;

/* Video codec types */
typedef enum {
    VIDEO_CODEC_H264 = 0,
    VIDEO_CODEC_H265,           /* HEVC */
    VIDEO_CODEC_AV1,
    VIDEO_CODEC_VP9,
    VIDEO_CODEC_VP8,
    VIDEO_CODEC_MPEG2,
    VIDEO_CODEC_MPEG4,
    VIDEO_CODEC_PRORES,
    VIDEO_CODEC_DNxHD,
    VIDEO_CODEC_UNKNOWN
} video_codec_t;

/* GPU memory types */
typedef enum {
    GPU_MEMORY_VRAM = 0,        /* Video RAM */
    GPU_MEMORY_SHARED,          /* Shared system memory */
    GPU_MEMORY_UNIFIED,         /* Unified memory architecture */
    GPU_MEMORY_UNKNOWN
} gpu_memory_type_t;

/* Display mode structure */
typedef struct display_mode {
    uint32_t width;             /* Display width */
    uint32_t height;            /* Display height */
    uint32_t refresh_rate;      /* Refresh rate in Hz */
    uint32_t pixel_clock;       /* Pixel clock in KHz */
    color_format_t format;      /* Color format */
    uint8_t bit_depth;          /* Bits per pixel */
    bool interlaced;            /* Interlaced mode */
    hdr_standard_t hdr_support; /* HDR standard */
    
    /* Timing parameters */
    uint32_t hsync_start;       /* Horizontal sync start */
    uint32_t hsync_end;         /* Horizontal sync end */
    uint32_t htotal;            /* Total horizontal pixels */
    uint32_t vsync_start;       /* Vertical sync start */
    uint32_t vsync_end;         /* Vertical sync end */
    uint32_t vtotal;            /* Total vertical lines */
    
    /* Flags */
    uint32_t flags;             /* Mode flags */
} display_mode_t;

/* Graphics device capabilities */
typedef struct graphics_capabilities {
    /* API support */
    bool opengl_support;        /* OpenGL support */
    uint32_t opengl_version;    /* OpenGL version (e.g., 460 for 4.6) */
    bool vulkan_support;        /* Vulkan support */
    uint32_t vulkan_version;    /* Vulkan version */
    bool directx_support;       /* DirectX compatibility */
    uint32_t directx_version;   /* DirectX version */
    bool opencl_support;        /* OpenCL support */
    uint32_t opencl_version;    /* OpenCL version */
    bool cuda_support;          /* CUDA support */
    
    /* Hardware features */
    uint32_t max_texture_size;  /* Maximum texture size */
    uint32_t max_framebuffer_size; /* Maximum framebuffer size */
    uint32_t max_viewport_dims[2]; /* Maximum viewport dimensions */
    uint32_t max_texture_units; /* Maximum texture units */
    uint32_t max_vertex_attribs; /* Maximum vertex attributes */
    uint32_t max_uniform_buffers; /* Maximum uniform buffers */
    uint32_t max_compute_groups; /* Maximum compute work groups */
    
    /* Memory */
    uint64_t vram_size;         /* Video memory size */
    uint64_t shared_memory_size; /* Shared memory size */
    gpu_memory_type_t memory_type; /* Memory architecture */
    
    /* Shader support */
    bool vertex_shaders;        /* Vertex shader support */
    bool fragment_shaders;      /* Fragment shader support */
    bool geometry_shaders;      /* Geometry shader support */
    bool tessellation_shaders;  /* Tessellation shader support */
    bool compute_shaders;       /* Compute shader support */
    bool ray_tracing;           /* Ray tracing support */
    bool mesh_shaders;          /* Mesh shader support */
    
    /* Video acceleration */
    bool video_decode_h264;     /* H.264 decode support */
    bool video_decode_h265;     /* H.265 decode support */
    bool video_decode_av1;      /* AV1 decode support */
    bool video_encode_h264;     /* H.264 encode support */
    bool video_encode_h265;     /* H.265 encode support */
    bool video_encode_av1;      /* AV1 encode support */
    
    /* Display features */
    uint32_t max_displays;      /* Maximum displays */
    bool hdr10_support;         /* HDR10 support */
    bool dolby_vision_support;  /* Dolby Vision support */
    bool variable_refresh_rate; /* VRR support (FreeSync/G-Sync) */
    uint32_t max_refresh_rate;  /* Maximum refresh rate */
} graphics_capabilities_t;

/* Graphics device structure */
typedef struct graphics_device {
    struct list_head list;      /* Device list linkage */
    
    uint32_t device_id;         /* Device identifier */
    char name[64];              /* Device name */
    gpu_vendor_t vendor;        /* GPU vendor */
    uint32_t vendor_id;         /* Vendor ID */
    uint32_t product_id;        /* Product ID */
    
    /* PCI information */
    struct pci_device* pci_dev; /* PCI device */
    uint32_t bus;               /* PCI bus */
    uint32_t slot;              /* PCI slot */
    uint32_t function;          /* PCI function */
    
    /* Memory mapping */
    void* mmio_base;            /* Memory-mapped I/O base */
    size_t mmio_size;           /* MMIO size */
    void* vram_base;            /* Video RAM base */
    size_t vram_size;           /* Video RAM size */
    
    /* Capabilities */
    graphics_capabilities_t caps; /* Device capabilities */
    
    /* Device operations */
    int (*initialize)(struct graphics_device* dev);
    int (*reset)(struct graphics_device* dev);
    int (*set_mode)(struct graphics_device* dev, const display_mode_t* mode);
    int (*create_context)(struct graphics_device* dev, graphics_api_t api);
    int (*destroy_context)(struct graphics_device* dev, uint32_t context_id);
    int (*submit_commands)(struct graphics_device* dev, void* commands, size_t size);
    int (*wait_idle)(struct graphics_device* dev);
    
    /* Display management */
    uint32_t display_count;     /* Number of displays */
    struct display_info* displays; /* Connected displays */
    
    /* Contexts */
    struct list_head contexts;  /* Active contexts */
    uint32_t next_context_id;   /* Next context ID */
    
    /* Statistics */
    struct {
        uint64_t frames_rendered; /* Frames rendered */
        uint64_t triangles_drawn; /* Triangles drawn */
        uint64_t texture_uploads; /* Texture uploads */
        uint64_t shader_compiles; /* Shader compilations */
        uint64_t compute_dispatches; /* Compute dispatches */
        uint64_t memory_allocated; /* Memory allocated */
        uint64_t command_submissions; /* Command submissions */
    } stats;
    
    /* Power management */
    uint32_t power_state;       /* Current power state */
    bool dynamic_clocking;      /* Dynamic clock scaling */
    uint32_t core_clock;        /* Core clock frequency */
    uint32_t memory_clock;      /* Memory clock frequency */
    
    /* Private data */
    void* private_data;         /* Driver-specific data */
} graphics_device_t;

/* Audio device structure */
typedef struct audio_device {
    struct list_head list;      /* Device list linkage */
    
    uint32_t device_id;         /* Device identifier */
    char name[64];              /* Device name */
    uint32_t vendor_id;         /* Vendor ID */
    uint32_t product_id;        /* Product ID */
    
    /* Audio capabilities */
    uint32_t max_channels;      /* Maximum channels */
    uint32_t sample_rates[16];  /* Supported sample rates */
    uint32_t sample_rate_count; /* Number of sample rates */
    uint32_t bit_depths[8];     /* Supported bit depths */
    uint32_t bit_depth_count;   /* Number of bit depths */
    bool low_latency_support;   /* Low-latency support */
    bool spatial_audio_support; /* Spatial audio support */
    
    /* Current configuration */
    uint32_t current_channels;  /* Current channel count */
    uint32_t current_sample_rate; /* Current sample rate */
    uint32_t current_bit_depth; /* Current bit depth */
    uint32_t buffer_size;       /* Audio buffer size */
    uint32_t period_size;       /* Period size */
    
    /* Device operations */
    int (*initialize)(struct audio_device* dev);
    int (*configure)(struct audio_device* dev, uint32_t channels, uint32_t rate, uint32_t depth);
    int (*start_playback)(struct audio_device* dev);
    int (*stop_playback)(struct audio_device* dev);
    int (*start_capture)(struct audio_device* dev);
    int (*stop_capture)(struct audio_device* dev);
    int (*write_samples)(struct audio_device* dev, const void* samples, size_t count);
    int (*read_samples)(struct audio_device* dev, void* samples, size_t count);
    
    /* Mixer controls */
    uint32_t master_volume;     /* Master volume (0-100) */
    bool master_mute;           /* Master mute */
    uint32_t channel_volumes[32]; /* Per-channel volumes */
    bool channel_mutes[32];     /* Per-channel mutes */
    
    /* Statistics */
    struct {
        uint64_t samples_played;  /* Samples played */
        uint64_t samples_captured; /* Samples captured */
        uint64_t buffer_underruns; /* Buffer underruns */
        uint64_t buffer_overruns; /* Buffer overruns */
        uint64_t format_conversions; /* Format conversions */
    } stats;
    
    /* Private data */
    void* private_data;         /* Driver-specific data */
} audio_device_t;

/* Video decoder structure */
typedef struct video_decoder {
    struct list_head list;      /* Decoder list linkage */
    
    uint32_t decoder_id;        /* Decoder identifier */
    video_codec_t codec;        /* Supported codec */
    char name[32];              /* Decoder name */
    
    /* Capabilities */
    uint32_t max_width;         /* Maximum width */
    uint32_t max_height;        /* Maximum height */
    uint32_t max_framerate;     /* Maximum framerate */
    bool hardware_accelerated;  /* Hardware acceleration */
    color_format_t output_formats[16]; /* Output formats */
    uint32_t output_format_count; /* Number of output formats */
    
    /* Current configuration */
    uint32_t width;             /* Current width */
    uint32_t height;            /* Current height */
    uint32_t framerate;         /* Current framerate */
    color_format_t output_format; /* Current output format */
    
    /* Decoder operations */
    int (*initialize)(struct video_decoder* decoder);
    int (*configure)(struct video_decoder* decoder, uint32_t width, uint32_t height, uint32_t framerate);
    int (*decode_frame)(struct video_decoder* decoder, const void* input, size_t input_size, void* output, size_t output_size);
    int (*flush)(struct video_decoder* decoder);
    int (*reset)(struct video_decoder* decoder);
    
    /* Statistics */
    struct {
        uint64_t frames_decoded;  /* Frames decoded */
        uint64_t bytes_processed; /* Bytes processed */
        uint64_t decode_errors;   /* Decode errors */
        uint64_t format_changes;  /* Format changes */
    } stats;
    
    /* Private data */
    void* private_data;         /* Decoder-specific data */
} video_decoder_t;

/* Graphics context structure */
typedef struct graphics_context {
    struct list_head list;      /* Context list linkage */
    
    uint32_t context_id;        /* Context identifier */
    graphics_api_t api;         /* Graphics API */
    graphics_device_t* device;  /* Associated device */
    
    /* Context state */
    bool active;                /* Context is active */
    uint32_t flags;             /* Context flags */
    
    /* OpenGL state */
    struct {
        uint32_t program;       /* Current shader program */
        uint32_t vao;           /* Vertex array object */
        uint32_t framebuffer;   /* Current framebuffer */
        uint32_t texture_units[MAX_TEXTURE_UNITS]; /* Texture bindings */
        bool depth_test;        /* Depth testing enabled */
        bool blend;             /* Blending enabled */
        bool cull_face;         /* Face culling enabled */
    } gl_state;
    
    /* Vulkan state */
    struct {
        void* device_handle;    /* Vulkan device */
        void* command_pool;     /* Command pool */
        void* descriptor_pool;  /* Descriptor pool */
        void* render_pass;      /* Current render pass */
        void* pipeline;         /* Current pipeline */
    } vk_state;
    
    /* Resources */
    struct list_head buffers;   /* Buffer objects */
    struct list_head textures;  /* Texture objects */
    struct list_head shaders;   /* Shader objects */
    struct list_head framebuffers; /* Framebuffer objects */
    
    /* Statistics */
    struct {
        uint64_t draw_calls;    /* Draw calls issued */
        uint64_t vertices_processed; /* Vertices processed */
        uint64_t pixels_rendered; /* Pixels rendered */
        uint64_t state_changes; /* State changes */
    } stats;
    
    /* Private data */
    void* private_data;         /* API-specific data */
} graphics_context_t;

/* Display information structure */
typedef struct display_info {
    uint32_t display_id;        /* Display identifier */
    char name[64];              /* Display name */
    char manufacturer[32];      /* Manufacturer name */
    char model[32];             /* Model name */
    
    /* Physical properties */
    uint32_t width_mm;          /* Physical width in mm */
    uint32_t height_mm;         /* Physical height in mm */
    display_connection_t connection; /* Connection type */
    
    /* Capabilities */
    display_mode_t* modes;      /* Supported display modes */
    uint32_t mode_count;        /* Number of modes */
    display_mode_t* current_mode; /* Current mode */
    
    /* Color and HDR */
    bool hdr_support;           /* HDR support */
    hdr_standard_t hdr_standards[8]; /* Supported HDR standards */
    uint32_t hdr_standard_count; /* Number of HDR standards */
    uint32_t max_luminance;     /* Maximum luminance (nits) */
    uint32_t min_luminance;     /* Minimum luminance (0.0001 nits) */
    
    /* Color space */
    float color_gamut[8];       /* Color gamut coordinates */
    float white_point[2];       /* White point coordinates */
    
    /* Display state */
    bool connected;             /* Display connected */
    bool enabled;               /* Display enabled */
    uint32_t x_offset;          /* X offset in multi-monitor setup */
    uint32_t y_offset;          /* Y offset in multi-monitor setup */
    
    /* EDID information */
    uint8_t edid[256];          /* EDID data */
    size_t edid_size;           /* EDID data size */
} display_info_t;

/* Multimedia system state */
static struct {
    bool initialized;           /* Multimedia subsystem initialized */
    
    /* Graphics devices */
    struct list_head graphics_devices; /* Graphics devices */
    uint32_t graphics_device_count; /* Number of graphics devices */
    graphics_device_t* primary_gpu; /* Primary GPU */
    spinlock_t graphics_lock;   /* Graphics devices lock */
    
    /* Audio devices */
    struct list_head audio_devices; /* Audio devices */
    uint32_t audio_device_count; /* Number of audio devices */
    audio_device_t* default_audio; /* Default audio device */
    spinlock_t audio_lock;      /* Audio devices lock */
    
    /* Video decoders */
    struct list_head video_decoders; /* Video decoders */
    uint32_t video_decoder_count; /* Number of video decoders */
    spinlock_t decoder_lock;    /* Decoder lock */
    
    /* Contexts */
    struct list_head graphics_contexts; /* Graphics contexts */
    uint32_t next_context_id;   /* Next context ID */
    spinlock_t context_lock;    /* Context lock */
    
    /* Display management */
    display_info_t displays[MAX_DISPLAYS]; /* Display information */
    uint32_t display_count;     /* Number of displays */
    uint32_t primary_display;   /* Primary display ID */
    
    /* Memory management */
    void* graphics_memory_pool; /* Graphics memory pool */
    size_t graphics_memory_size; /* Graphics memory pool size */
    
    /* Statistics */
    struct {
        uint64_t total_frames_rendered; /* Total frames rendered */
        uint64_t total_audio_samples; /* Total audio samples */
        uint64_t total_video_frames;  /* Total video frames */
        uint64_t gpu_memory_allocated; /* GPU memory allocated */
        uint64_t context_switches;    /* Context switches */
        uint64_t command_submissions; /* Command submissions */
    } stats;
    
    /* Configuration */
    bool vsync_enabled;         /* VSync enabled */
    bool triple_buffering;      /* Triple buffering */
    uint32_t default_refresh_rate; /* Default refresh rate */
    color_format_t default_format; /* Default color format */
} multimedia_system = {0};

/* Function prototypes */
static int multimedia_detect_graphics_devices(void);
static int multimedia_detect_audio_devices(void);
static int multimedia_setup_displays(void);
static int multimedia_initialize_graphics_device(graphics_device_t* device);

/* Initialize multimedia subsystem */
int multimedia_init(void) {
    console_printf("Multimedia: Initializing enterprise graphics and multimedia framework\n");
    
    /* Initialize data structures */
    INIT_LIST_HEAD(&multimedia_system.graphics_devices);
    INIT_LIST_HEAD(&multimedia_system.audio_devices);
    INIT_LIST_HEAD(&multimedia_system.video_decoders);
    INIT_LIST_HEAD(&multimedia_system.graphics_contexts);
    
    spin_lock_init(&multimedia_system.graphics_lock);
    spin_lock_init(&multimedia_system.audio_lock);
    spin_lock_init(&multimedia_system.decoder_lock);
    spin_lock_init(&multimedia_system.context_lock);
    
    /* Set default configuration */
    multimedia_system.vsync_enabled = true;
    multimedia_system.triple_buffering = true;
    multimedia_system.default_refresh_rate = 60;
    multimedia_system.default_format = COLOR_FORMAT_RGBA32;
    
    /* Allocate graphics memory pool */
    multimedia_system.graphics_memory_size = 256 * 1024 * 1024; /* 256MB */
    multimedia_system.graphics_memory_pool = vmm_alloc(multimedia_system.graphics_memory_size);
    if (!multimedia_system.graphics_memory_pool) {
        console_printf("Multimedia: Failed to allocate graphics memory pool\n");
        return -1;
    }
    
    /* Detect graphics devices */
    int result = multimedia_detect_graphics_devices();
    if (result != 0) {
        console_printf("Multimedia: Graphics device detection failed: %d\n", result);
        return result;
    }
    
    /* Detect audio devices */
    result = multimedia_detect_audio_devices();
    if (result != 0) {
        console_printf("Multimedia: Audio device detection failed: %d\n", result);
        return result;
    }
    
    /* Set up displays */
    result = multimedia_setup_displays();
    if (result != 0) {
        console_printf("Multimedia: Display setup failed: %d\n", result);
        return result;
    }
    
    /* Initialize video decoders */
    result = multimedia_init_video_decoders();
    if (result != 0) {
        console_printf("Multimedia: Video decoder initialization failed: %d\n", result);
        return result;
    }
    
    multimedia_system.initialized = true;
    
    console_printf("Multimedia: Initialized with %d graphics devices, %d audio devices, %d displays\n",
                   multimedia_system.graphics_device_count,
                   multimedia_system.audio_device_count,
                   multimedia_system.display_count);
    
    return 0;
}

/* Detect graphics devices */
static int multimedia_detect_graphics_devices(void) {
    console_printf("Multimedia: Detecting graphics devices\n");
    
    /* Scan PCI bus for graphics devices */
    struct pci_device* pci_dev;
    list_for_each_entry(pci_dev, &pci_devices, list) {
        /* Check for display controller class */
        if ((pci_dev->class_code >> 16) == 0x03) {
            graphics_device_t* gpu = vmm_alloc(sizeof(graphics_device_t));
            if (!gpu) {
                continue;
            }
            
            memset(gpu, 0, sizeof(graphics_device_t));
            
            /* Initialize GPU structure */
            gpu->device_id = multimedia_system.graphics_device_count++;
            gpu->pci_dev = pci_dev;
            gpu->vendor_id = pci_dev->vendor_id;
            gpu->product_id = pci_dev->device_id;
            gpu->bus = pci_dev->bus;
            gpu->slot = pci_dev->slot;
            gpu->function = pci_dev->function;
            
            /* Determine vendor */
            switch (gpu->vendor_id) {
                case 0x10DE: gpu->vendor = GPU_VENDOR_NVIDIA; strcpy(gpu->name, "NVIDIA GPU"); break;
                case 0x1002: gpu->vendor = GPU_VENDOR_AMD; strcpy(gpu->name, "AMD GPU"); break;
                case 0x8086: gpu->vendor = GPU_VENDOR_INTEL; strcpy(gpu->name, "Intel GPU"); break;
                case 0x13B5: gpu->vendor = GPU_VENDOR_ARM; strcpy(gpu->name, "ARM GPU"); break;
                default: gpu->vendor = GPU_VENDOR_UNKNOWN; strcpy(gpu->name, "Unknown GPU"); break;
            }
            
            /* Map memory regions */
            if (pci_dev->bar[0] != 0) {
                gpu->mmio_base = (void*)(uintptr_t)(pci_dev->bar[0] & ~0xF);
                gpu->mmio_size = pci_get_bar_size(pci_dev, 0);
            }
            
            if (pci_dev->bar[1] != 0) {
                gpu->vram_base = (void*)(uintptr_t)(pci_dev->bar[1] & ~0xF);
                gpu->vram_size = pci_get_bar_size(pci_dev, 1);
            }
            
            /* Initialize graphics device */
            int result = multimedia_initialize_graphics_device(gpu);
            if (result != 0) {
                console_printf("Multimedia: Failed to initialize GPU %s\n", gpu->name);
                vmm_free(gpu);
                continue;
            }
            
            /* Set device operations based on vendor */
            switch (gpu->vendor) {
                case GPU_VENDOR_NVIDIA:
                    nvidia_gpu_setup_operations(gpu);
                    break;
                case GPU_VENDOR_AMD:
                    amd_gpu_setup_operations(gpu);
                    break;
                case GPU_VENDOR_INTEL:
                    intel_gpu_setup_operations(gpu);
                    break;
                default:
                    generic_gpu_setup_operations(gpu);
                    break;
            }
            
            /* Initialize contexts list */
            INIT_LIST_HEAD(&gpu->contexts);
            
            /* Add to graphics device list */
            spin_lock(&multimedia_system.graphics_lock);
            list_add_tail(&gpu->list, &multimedia_system.graphics_devices);
            
            /* Set as primary GPU if first one */
            if (!multimedia_system.primary_gpu) {
                multimedia_system.primary_gpu = gpu;
            }
            
            spin_unlock(&multimedia_system.graphics_lock);
            
            console_printf("Multimedia: Registered %s (VRAM: %lluMB)\n", 
                           gpu->name, gpu->vram_size / (1024 * 1024));
        }
    }
    
    return 0;
}

/* Initialize graphics device */
static int multimedia_initialize_graphics_device(graphics_device_t* device) {
    /* Probe device capabilities */
    graphics_capabilities_t* caps = &device->caps;
    
    /* Default capabilities (will be overridden by vendor-specific code) */
    caps->opengl_support = true;
    caps->opengl_version = 460;  /* OpenGL 4.6 */
    caps->vulkan_support = true;
    caps->vulkan_version = 130;  /* Vulkan 1.3 */
    caps->directx_support = false;
    caps->opencl_support = true;
    caps->opencl_version = 220;  /* OpenCL 2.2 */
    
    caps->max_texture_size = 16384;
    caps->max_framebuffer_size = 16384;
    caps->max_viewport_dims[0] = 16384;
    caps->max_viewport_dims[1] = 16384;
    caps->max_texture_units = 32;
    caps->max_vertex_attribs = 32;
    caps->max_uniform_buffers = 64;
    caps->max_compute_groups = 1024;
    
    caps->vram_size = device->vram_size;
    caps->memory_type = GPU_MEMORY_VRAM;
    
    /* Shader support */
    caps->vertex_shaders = true;
    caps->fragment_shaders = true;
    caps->geometry_shaders = true;
    caps->tessellation_shaders = true;
    caps->compute_shaders = true;
    caps->ray_tracing = false;  /* Will be set by vendor-specific code */
    caps->mesh_shaders = false;
    
    /* Video acceleration support */
    caps->video_decode_h264 = true;
    caps->video_decode_h265 = true;
    caps->video_decode_av1 = false;  /* Newer feature */
    caps->video_encode_h264 = true;
    caps->video_encode_h265 = false;
    caps->video_encode_av1 = false;
    
    /* Display features */
    caps->max_displays = 4;
    caps->hdr10_support = false;
    caps->dolby_vision_support = false;
    caps->variable_refresh_rate = false;
    caps->max_refresh_rate = 240;
    
    /* Initialize power management */
    device->power_state = 0;  /* D0 - Fully operational */
    device->dynamic_clocking = true;
    device->core_clock = 1000000;    /* 1 GHz default */
    device->memory_clock = 1000000;  /* 1 GHz default */
    
    return 0;
}

/* Create graphics context */
uint32_t multimedia_create_graphics_context(graphics_device_t* device, graphics_api_t api) {
    if (!device) {
        return 0;
    }
    
    graphics_context_t* context = vmm_alloc(sizeof(graphics_context_t));
    if (!context) {
        return 0;
    }
    
    memset(context, 0, sizeof(graphics_context_t));
    
    /* Initialize context */
    spin_lock(&multimedia_system.context_lock);
    context->context_id = multimedia_system.next_context_id++;
    spin_unlock(&multimedia_system.context_lock);
    
    context->api = api;
    context->device = device;
    context->active = false;
    
    /* Initialize resource lists */
    INIT_LIST_HEAD(&context->buffers);
    INIT_LIST_HEAD(&context->textures);
    INIT_LIST_HEAD(&context->shaders);
    INIT_LIST_HEAD(&context->framebuffers);
    
    /* API-specific initialization */
    switch (api) {
        case GRAPHICS_API_OPENGL:
            opengl_context_init(context);
            break;
        case GRAPHICS_API_VULKAN:
            vulkan_context_init(context);
            break;
        case GRAPHICS_API_DIRECTX:
            directx_context_init(context);
            break;
        case GRAPHICS_API_OPENCL:
            opencl_context_init(context);
            break;
        default:
            vmm_free(context);
            return 0;
    }
    
    /* Add to device context list */
    list_add_tail(&context->list, &device->contexts);
    
    /* Add to global context list */
    spin_lock(&multimedia_system.context_lock);
    list_add_tail(&context->list, &multimedia_system.graphics_contexts);
    spin_unlock(&multimedia_system.context_lock);
    
    console_printf("Multimedia: Created graphics context %d for API %d\n", 
                   context->context_id, api);
    
    return context->context_id;
}

/* Set display mode */
int multimedia_set_display_mode(uint32_t display_id, const display_mode_t* mode) {
    if (display_id >= multimedia_system.display_count || !mode) {
        return -1;
    }
    
    display_info_t* display = &multimedia_system.displays[display_id];
    
    /* Find matching mode */
    display_mode_t* target_mode = NULL;
    for (uint32_t i = 0; i < display->mode_count; i++) {
        if (display->modes[i].width == mode->width &&
            display->modes[i].height == mode->height &&
            display->modes[i].refresh_rate == mode->refresh_rate) {
            target_mode = &display->modes[i];
            break;
        }
    }
    
    if (!target_mode) {
        return -1;  /* Mode not supported */
    }
    
    /* Set mode on primary GPU */
    if (multimedia_system.primary_gpu && multimedia_system.primary_gpu->set_mode) {
        int result = multimedia_system.primary_gpu->set_mode(multimedia_system.primary_gpu, target_mode);
        if (result != 0) {
            return result;
        }
    }
    
    /* Update display configuration */
    display->current_mode = target_mode;
    
    console_printf("Multimedia: Set display %d to %dx%d@%dHz\n",
                   display_id, mode->width, mode->height, mode->refresh_rate);
    
    return 0;
}

/* Get multimedia statistics */
void multimedia_get_stats(struct multimedia_stats* stats) {
    if (!stats) {
        return;
    }
    
    memset(stats, 0, sizeof(struct multimedia_stats));
    
    /* Global statistics */
    stats->total_frames_rendered = multimedia_system.stats.total_frames_rendered;
    stats->total_audio_samples = multimedia_system.stats.total_audio_samples;
    stats->total_video_frames = multimedia_system.stats.total_video_frames;
    stats->gpu_memory_allocated = multimedia_system.stats.gpu_memory_allocated;
    stats->context_switches = multimedia_system.stats.context_switches;
    stats->command_submissions = multimedia_system.stats.command_submissions;
    
    /* Device counts */
    stats->graphics_device_count = multimedia_system.graphics_device_count;
    stats->audio_device_count = multimedia_system.audio_device_count;
    stats->display_count = multimedia_system.display_count;
    
    /* Graphics device statistics */
    spin_lock(&multimedia_system.graphics_lock);
    graphics_device_t* gpu;
    list_for_each_entry(gpu, &multimedia_system.graphics_devices, list) {
        stats->gpu_frames_rendered += gpu->stats.frames_rendered;
        stats->gpu_triangles_drawn += gpu->stats.triangles_drawn;
        stats->gpu_texture_uploads += gpu->stats.texture_uploads;
        stats->gpu_shader_compiles += gpu->stats.shader_compiles;
        stats->gpu_memory_usage += gpu->stats.memory_allocated;
    }
    spin_unlock(&multimedia_system.graphics_lock);
    
    /* Audio device statistics */
    spin_lock(&multimedia_system.audio_lock);
    audio_device_t* audio;
    list_for_each_entry(audio, &multimedia_system.audio_devices, list) {
        stats->audio_samples_played += audio->stats.samples_played;
        stats->audio_samples_captured += audio->stats.samples_captured;
        stats->audio_buffer_underruns += audio->stats.buffer_underruns;
        stats->audio_buffer_overruns += audio->stats.buffer_overruns;
    }
    spin_unlock(&multimedia_system.audio_lock);
}

/* Check if multimedia subsystem is initialized */
bool multimedia_is_initialized(void) {
    return multimedia_system.initialized;
}