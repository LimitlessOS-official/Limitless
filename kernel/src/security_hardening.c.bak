/*
 * LimitlessOS Production Kernel - KASLR and Security Hardening
 * Kernel Address Space Layout Randomization and Guard Pages
 */

#include "kernel.h"
#include "vmm.h"
#include "pmm.h"
#include "random.h"
#include <stdint.h>
#include <string.h>

/* ============================================================================
 * KERNEL ADDRESS SPACE LAYOUT RANDOMIZATION (KASLR)
 * ============================================================================ */

/* KASLR configuration */
#define KASLR_KERNEL_ALIGN      0x200000    /* 2MB alignment */
#define KASLR_MAX_OFFSET        0x40000000  /* 1GB max offset */
#define KASLR_MIN_OFFSET        0x1000000   /* 16MB min offset */
#define KASLR_ENTROPY_BITS      28          /* Bits of entropy */

/* Virtual address ranges */
#define KERNEL_TEXT_BASE        0xFFFFFFFF80000000ULL
#define KERNEL_DATA_BASE        0xFFFFFFFF90000000ULL
#define KERNEL_HEAP_BASE        0xFFFFFFFFA0000000ULL
#define KERNEL_STACK_BASE       0xFFFFFFFFB0000000ULL
#define KERNEL_MODULES_BASE     0xFFFFFFFFC0000000ULL
#define KERNEL_PERCPU_BASE      0xFFFFFFFFD0000000ULL
#define KERNEL_VSYSCALL_BASE    0xFFFFFFFFE0000000ULL

typedef struct kaslr_layout {
    uintptr_t text_base;
    uintptr_t data_base;
    uintptr_t heap_base;
    uintptr_t stack_base;
    uintptr_t modules_base;
    uintptr_t percpu_base;
    uintptr_t vsyscall_base;
    
    size_t text_size;
    size_t data_size;
    size_t heap_size;
    size_t stack_size;
    size_t modules_size;
    size_t percpu_size;
    
    uint64_t entropy_seed;
} kaslr_layout_t;

static kaslr_layout_t kaslr_layout;
static bool kaslr_enabled = true;

/* Generate cryptographically secure random offset */
static uint64_t kaslr_get_random_offset(uint64_t max_offset) {
    uint64_t entropy = 0;
    
    /* Gather entropy from various sources */
    entropy ^= rdtsc();                    /* CPU timestamp counter */
    entropy ^= get_random_entropy();       /* Hardware RNG if available */
    entropy ^= (uintptr_t)__builtin_return_address(0); /* Stack address */
    
    /* Use entropy to generate offset */
    uint64_t offset = entropy % max_offset;
    
    /* Align to required boundary */
    offset = (offset + KASLR_KERNEL_ALIGN - 1) & ~(KASLR_KERNEL_ALIGN - 1);
    
    /* Ensure minimum offset */
    if (offset < KASLR_MIN_OFFSET) {
        offset = KASLR_MIN_OFFSET;
    }
    
    return offset;
}

/* Initialize KASLR layout */
status_t kaslr_init(void) {
    if (!kaslr_enabled) {
        kprintf("KASLR disabled\n");
        /* Use fixed layout */
        kaslr_layout.text_base = KERNEL_TEXT_BASE;
        kaslr_layout.data_base = KERNEL_DATA_BASE;
        kaslr_layout.heap_base = KERNEL_HEAP_BASE;
        kaslr_layout.stack_base = KERNEL_STACK_BASE;
        kaslr_layout.modules_base = KERNEL_MODULES_BASE;
        kaslr_layout.percpu_base = KERNEL_PERCPU_BASE;
        kaslr_layout.vsyscall_base = KERNEL_VSYSCALL_BASE;
        return STATUS_OK;
    }
    
    /* Generate random offsets for each section */
    uint64_t text_offset = kaslr_get_random_offset(KASLR_MAX_OFFSET);
    uint64_t data_offset = kaslr_get_random_offset(KASLR_MAX_OFFSET);
    uint64_t heap_offset = kaslr_get_random_offset(KASLR_MAX_OFFSET);
    uint64_t stack_offset = kaslr_get_random_offset(KASLR_MAX_OFFSET);
    uint64_t modules_offset = kaslr_get_random_offset(KASLR_MAX_OFFSET);
    uint64_t percpu_offset = kaslr_get_random_offset(KASLR_MAX_OFFSET);
    uint64_t vsyscall_offset = kaslr_get_random_offset(KASLR_MAX_OFFSET);
    
    /* Calculate randomized bases */
    kaslr_layout.text_base = KERNEL_TEXT_BASE + text_offset;
    kaslr_layout.data_base = KERNEL_DATA_BASE + data_offset;
    kaslr_layout.heap_base = KERNEL_HEAP_BASE + heap_offset;
    kaslr_layout.stack_base = KERNEL_STACK_BASE + stack_offset;
    kaslr_layout.modules_base = KERNEL_MODULES_BASE + modules_offset;
    kaslr_layout.percpu_base = KERNEL_PERCPU_BASE + percpu_offset;
    kaslr_layout.vsyscall_base = KERNEL_VSYSCALL_BASE + vsyscall_offset;
    
    /* Store entropy seed */
    kaslr_layout.entropy_seed = rdtsc();
    
    kprintf("KASLR initialized with %d bits of entropy\n", KASLR_ENTROPY_BITS);
    kprintf("  Text base: 0x%016lx (offset: 0x%lx)\n", 
            kaslr_layout.text_base, text_offset);
    kprintf("  Data base: 0x%016lx (offset: 0x%lx)\n", 
            kaslr_layout.data_base, data_offset);
    kprintf("  Heap base: 0x%016lx (offset: 0x%lx)\n", 
            kaslr_layout.heap_base, heap_offset);
    
    return STATUS_OK;
}

/* Get randomized address for kernel section */
uintptr_t kaslr_get_base(uint32_t section) {
    switch (section) {
        case KASLR_TEXT:    return kaslr_layout.text_base;
        case KASLR_DATA:    return kaslr_layout.data_base;
        case KASLR_HEAP:    return kaslr_layout.heap_base;
        case KASLR_STACK:   return kaslr_layout.stack_base;
        case KASLR_MODULES: return kaslr_layout.modules_base;
        case KASLR_PERCPU:  return kaslr_layout.percpu_base;
        case KASLR_VSYSCALL: return kaslr_layout.vsyscall_base;
        default: return 0;
    }
}

/* ============================================================================
 * GUARD PAGE IMPLEMENTATION
 * ============================================================================ */

#define GUARD_PAGE_MAGIC        0x47554152  /* "GUAR" */
#define GUARD_PATTERN_DEAD      0xDEADBEEF
#define GUARD_PATTERN_CANARY    0xCAFEBABE

typedef struct guard_page {
    uint32_t magic;
    uint32_t flags;
    uintptr_t protected_addr;
    size_t protected_size;
    uint64_t alloc_time;
    const char* file;
    uint32_t line;
    const char* function;
    struct guard_page* next;
} guard_page_t;

#define GUARD_FLAG_ACTIVE       0x1
#define GUARD_FLAG_STACK        0x2
#define GUARD_FLAG_HEAP         0x4
#define GUARD_FLAG_READ_ONLY    0x8

static guard_page_t* guard_pages = NULL;
static spinlock_t guard_lock = 0;
static uint64_t guard_violations = 0;
static uint64_t guard_pages_active = 0;

/* Create guard page */
static guard_page_t* create_guard_page(uintptr_t addr, size_t size, uint32_t flags,
                                      const char* file, uint32_t line, const char* func) {
    guard_page_t* guard = kmalloc(sizeof(guard_page_t));
    if (!guard) return NULL;
    
    guard->magic = GUARD_PAGE_MAGIC;
    guard->flags = flags | GUARD_FLAG_ACTIVE;
    guard->protected_addr = addr;
    guard->protected_size = size;
    guard->alloc_time = get_timestamp();
    guard->file = file;
    guard->line = line;
    guard->function = func;
    
    /* Map guard page as non-accessible */
    paddr_t guard_phys = pmm_alloc_page();
    if (!guard_phys) {
        kfree(guard);
        return NULL;
    }
    
    /* Fill guard page with canary pattern */
    void* guard_virt = map_temp_page(guard_phys);
    uint32_t* pattern = (uint32_t*)guard_virt;
    for (size_t i = 0; i < PAGE_SIZE / sizeof(uint32_t); i++) {
        pattern[i] = GUARD_PATTERN_CANARY;
    }
    unmap_temp_page(guard_virt);
    
    /* Map as non-accessible (no read, write, or execute) */
    map_page(get_current_pgd(), addr, guard_phys, PTE_PRESENT);
    
    return guard;
}

/* Add guard pages around allocation */
status_t add_guard_pages(uintptr_t addr, size_t size, uint32_t flags,
                        const char* file, uint32_t line, const char* func) {
    if (!addr || !size) return STATUS_INVALID_PARAMETER;
    
    spin_lock(&guard_lock);
    
    /* Add guard page before allocation */
    uintptr_t guard_before = addr - PAGE_SIZE;
    guard_page_t* guard1 = create_guard_page(guard_before, PAGE_SIZE, flags, file, line, func);
    
    /* Add guard page after allocation */
    uintptr_t guard_after = (addr + size + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
    guard_page_t* guard2 = create_guard_page(guard_after, PAGE_SIZE, flags, file, line, func);
    
    if (guard1) {
        guard1->next = guard_pages;
        guard_pages = guard1;
        guard_pages_active++;
    }
    
    if (guard2) {
        guard2->next = guard_pages;
        guard_pages = guard2;
        guard_pages_active++;
    }
    
    spin_unlock(&guard_lock);
    
    kprintf("Guard pages added: 0x%lx-0x%lx, 0x%lx-0x%lx for allocation 0x%lx (%s:%u)\n",
            guard_before, guard_before + PAGE_SIZE,
            guard_after, guard_after + PAGE_SIZE,
            addr, file ? file : "unknown", line);
    
    return (guard1 && guard2) ? STATUS_OK : STATUS_ERROR;
}

/* Handle guard page violation */
status_t handle_guard_page_violation(uintptr_t fault_addr, uint32_t error_code) {
    spin_lock(&guard_lock);
    
    guard_violations++;
    
    /* Find guard page containing fault address */
    guard_page_t* guard = guard_pages;
    while (guard) {
        if (guard->magic != GUARD_PAGE_MAGIC) {
            kprintf("CORRUPTION: Invalid guard page magic\n");
            break;
        }
        
        if (fault_addr >= guard->protected_addr && 
            fault_addr < guard->protected_addr + guard->protected_size) {
            
            spin_unlock(&guard_lock);
            
            kprintf("GUARD PAGE VIOLATION!\n");
            kprintf("  Fault address: 0x%016lx\n", fault_addr);
            kprintf("  Guard page: 0x%016lx-0x%016lx\n", 
                    guard->protected_addr, 
                    guard->protected_addr + guard->protected_size);
            kprintf("  Allocation: %s:%u in %s()\n", 
                    guard->file ? guard->file : "unknown",
                    guard->line,
                    guard->function ? guard->function : "unknown");
            kprintf("  Error code: 0x%x (%s%s%s)\n", error_code,
                    (error_code & 0x1) ? "present " : "not-present ",
                    (error_code & 0x2) ? "write " : "read ",
                    (error_code & 0x4) ? "user" : "kernel");
            
            /* Check guard page integrity */
            void* guard_virt = map_temp_page(get_page_phys(guard->protected_addr));
            uint32_t* pattern = (uint32_t*)guard_virt;
            bool corrupted = false;
            
            for (size_t i = 0; i < PAGE_SIZE / sizeof(uint32_t); i++) {
                if (pattern[i] != GUARD_PATTERN_CANARY) {
                    kprintf("  Guard corruption at offset 0x%zx: 0x%x\n", 
                            i * sizeof(uint32_t), pattern[i]);
                    corrupted = true;
                }
            }
            
            unmap_temp_page(guard_virt);
            
            if (corrupted) {
                kprintf("  GUARD PAGE CORRUPTED - possible buffer overflow!\n");
            }
            
            /* Generate stack trace */
            print_stack_trace();
            
            /* Kill the offending process */
            process_t* current = process_current();
            if (current) {
                kprintf("  Terminating process %s (PID %u)\n", 
                        current->name, current->pid);
                send_signal(current, SIGSEGV);
            }
            
            return STATUS_ERROR;
        }
        
        guard = guard->next;
    }
    
    spin_unlock(&guard_lock);
    return STATUS_NOT_FOUND;
}

/* Remove guard pages */
status_t remove_guard_pages(uintptr_t addr, size_t size) {
    spin_lock(&guard_lock);
    
    guard_page_t** guard_ptr = &guard_pages;
    uint32_t removed = 0;
    
    while (*guard_ptr) {
        guard_page_t* guard = *guard_ptr;
        
        if (guard->magic != GUARD_PAGE_MAGIC) {
            kprintf("CORRUPTION: Invalid guard page magic during removal\n");
            break;
        }
        
        /* Check if this guard protects the given allocation */
        if ((guard->protected_addr == addr - PAGE_SIZE) ||
            (guard->protected_addr >= addr + size && 
             guard->protected_addr < addr + size + PAGE_SIZE)) {
            
            /* Remove from list */
            *guard_ptr = guard->next;
            
            /* Unmap and free guard page */
            paddr_t guard_phys = get_page_phys(guard->protected_addr);
            unmap_page(get_current_pgd(), guard->protected_addr);
            pmm_free_page(guard_phys);
            
            kfree(guard);
            guard_pages_active--;
            removed++;
        } else {
            guard_ptr = &guard->next;
        }
    }
    
    spin_unlock(&guard_lock);
    
    if (removed > 0) {
        kprintf("Removed %u guard pages for allocation 0x%lx\n", removed, addr);
    }
    
    return removed > 0 ? STATUS_OK : STATUS_NOT_FOUND;
}

/* ============================================================================
 * STACK CANARIES AND PROTECTION
 * ============================================================================ */

#define STACK_CANARY_MAGIC  0x5354414B  /* "STAK" */

/* Per-thread stack canary */
DEFINE_PER_CPU(uint64_t, stack_canary);

static uint64_t master_canary = 0;

/* Initialize stack canaries */
void stack_canary_init(void) {
    /* Generate master canary from entropy */
    master_canary = get_random_entropy() ^ rdtsc() ^ (uintptr_t)&master_canary;
    
    /* Initialize per-CPU canaries */
    for (uint32_t cpu = 0; cpu < get_cpu_count(); cpu++) {
        uint64_t cpu_canary = master_canary ^ cpu ^ rdtsc();
        per_cpu(stack_canary, cpu) = cpu_canary;
    }
    
    kprintf("Stack canaries initialized\n");
}

/* Get current stack canary */
uint64_t get_stack_canary(void) {
    return get_percpu(stack_canary);
}

/* Check stack canary integrity */
bool check_stack_canary(uint64_t expected_canary) {
    uint64_t current_canary = get_stack_canary();
    
    if (current_canary != expected_canary) {
        kprintf("STACK SMASHING DETECTED!\n");
        kprintf("  Expected canary: 0x%016llx\n", expected_canary);
        kprintf("  Current canary:  0x%016llx\n", current_canary);
        kprintf("  XOR difference:  0x%016llx\n", expected_canary ^ current_canary);
        
        print_stack_trace();
        
        process_t* current = process_current();
        if (current) {
            kprintf("  Terminating process %s (PID %u)\n", 
                    current->name, current->pid);
            send_signal(current, SIGABRT);
        }
        
        return false;
    }
    
    return true;
}

/* ============================================================================
 * KERNEL UNIT TESTS
 * ============================================================================ */

typedef struct kernel_test {
    const char* name;
    const char* description;
    status_t (*test_func)(void);
    uint32_t flags;
    uint64_t run_count;
    uint64_t pass_count;
    uint64_t fail_count;
    uint64_t last_run_time;
} kernel_test_t;

#define TEST_FLAG_CRITICAL  0x1
#define TEST_FLAG_SLOW      0x2
#define TEST_FLAG_SMP       0x4

static status_t test_memory_allocation(void) {
    /* Test basic allocation */
    void* ptr1 = kmalloc(1024);
    if (!ptr1) return STATUS_ERROR;
    
    memset(ptr1, 0xAA, 1024);
    
    void* ptr2 = kmalloc(2048);
    if (!ptr2) {
        kfree(ptr1);
        return STATUS_ERROR;
    }
    
    memset(ptr2, 0xBB, 2048);
    
    /* Verify data integrity */
    for (int i = 0; i < 1024; i++) {
        if (((uint8_t*)ptr1)[i] != 0xAA) {
            kfree(ptr1);
            kfree(ptr2);
            return STATUS_ERROR;
        }
    }
    
    kfree(ptr1);
    kfree(ptr2);
    return STATUS_OK;
}

static status_t test_guard_pages(void) {
    /* Allocate memory with guard pages */
    size_t size = PAGE_SIZE;
    uintptr_t addr = (uintptr_t)kmalloc(size + 2 * PAGE_SIZE);
    if (!addr) return STATUS_ERROR;
    
    /* Align to page boundary */
    addr = (addr + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
    
    /* Add guard pages */
    status_t result = add_guard_pages(addr, size, GUARD_FLAG_HEAP, __FILE__, __LINE__, __func__);
    if (FAILED(result)) {
        kfree((void*)addr);
        return result;
    }
    
    /* Write to valid memory */
    memset((void*)addr, 0x55, size);
    
    /* Clean up */
    remove_guard_pages(addr, size);
    kfree((void*)(addr - PAGE_SIZE));
    
    return STATUS_OK;
}

static status_t test_stack_canaries(void) {
    uint64_t canary1 = get_stack_canary();
    uint64_t canary2 = get_stack_canary();
    
    /* Canaries should be consistent */
    if (canary1 != canary2) {
        return STATUS_ERROR;
    }
    
    /* Test canary checking */
    if (!check_stack_canary(canary1)) {
        return STATUS_ERROR;
    }
    
    return STATUS_OK;
}

static status_t test_smp_functionality(void) {
    if (get_cpu_count() < 2) {
        kprintf("Skipping SMP test (only %u CPUs)\n", get_cpu_count());
        return STATUS_OK;
    }
    
    /* Test SMP barrier */
    smp_barrier();
    
    /* Test per-CPU data */
    uint32_t cpu_id1 = get_cpu_id();
    uint32_t cpu_id2 = get_cpu_id();
    
    if (cpu_id1 != cpu_id2) {
        return STATUS_ERROR;
    }
    
    return STATUS_OK;
}

static kernel_test_t kernel_tests[] = {
    {
        .name = "memory_allocation",
        .description = "Basic kernel memory allocation test",
        .test_func = test_memory_allocation,
        .flags = TEST_FLAG_CRITICAL,
    },
    {
        .name = "guard_pages",
        .description = "Guard page protection test",
        .test_func = test_guard_pages,
        .flags = TEST_FLAG_CRITICAL,
    },
    {
        .name = "stack_canaries",
        .description = "Stack canary integrity test",
        .test_func = test_stack_canaries,
        .flags = TEST_FLAG_CRITICAL,
    },
    {
        .name = "smp_functionality",
        .description = "SMP synchronization and per-CPU test",
        .test_func = test_smp_functionality,
        .flags = TEST_FLAG_SMP,
    },
};

static const uint32_t num_kernel_tests = sizeof(kernel_tests) / sizeof(kernel_tests[0]);

/* Run kernel unit tests */
status_t run_kernel_tests(uint32_t test_flags) {
    kprintf("Running kernel unit tests...\n");
    
    uint32_t total_tests = 0;
    uint32_t passed_tests = 0;
    uint32_t failed_tests = 0;
    
    for (uint32_t i = 0; i < num_kernel_tests; i++) {
        kernel_test_t* test = &kernel_tests[i];
        
        /* Skip tests not matching flags */
        if (test_flags && !(test->flags & test_flags)) {
            continue;
        }
        
        total_tests++;
        test->run_count++;
        
        kprintf("  [%u/%u] %s: ", i + 1, num_kernel_tests, test->name);
        
        uint64_t start_time = get_timestamp();
        status_t result = test->test_func();
        uint64_t end_time = get_timestamp();
        
        test->last_run_time = end_time - start_time;
        
        if (SUCCEEDED(result)) {
            test->pass_count++;
            passed_tests++;
            kprintf("PASS (%llu us)\n", test->last_run_time);
        } else {
            test->fail_count++;
            failed_tests++;
            kprintf("FAIL (%llu us)\n", test->last_run_time);
        }
    }
    
    kprintf("\nKernel test results: %u passed, %u failed, %u total\n",
            passed_tests, failed_tests, total_tests);
    
    return failed_tests == 0 ? STATUS_OK : STATUS_ERROR;
}

/* Initialize security subsystem */
status_t security_init(void) {
    status_t result;
    
    /* Initialize KASLR */
    result = kaslr_init();
    if (FAILED(result)) {
        kprintf("ERROR: Failed to initialize KASLR\n");
        return result;
    }
    
    /* Initialize stack canaries */
    stack_canary_init();
    
    /* Run critical tests */
    result = run_kernel_tests(TEST_FLAG_CRITICAL);
    if (FAILED(result)) {
        kprintf("ERROR: Critical kernel tests failed\n");
        return result;
    }
    
    kprintf("Security hardening initialized\n");
    kprintf("- KASLR: %s\n", kaslr_enabled ? "enabled" : "disabled");
    kprintf("- Guard pages: enabled\n");
    kprintf("- Stack canaries: enabled\n");
    kprintf("- Unit tests: passed\n");
    
    return STATUS_OK;
}

/* Security statistics */
void security_print_stats(void) {
    kprintf("SECURITY STATISTICS\n");
    kprintf("===================\n");
    kprintf("Guard page violations: %llu\n", guard_violations);
    kprintf("Active guard pages: %llu\n", guard_pages_active);
    kprintf("KASLR enabled: %s\n", kaslr_enabled ? "yes" : "no");
    
    if (kaslr_enabled) {
        kprintf("KASLR entropy: %u bits\n", KASLR_ENTROPY_BITS);
        kprintf("Current layout offsets:\n");
        kprintf("  Text: 0x%lx\n", kaslr_layout.text_base - KERNEL_TEXT_BASE);
        kprintf("  Data: 0x%lx\n", kaslr_layout.data_base - KERNEL_DATA_BASE);
        kprintf("  Heap: 0x%lx\n", kaslr_layout.heap_base - KERNEL_HEAP_BASE);
    }
}