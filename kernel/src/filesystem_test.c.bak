#include "kernel.h"
#include "vfs.h"
#include "ramdisk.h"
#include "block.h"
#include "log.h"

/*
 * Filesystem Integration Self-Test Suite
 * Tests block device layer, filesystem mounting, and persistent storage
 */

int filesystem_selftest(void) {
    KLOG_INFO("fs_test", "Starting filesystem integration tests");

    // Test 1: Create a RAM disk
    block_dev_t* ramdisk = ramdisk_create("testdisk", 4);  // 4MB
    if (!ramdisk) {
        KLOG_ERROR("fs_test", "Failed to create RAM disk");
        return -1;
    }

    // Test 2: Test block device operations
    char test_data[512] = {0};
    char read_data[512] = {0};
    
    // Fill with test pattern
    for (int i = 0; i < 512; i++) {
        test_data[i] = (char)(i & 0xFF);
    }
    
    int rc = block_write(ramdisk, 0, test_data, 512);
    if (rc != 0) {
        KLOG_ERROR("fs_test", "Block write failed: %d", rc);
        return -2;
    }
    
    rc = block_read(ramdisk, 0, read_data, 512);
    if (rc != 0) {
        KLOG_ERROR("fs_test", "Block read failed: %d", rc);
        return -3;
    }
    
    // Test 3: Verify data integrity
    if (k_memcmp(test_data, read_data, 512) != 0) {
        KLOG_ERROR("fs_test", "Block data integrity check failed");
        return -4;
    }

    // Test 4: Test unaligned I/O
    char unaligned_data[100];
    for (int i = 0; i < 100; i++) {
        unaligned_data[i] = (char)(0x55 + i);
    }
    
    rc = bdev_write_bytes(ramdisk, 100, unaligned_data, 100);
    if (rc != 0) {
        KLOG_ERROR("fs_test", "Unaligned write failed: %d", rc);
        return -5;
    }
    
    char unaligned_read[100];
    rc = bdev_read_bytes(ramdisk, 100, unaligned_read, 100);
    if (rc != 0) {
        KLOG_ERROR("fs_test", "Unaligned read failed: %d", rc);
        return -6;
    }
    
    if (k_memcmp(unaligned_data, unaligned_read, 100) != 0) {
        KLOG_ERROR("fs_test", "Unaligned data integrity check failed");
        return -7;
    }

    // Test 5: Test block device lookup
    block_dev_t* found = block_find_by_name("testdisk");
    if (found != ramdisk) {
        KLOG_ERROR("fs_test", "Block device lookup failed");
        return -8;
    }

    // Test 6: Test filesystem type registration
    const fs_type_t* tmpfs_type = vfs_find_fs("tmpfs");
    if (!tmpfs_type) {
        KLOG_ERROR("fs_test", "tmpfs filesystem type not found");
        return -9;
    }

    const fs_type_t* fat32_type = vfs_find_fs("fat32");
    if (!fat32_type) {
        KLOG_ERROR("fs_test", "fat32 filesystem type not found");
        return -10;
    }

    const fs_type_t* ext4_type = vfs_find_fs("ext4");
    if (!ext4_type) {
        KLOG_ERROR("fs_test", "ext4 filesystem type not found");
        return -11;
    }

    // Test 7: Test filesystem mounting (will fail gracefully for empty disk)
    rc = vfs_mount_device_by_name("fat32", "testdisk", "/mnt/test");
    if (rc == 0) {
        KLOG_INFO("fs_test", "FAT32 mount succeeded (unexpected but OK)");
    } else {
        KLOG_INFO("fs_test", "FAT32 mount failed as expected (empty disk)");
    }

    // Test 8: Directory operations on root tmpfs
    rc = vfs_mkdir_path("/test_fs_dir", 0755);
    if (rc != 0) {
        KLOG_ERROR("fs_test", "Failed to create test directory: %d", rc);
        return -12;
    }

    file_t* test_file = NULL;
    rc = vfs_create_file("/test_fs_dir/test.txt", 0644, &test_file);
    if (rc != 0) {
        KLOG_ERROR("fs_test", "Failed to create test file: %d", rc);
        return -13;
    }

    const char* file_content = "Filesystem test content";
    u64 bytes_written = 0;
    rc = vfs_write(test_file, file_content, k_strlen(file_content), &bytes_written);
    if (rc != 0 || bytes_written != k_strlen(file_content)) {
        KLOG_ERROR("fs_test", "Failed to write test file: %d", rc);
        vfs_close(test_file);
        return -14;
    }

    vfs_close(test_file);

    // Test 9: Read back the file
    file_t* read_file = NULL;
    rc = vfs_open("/test_fs_dir/test.txt", VFS_O_RDONLY, &read_file);
    if (rc != 0) {
        KLOG_ERROR("fs_test", "Failed to open test file for reading: %d", rc);
        return -15;
    }

    char read_content[64];
    u64 bytes_read = 0;
    rc = vfs_read(read_file, read_content, sizeof(read_content), &bytes_read);
    if (rc != 0) {
        KLOG_ERROR("fs_test", "Failed to read test file: %d", rc);
        vfs_close(read_file);
        return -16;
    }

    vfs_close(read_file);

    if (bytes_read != k_strlen(file_content) || 
        k_strncmp(read_content, file_content, bytes_read) != 0) {
        KLOG_ERROR("fs_test", "File content mismatch");
        return -17;
    }

    // Test 10: Cleanup
    rc = vfs_unlink_path("/test_fs_dir/test.txt");
    if (rc != 0) {
        KLOG_ERROR("fs_test", "Failed to remove test file: %d", rc);
        return -18;
    }

    KLOG_INFO("fs_test", "All filesystem integration tests passed");
    return 0;
}